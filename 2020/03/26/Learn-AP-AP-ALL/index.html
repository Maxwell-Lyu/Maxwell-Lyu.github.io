<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    
    
    
    
    <title>Advanced Programming | Maxwell&#39;s Blog | Think &amp; Write</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#1976D2">
    
    
    <meta name="keywords" content="Course,Advanced Programming">
    <meta name="description" content="高级程序设计 课程的重点知识">
<meta name="keywords" content="Course,Advanced Programming">
<meta property="og:type" content="article">
<meta property="og:title" content="Advanced Programming">
<meta property="og:url" content="https://Maxwell-lyu.github.io/2020/03/26/Learn-AP-AP-ALL/index.html">
<meta property="og:site_name" content="Maxwell&#39;s Blog">
<meta property="og:description" content="高级程序设计 课程的重点知识">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2020-05-09T07:25:06.988Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Advanced Programming">
<meta name="twitter:description" content="高级程序设计 课程的重点知识">
    
        <link rel="alternate" type="application/atom+xml" title="Maxwell&#39;s Blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head --><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    

</head>

<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.png)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Maxwell Lyu</h5>
          <a href="mailto:maxwell.lyu@foxmail.com" title="maxwell.lyu@foxmail.com" class="mail">maxwell.lyu@foxmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Index
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/friends"  >
                <i class="icon icon-lg icon-address-book"></i>
                Friends
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/Maxwell-Lyu" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://maxwell-lyu.github.io/"  >
                <i class="icon icon-lg icon-link"></i>
                Link
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Advanced Programming</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Advanced Programming</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-03-26T06:18:33.000Z" itemprop="datePublished" class="page-time">
  2020-03-26
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#15-继承的基本概念和单继承"><span class="post-toc-number">1.</span> <span class="post-toc-text">15.继承的基本概念和单继承</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#继承的基本概念"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">继承的基本概念</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#单继承"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">单继承</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#继承中的访问控制"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">继承中的访问控制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#在派生类中访问基类成员"><span class="post-toc-number">1.3.1.</span> <span class="post-toc-text">在派生类中访问基类成员</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#protected访问控制"><span class="post-toc-number">1.3.2.</span> <span class="post-toc-text">protected访问控制</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#派生类成员标识符的作用域"><span class="post-toc-number">1.3.3.</span> <span class="post-toc-text">派生类成员标识符的作用域</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#继承方式"><span class="post-toc-number">1.3.4.</span> <span class="post-toc-text">继承方式</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#16-派生类的初始化和消亡处理"><span class="post-toc-number">2.</span> <span class="post-toc-text">16.派生类的初始化和消亡处理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#派生类对象的初始化"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">派生类对象的初始化</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#派生类拷贝构造函数"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">派生类拷贝构造函数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#派生类对象的赋值操作"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">派生类对象的赋值操作</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#转移构造函数"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">转移构造函数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#赋值操作符的重载"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">赋值操作符的重载</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#17-消息的多态与动态绑定（虚函数）"><span class="post-toc-number">3.</span> <span class="post-toc-text">17.消息的多态与动态绑定（虚函数）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#多态"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">多态</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#消息的动态绑定"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">消息的动态绑定</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#虚函数与动态绑定的实现-不考"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">虚函数与动态绑定的实现(不考)</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#18-抽象类（纯虚函数）"><span class="post-toc-number">4.</span> <span class="post-toc-text">18.抽象类（纯虚函数）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#纯虚函数"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">纯虚函数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#抽象类"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">抽象类</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#19-多继承"><span class="post-toc-number">5.</span> <span class="post-toc-text">19.多继承</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#20-继承和代码复用"><span class="post-toc-number">6.</span> <span class="post-toc-text">20.继承和代码复用</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#21-泛型-类属-程序设计-模板"><span class="post-toc-number">7.</span> <span class="post-toc-text">21.泛型(类属)程序设计 模板</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#概念"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">概念</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#类属函数"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">类属函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#函数模板"><span class="post-toc-number">7.2.1.</span> <span class="post-toc-text">函数模板</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#类模板"><span class="post-toc-number">7.2.2.</span> <span class="post-toc-text">类模板</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#模板的复用"><span class="post-toc-number">7.2.3.</span> <span class="post-toc-text">模板的复用</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#22-基于STL的编程"><span class="post-toc-number">8.</span> <span class="post-toc-text">22.基于STL的编程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#STL"><span class="post-toc-number">8.1.</span> <span class="post-toc-text">STL</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#容器"><span class="post-toc-number">8.2.</span> <span class="post-toc-text">容器</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#迭代器"><span class="post-toc-number">8.3.</span> <span class="post-toc-text">迭代器</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#算法"><span class="post-toc-number">8.4.</span> <span class="post-toc-text">算法</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#23-输入输出-面向对象"><span class="post-toc-number">9.</span> <span class="post-toc-text">23.输入输出(面向对象)</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#输入-输出（I-O）概述"><span class="post-toc-number">9.1.</span> <span class="post-toc-text">输入/输出（I/O）概述</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面向控制台的I-O"><span class="post-toc-number">9.2.</span> <span class="post-toc-text">面向控制台的I/O</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#控制台输出"><span class="post-toc-number">9.2.1.</span> <span class="post-toc-text">控制台输出</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#控制台输入"><span class="post-toc-number">9.2.2.</span> <span class="post-toc-text">控制台输入</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面向文件的I-O"><span class="post-toc-number">9.3.</span> <span class="post-toc-text">面向文件的I/O</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#文件输出"><span class="post-toc-number">9.3.1.</span> <span class="post-toc-text">文件输出</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#文件输入"><span class="post-toc-number">9.3.2.</span> <span class="post-toc-text">文件输入</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#24-异常处理"><span class="post-toc-number">10.</span> <span class="post-toc-text">24.异常处理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#异常概述"><span class="post-toc-number">10.1.</span> <span class="post-toc-text">异常概述</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#异常的就地处理"><span class="post-toc-number">10.1.1.</span> <span class="post-toc-text">异常的就地处理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#异常的异地处理"><span class="post-toc-number">10.1.2.</span> <span class="post-toc-text">异常的异地处理</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#C-异常处理机制"><span class="post-toc-number">10.2.</span> <span class="post-toc-text">C++异常处理机制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#异常处理的嵌套"><span class="post-toc-number">10.2.1.</span> <span class="post-toc-text">异常处理的嵌套</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#基于断言的程序调试"><span class="post-toc-number">10.3.</span> <span class="post-toc-text">基于断言的程序调试</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#宏ASSERT"><span class="post-toc-number">10.3.1.</span> <span class="post-toc-text">宏ASSERT</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#宏ASSERT的实现"><span class="post-toc-number">10.3.2.</span> <span class="post-toc-text">宏ASSERT的实现</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-Learn-AP-AP-ALL"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Advanced Programming</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-03-26 14:18:33" datetime="2020-03-26T06:18:33.000Z"  itemprop="datePublished">2020-03-26</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>高级程序设计 课程的重点知识<br><a id="more"></a>  </p>
<h1 id="15-继承的基本概念和单继承"><a href="#15-继承的基本概念和单继承" class="headerlink" title="15.继承的基本概念和单继承"></a>15.继承的基本概念和单继承</h1><h2 id="继承的基本概念"><a href="#继承的基本概念" class="headerlink" title="继承的基本概念"></a>继承的基本概念</h2><ul>
<li><strong>继承机制</strong>: 对一个<strong>面向对象的程序</strong>，在定义一个<strong>新的类</strong>时，先把已有程序中的一个或多个类的<strong>功能全部包含</strong>进来，然后在新的类中<strong>再给出新功能</strong>的定义或对已有类的某些功能<strong>重新定义</strong><blockquote>
<p>新类 &lt;== 已有类的功能 + 新功能/已有功能重定义</p>
</blockquote>
</li>
</ul>
<h2 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h2><h2 id="继承中的访问控制"><a href="#继承中的访问控制" class="headerlink" title="继承中的访问控制"></a>继承中的访问控制</h2><h3 id="在派生类中访问基类成员"><a href="#在派生类中访问基类成员" class="headerlink" title="在派生类中访问基类成员"></a>在派生类中访问基类成员</h3><ul>
<li>C++中, 派生类不能直接访问基类的私有成员</li>
<li>继承与封装的矛盾: 派生类可能访问private, 但不允许c’c</li>
<li>实际上，有了继承机制以后，一个类的成员有两种被外界使用的场合：<ul>
<li>通过类的对象（实例）使用</li>
<li>在派生类中使用<h3 id="protected访问控制"><a href="#protected访问控制" class="headerlink" title="protected访问控制"></a>protected访问控制</h3></li>
</ul>
</li>
<li>用protected说明的成员不能通过对象使用，但可以在派生类中使用。</li>
<li>C++类向外界提供两种接口：<ul>
<li>public：对象的使用者（类的实例用户）</li>
<li>public+protected：派生类<h3 id="派生类成员标识符的作用域"><a href="#派生类成员标识符的作用域" class="headerlink" title="派生类成员标识符的作用域"></a>派生类成员标识符的作用域</h3></li>
</ul>
</li>
<li>派生类对基类成员的访问除了受到基类的访问控制的限制以外，还要受到标识符作用域的限制。<ul>
<li>在类中定义的标识符局部于类定义</li>
<li>在类中任何地方都可以访问</li>
<li>在类外使用类中定义的标识符时，需要通过对象名受限或者类名受限</li>
<li>在类中使用与成员标识符同名的全局标识符时，需要在全局标识符前面加上全局域解析符“::”</li>
</ul>
</li>
<li><strong>作用域嵌套</strong>: 对基类而言，派生类成员标识符的作用域是嵌套在基类作用域中的<ul>
<li>派生类可使用基类的标识符</li>
<li>基类不能用基类的标识符</li>
</ul>
</li>
<li><strong>同名成员</strong>: 如果派生类中定义了与基类同名的成员，则基类的成员名在派生类的作用域内不直接可见（被隐藏，Hidden）。<ul>
<li>访问基类同名成员时要用基类名受限</li>
<li>即使派生类中定义了与基类同名但参数不同的成员函数，基类的同名函数在派生类的作用域中也是不直接可见的，可以用基类名受限方式来使用之</li>
<li>也可以在派生类中使用using声明把基类中某个的函数名对派生类开放<h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3>|继承方式\基类成员|public|protected|private|<br>|-|-|-|-|<br>|public|public|protected|不能访问|<br>|protected|protected|protected|不能访问|<br>|private|private|private|不能访问|</li>
</ul>
</li>
</ul>
<blockquote>
<p>原private都不可访问, 其余收紧(选继承方式和基类成员中, 修饰符严格的那个)</p>
</blockquote>
<h1 id="16-派生类的初始化和消亡处理"><a href="#16-派生类的初始化和消亡处理" class="headerlink" title="16.派生类的初始化和消亡处理"></a>16.派生类的初始化和消亡处理</h1><h2 id="派生类对象的初始化"><a href="#派生类对象的初始化" class="headerlink" title="派生类对象的初始化"></a>派生类对象的初始化</h2><ul>
<li><strong>共同完成</strong><ul>
<li>基类继承的成员由基类的构造函数初始化</li>
<li>派生类的数据成员由派生类的构造函数初始化<ul>
<li>派生类构造函数体前, 将调用基类构造函数</li>
</ul>
</li>
</ul>
</li>
<li><p>当<strong>创建派生类的对象</strong>时</p>
<ul>
<li>默认情况下，调用基类的默认构造函数</li>
<li>如果要调用基类的非默认构造函数，则必须在派生类构造函数的成员初始化表中指出<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span>		<span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    A() &#123; x = <span class="number">0</span>; &#125;</span><br><span class="line">    A(<span class="keyword">int</span> i) &#123; x = i; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;		<span class="keyword">int</span> y;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    B() &#123; y = <span class="number">0</span>; &#125;</span><br><span class="line">    B(<span class="keyword">int</span> i) &#123; y = i; &#125;</span><br><span class="line">    B(<span class="keyword">int</span> i, <span class="keyword">int</span> j):A(i) &#123; y = j; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>当<strong>析构派生类的对象</strong>时</p>
<ul>
<li>先执行派生类的析构, 再执行基类的析构</li>
</ul>
</li>
<li>类D同时有基类B和成员类M时:<ul>
<li>构造: D -&gt; M -&gt; A</li>
<li>析构: A -&gt; M -&gt; D<h2 id="派生类拷贝构造函数"><a href="#派生类拷贝构造函数" class="headerlink" title="派生类拷贝构造函数"></a>派生类拷贝构造函数</h2></li>
</ul>
</li>
<li>派生类的隐式拷贝构造函数: 调用基类的<strong>拷贝构造函数</strong></li>
<li>派生类的自定义拷贝构造函数, 自动调用基类的<strong>默认构造函数</strong>, 可在初始化表中指定调用哪个构造函数<h2 id="派生类对象的赋值操作"><a href="#派生类对象的赋值操作" class="headerlink" title="派生类对象的赋值操作"></a>派生类对象的赋值操作</h2></li>
<li>派生类隐式的赋值操作除了对派生类成员进行赋值外，还将调用基类的赋值操作对基类成员进行赋值</li>
<li>派生类自定义的赋值操作符重载函数<strong>不会</strong>自动调用基类的赋值操作，需要在自定义的赋值操作符重载函数中<strong>显式地指出</strong><h2 id="转移构造函数"><a href="#转移构造函数" class="headerlink" title="转移构造函数"></a>转移构造函数</h2></li>
<li>在创建一个对象用另一个同类型的对象对其初始化时，将会调用拷贝构造函数</li>
<li>当用一个临时或即将消亡的对象去初始化另一个同类的对象时，目前的拷贝构造函数的实现效率有时是不高的</li>
<li><strong>转移构造函数</strong>: <code>A(A&amp;&amp; x)</code> 右值引用类型: 不能作为赋值操作符的左操作符</li>
<li>当用一个临时对象或即将消亡的对象去初始化另一个对象时<ul>
<li>如果对象类中有<strong>转移构造函数</strong>，则会去调用转移构造函数来对对象初始化。</li>
<li>否则去调用<strong>拷贝构造函数</strong>进行对象初始化。（注意：系统<strong>不会提供隐式转移</strong>构造函数！）<h2 id="赋值操作符的重载"><a href="#赋值操作符的重载" class="headerlink" title="赋值操作符的重载"></a>赋值操作符的重载</h2></li>
</ul>
</li>
<li>用于赋值的对象是一个临时或即将消亡的对象时，目前的赋值操作符重载函数的实现效率有时是不高的</li>
<li><strong>转移赋值操作符</strong>: <code>A&amp; operator=(A&amp;&amp; x)</code></li>
<li>类似转移构造函数, 并且也需要检测自身赋值</li>
</ul>
<h1 id="17-消息的多态与动态绑定（虚函数）"><a href="#17-消息的多态与动态绑定（虚函数）" class="headerlink" title="17.消息的多态与动态绑定（虚函数）"></a>17.消息的多态与动态绑定（虚函数）</h1><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul>
<li>某个论域中的一个元素存在多种解释<ul>
<li>体现<ul>
<li>函数名重载</li>
<li>操作符重载</li>
</ul>
</li>
<li>类属性(泛型)</li>
</ul>
</li>
<li>子类型<ul>
<li>用类型S替换所有程序P中的类型T, 程序P功能不变, 则S是T的子类型</li>
<li>C++中, 以public方式继承的派生类, 可以看作是基类的子类型</li>
</ul>
</li>
<li>面向对象程序设计的多态性<ul>
<li>对于public继承关系的2个类, c++中存在下面的多态<ul>
<li>一个对象, 多种类型: 派生类的对象的类型, 既可以是派生类, 也可以是基类</li>
<li>一个对象标识, 多种对象: 基类对象的指针, 可以指向派生类对象</li>
<li>消息多态: 可以发送到基类的消息, 也可以发送到派生类<h2 id="消息的动态绑定"><a href="#消息的动态绑定" class="headerlink" title="消息的动态绑定"></a>消息的动态绑定</h2></li>
</ul>
</li>
<li>虚函数: virtual关键字</li>
<li>根据运行时, 实际指向的对象来决定调用哪一个消息</li>
</ul>
</li>
<li>派生类中重定义基类的成员函数<ul>
<li>对于基类中的虚函数, 在派生类中定义的, 与之具有相同型构的函数成员, 是对基类该成员的重定义</li>
<li>型构: 名字, 参数个数和类型, 返回值类型要么相同, 要么是派生类</li>
</ul>
</li>
<li>动态绑定的条件<ul>
<li>基类的指针或引用</li>
<li>访问的是虚函数</li>
<li>基类构造函数和析构函数中, 对虚函数的调用, 不进行动态绑定</li>
</ul>
</li>
<li>几点说明<ul>
<li>只有类的成员函数才能是虚函数, 静态成员函数不能是虚函数</li>
<li>构造函数可以是虚函数, 析构函数可以并且往往是虚函数</li>
<li>只要在基类中说明了虚函数, 派生类的派生类…当中的同型构函数, 也是虚函数, 可不写virtual</li>
</ul>
</li>
<li>运行时刻类型信息: RTTI<ul>
<li>使用<code>dynamic_cast&lt;B *&gt;</code>, 进行类型转换, 之后检查转换是否成功<h2 id="虚函数与动态绑定的实现-不考"><a href="#虚函数与动态绑定的实现-不考" class="headerlink" title="虚函数与动态绑定的实现(不考)"></a>虚函数与动态绑定的实现(不考)</h2></li>
</ul>
</li>
<li>基类对象和派生类对象成员的空间分配<ul>
<li>内存布局: 基类成员低地址, 派生类新成员高地址</li>
<li>内存布局决定, 基类指针可以指向派生类对象</li>
</ul>
</li>
<li>多态的实现<ul>
<li>虚函数表: A, B两类, 分别生成虚函数表</li>
<li>虚函数表指针: 类的对象的指针位置(空间头部), 有指向虚函数表的指针, 据此进行动态绑定</li>
<li>虚函数表项类型: <code>typedef void (*FuncPtr)(void *)</code></li>
<li>虚函数表类型: <code>typedef FuncPtr *VtblPtr</code></li>
</ul>
</li>
<li>纯虚函数: 没有给出实现的虚函数<ul>
<li>函数体: <code>vitrual int f()=0;</code></li>
<li>派生类中, 所有同型构的函数, 都是虚函数</li>
</ul>
</li>
<li>抽象类: 包含纯虚函数的类<ul>
<li>抽象类的作用, 是为派生类提供一个基本框架和公共的对外接口</li>
</ul>
</li>
</ul>
<h1 id="18-抽象类（纯虚函数）"><a href="#18-抽象类（纯虚函数）" class="headerlink" title="18.抽象类（纯虚函数）"></a>18.抽象类（纯虚函数）</h1><h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><ul>
<li>纯虚函数是没给出实现的虚函数，函数体用“=0”表示<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2></li>
<li>包含纯虚函数的类称为抽象类</li>
<li>抽象类不能创建对象</li>
</ul>
<h1 id="19-多继承"><a href="#19-多继承" class="headerlink" title="19.多继承"></a>19.多继承</h1><ul>
<li>多继承是指派生类可以有一个以上的直接基类<ul>
<li>继承方式及访问控制的规定同单继承</li>
<li>派生类拥有所有基类的所有成员</li>
<li>基类的声明次序决定<ul>
<li>对基类构造函数/析构函数的调用次序</li>
<li>对基类数据成员的存储安排</li>
</ul>
</li>
</ul>
</li>
<li>可以把以public继承方式定义的多继承派生类的对象的地址赋给任何一个基类的指针<ul>
<li>这时将会自动进行地址调整: 不同基类指针指向的时候, 指针的值不一样, 指向对应基类数据成员的基地址</li>
</ul>
</li>
<li>名冲突<ul>
<li>使用基类名受限: <code>C c; c.A::f(); c.B::f();</code></li>
</ul>
</li>
<li>重复继承问题(虚基类)<ul>
<li>例如: B-&gt;A, C-&gt;A, D-&gt;(B,C), D从A继承了2次</li>
<li>如果要求D中仅有一个A, 则可以在B, C中, 将A继承为虚基类: <code>class B: virtual public A {};</code></li>
</ul>
</li>
<li>虚基类<ul>
<li>间接包含虚基类的类<ul>
<li>虚基类的构造函数, 由该类的构造函数直接调用(上例为D); 即由最新构造的类调用</li>
</ul>
</li>
</ul>
</li>
<li>虚基类的实现<ul>
<li>一般基类: 内存空间直接连接</li>
<li>虚基类: 虚基类成员移到直接基类最后,原位头留指针指向最后; 简洁派生类同理, 多个指针指向同一个地方<h1 id="20-继承和代码复用"><a href="#20-继承和代码复用" class="headerlink" title="20.继承和代码复用"></a>20.继承和代码复用</h1></li>
</ul>
</li>
<li>C++中, 把类看作类型，把以public方式继承的派生类看作是基类的子类型</li>
<li>具有继承关系的两个类之间通常属于一般与特殊的关系（is-a-kind-of）</li>
<li>聚集<ul>
<li>代码复用的另一种方式是通过聚集（aggregation，也称聚合）来实现，即把一个类作为另一个类（新类）的成员对象类</li>
<li>在基于对象的程序设计中，一般采用聚集来实现代码复用的</li>
</ul>
</li>
<li>继承与封装存在矛盾，聚集则否。<ul>
<li>在继承方式的代码复用中，一个类通过protected访问控制，向外界提供两种接口：<ul>
<li>public：对象（实例）用户</li>
<li>public+protected：派生类用户</li>
</ul>
</li>
<li>在聚集方式的代码复用中，一个类对外只需一个接口：public。</li>
</ul>
</li>
<li>具有聚集关系的两个类不具有子类型关系<h1 id="21-泛型-类属-程序设计-模板"><a href="#21-泛型-类属-程序设计-模板" class="headerlink" title="21.泛型(类属)程序设计 模板"></a>21.泛型(类属)程序设计 模板</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2></li>
<li>泛型: <strong>一个程序实体</strong>能对<strong>多种类型的数据</strong>进行<strong>操作或描述</strong>的特性称为类属或泛型（Generics）。</li>
<li>具有类属特性的程序实体通常有：<ul>
<li>类属函数：一个能对<strong>不同类型的数据</strong>完成<strong>相同操作</strong>的函数。</li>
<li>类属类：一个<strong>成员类型可变</strong>、但<strong>功能不变</strong>的类。</li>
</ul>
</li>
<li>基于具有类属性的程序实体进行程序设计的技术称为：<strong>c泛型程序设计</strong>（或类属程序设计，Generic Programming）。<h2 id="类属函数"><a href="#类属函数" class="headerlink" title="类属函数"></a>类属函数</h2></li>
<li>一个函数能对不同类型的参数完成相同的操作</li>
<li><p>实现机制</p>
<ul>
<li><p>通用指针的参数(C做法): 用通用指针实现类属函数面临的问题</p>
<ul>
<li><p>排序函数为例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">void</span> *base, <span class="comment">//需排序的数据（数组）内存首地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">unsigned</span> <span class="keyword">int</span> count, <span class="comment">//数据元素的个数</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">unsigned</span> <span class="keyword">int</span> element_size, <span class="comment">//一个数据元素所占内存大小（字节数）</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> (*cmp)(<span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *) )</span> <span class="comment">//比较两个元素的函数</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>比较麻烦，需要大量的指针操作。</p>
</li>
<li>容易出错！编译程序无法进行类型检查。</li>
</ul>
</li>
<li>函数模板<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3></li>
</ul>
</li>
<li>函数模板是指带有类型参数的函数定义</li>
<li><p>一般格式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">sort</span>(<span class="title">T</span> <span class="title">elements</span>[], <span class="title">unsigned</span> <span class="title">int</span> <span class="title">count</span>)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>T1、T2等是函数模板的参数, 函数的&lt;返回值类型&gt; 、&lt;参数表&gt;中的参数类型以及函数体中的局部变量的类型可以是：T1、T2等</li>
</ul>
</li>
<li><p>实例化</p>
<ul>
<li>实际上，函数模板定义了一系列重载的函数。<ul>
<li>要使用函数模板所定义的函数，首先必须要对函数模板进行实例化：<ul>
<li>给模板参数提供一个具体的类型，从而生成具体的函数。</li>
</ul>
</li>
<li>函数模板的实例化通常是<strong>隐式的</strong>：<ul>
<li>由<strong>编译程序</strong>根据函数调用的实参类型自动地把函数模板实例化为具体的函数。</li>
</ul>
</li>
<li>这种确定函数模板实例的过程叫做模板实参推导（template argument deduction）。</li>
</ul>
</li>
<li><p>显式地实例化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">max</span>(<span class="title">T</span> <span class="title">a</span>, <span class="title">T</span> <span class="title">b</span>) &#123;</span> <span class="keyword">return</span> a &gt; b ? a : b; &#125;</span><br><span class="line"></span><br><span class="line">max&lt;<span class="keyword">double</span>&gt;(x,m);</span><br></pre></td></tr></table></figure>
<ul>
<li>也可以进行显式类型转换以交由编译程序推导</li>
</ul>
</li>
</ul>
</li>
<li><p>带非类型参数的函数模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">size</span>&gt; //<span class="title">size</span>为一个<span class="title">int</span>型的普通参数</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">f</span>(<span class="title">T</span> <span class="title">a</span>)</span></span><br><span class="line"><span class="class">&#123;</span>	T temp[size];</span><br><span class="line">  ......  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f&lt;<span class="keyword">int</span>,<span class="number">10</span>&gt;(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>这样的函数模板在使用时需要显式实例化</li>
</ul>
</li>
</ul>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><ul>
<li>如果一个类的成员类型可变、但功能不变，则该类称为类属类</li>
<li><p>类模板的格式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>,...&gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> &lt;类名&gt;</span></span><br><span class="line"><span class="class">&#123;</span>	&lt;类成员说明&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中，T1、T2等为类模板的类型参数，在类成员的说明中可以用T1、T2等来作为它们的类型。 </li>
</ul>
</li>
<li><p>实例化</p>
<ul>
<li><p>类模板的实例化需要在程序中显式地指出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;<span class="keyword">int</span>&gt; st1; <span class="comment">//实例化int型栈类并创建一个相应类的对象</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">st1.push(<span class="number">10</span>); st1.pop(x);</span><br><span class="line"></span><br><span class="line">Stack&lt;<span class="keyword">double</span>&gt; st2; <span class="comment">//实例化double型栈类并创建一个相应类的对象</span></span><br><span class="line"><span class="keyword">double</span> y;</span><br><span class="line">st2.push(<span class="number">1.2</span>); st2.pop(y); </span><br><span class="line"></span><br><span class="line">Stack&lt;A&gt; st3; <span class="comment">//实例化A类型栈类并创建一个相应类的对象</span></span><br><span class="line">A a,b;</span><br><span class="line">st3.push(a); st3.pop(b); <span class="comment">//A中可能要重载赋值操作符！为什么？</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不同类模板实例之间不共享类模板中的静态成员</p>
</li>
</ul>
</li>
<li>带非类型参数的类模板: 与函数类似<h3 id="模板的复用"><a href="#模板的复用" class="headerlink" title="模板的复用"></a>模板的复用</h3></li>
<li>用模板实现的类属也属于一种多态，称为参数化多态</li>
<li>模板属于源代码复用</li>
<li>模板的定义和实现都放在头文件中, 把模板的源代码全包含进来，以备实例化所需</li>
<li>重复实例的处理<ul>
<li>由开发环境来解决：编译第二个模块的时候不生成这个实例。（代价大！）</li>
<li>由连接程序来解决：舍弃一个相同的实例。</li>
</ul>
</li>
<li>类模板的友元函数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">f3</span>(<span class="title">A</span>&lt;T&gt;&amp; <span class="title">a</span>) &#123;</span> ...... &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span> T x,y;</span><br><span class="line">  ......</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(A&lt;T&gt;&amp; a)</span></span>; <span class="comment">//f1不是模板！</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">friend</span> <span class="title">void</span> <span class="title">f2</span>(<span class="title">A</span>&lt;T&gt;&amp; <span class="title">a</span>);</span> <span class="comment">//f2的实例与A的实例多对多友元</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">void</span> f3&lt;T&gt;(A&lt;T&gt;&amp; a); <span class="comment">//f3的实例与A的实例一对一友元</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(A&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123; ...... &#125; <span class="comment">//是A&lt;int&gt;的友元，但不是A&lt;double&gt;的友元！</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">f2</span>(<span class="title">A</span>&lt;T&gt;&amp; <span class="title">a</span>) &#123;</span>......&#125;</span><br><span class="line">......</span><br><span class="line">A&lt;<span class="keyword">int</span>&gt; a1; <span class="comment">//实例化A&lt;int&gt;</span></span><br><span class="line">A&lt;<span class="keyword">double</span>&gt; a2; <span class="comment">//实例化A&lt;double&gt;</span></span><br><span class="line">f1(a1); <span class="comment">//OK，调用f1(A&lt;int&gt;&amp;)</span></span><br><span class="line">f1(a2); <span class="comment">//链接错误! 调用f1(A&lt;double&gt;&amp;)，但它不存在！</span></span><br><span class="line">f2(a1); <span class="comment">//实例化f2&lt;int&gt;，它是A&lt;int&gt;和A&lt;double&gt;的友元</span></span><br><span class="line">f2(a2); <span class="comment">//实例化f2&lt;double&gt;，它是A&lt;int&gt;和A&lt;double&gt;的友元</span></span><br><span class="line">f3(a1); <span class="comment">//实例化f3&lt;int&gt;，它是A&lt;int&gt;的友元，但不是A&lt;double&gt;的友元！</span></span><br><span class="line">f3(a2); <span class="comment">//实例化f3&lt;double&gt;，它是A&lt;double&gt;的友元，但不是A&lt;int&gt;的友元！</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="22-基于STL的编程"><a href="#22-基于STL的编程" class="headerlink" title="22.基于STL的编程"></a>22.基于STL的编程</h1><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><ul>
<li>C++提供了一个基于模板实现的标准模板库（Standard Template Library，简称STL）<ul>
<li>STL基于模板实现了一些面向序列数据的表示及常用的操作。</li>
<li>STL支持了一种抽象的编程模式: 隐藏了一些低级的程序元素，如数组、链表、循环等</li>
</ul>
</li>
<li>容器类模板<ul>
<li>容器用于存储序列化的数据，如：向量、队列、栈、集合等。</li>
</ul>
</li>
<li>算法函数模板<ul>
<li>算法用于对容器中的数据元素进行一些常用操作，如：排序、统计等。</li>
</ul>
</li>
<li>迭代器类模板<ul>
<li>迭代器实现了抽象的指针功能，它们指向容器中的数据元素，用于对容器中的数据元素进行遍历和访问。</li>
<li>迭代器是容器和算法之间的桥梁：传给算法的不是容器，而是指向容器中元素的迭代器，算法通过迭代器实现对容器中数据元素的访问。这样使得算法与容器保持独立，从而提高算法的通用性。<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2></li>
</ul>
</li>
<li>容器用于表示由<strong>同类型元素</strong>构成的、<strong>长度可变</strong>的元素序列。</li>
<li>容器是由<strong>类模板</strong>来实现的，模板的<strong>参数是容器中元素</strong>的类型。</li>
<li>主要容器<ul>
<li>vector&lt;类型&gt;: 随机访问, 尾部增减, 动态数组实现</li>
<li>list&lt;类型&gt;: 任意位置增减, 双向链表实现</li>
<li>deque&lt;类型&gt;: 随机访问, 头尾增减, 分段的连续空间实现</li>
<li>stack&lt;类型&gt;: 尾部增减, 可基于前三者实现</li>
<li>queue&lt;类型&gt;: 尾增头减, 基于deque或list</li>
<li>priority_queue&lt;类型&gt;: 与queue的操作类似, 带排序功能, 基于deque或vector</li>
<li>map/multimap&lt;关键字类型, 值类型&gt;<ul>
<li>每个元素是一个pair, first是关键字, second是值, 元素根据关键字排序</li>
<li>map: 关键字各不相同; multimap: 关键字可以相同</li>
<li>常常用某种二叉树实现(例如红黑树)</li>
</ul>
</li>
<li>set/multiset&lt;类型&gt;: map/multimap的特例, 有关键字没值</li>
<li>basic_string&lt;字符类型&gt;: 类似vector, 但提供字符串相关的操作</li>
</ul>
</li>
<li><p>基本操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// * 分别在容器的头部增加和删除一个元素。适用于list和deque。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// * 分别在容器的尾部增加和删除一个元素。适用于vector、list和deque。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span>;</span><br><span class="line"><span class="comment">// * 在容器的尾部增加一个元素。适用于stack、queue和priority_queue。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// * 在容器的尾部（适用于stack）或头部（适用于queue和priority_queue）删除一个元素。</span></span><br><span class="line"><span class="function">T&amp; <span class="title">front</span><span class="params">()</span></span>;和<span class="function"><span class="keyword">const</span> T&amp; <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="comment">// * 获取容器中第一个元素。适用于vector、list、deque和queue。</span></span><br><span class="line"><span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>;和<span class="function"><span class="keyword">const</span> T&amp; <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="comment">// * 获取容器中最后一个元素。适用于vector、list、deque和queue。</span></span><br><span class="line"><span class="function">T&amp; <span class="title">top</span><span class="params">()</span></span>;和<span class="function"><span class="keyword">const</span> T&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="comment">// * 获取容器尾部元素（适用于stack）或头部元素（适用于priority_queue）。</span></span><br><span class="line"><span class="function">T&amp; <span class="title">at</span><span class="params">(size_type pos)</span></span>;</span><br><span class="line"><span class="comment">// * 获取容器中某位置pos（序号）上的元素（会进行越界检查）。适用于vector、deque和basic_string。</span></span><br><span class="line">T&amp; <span class="keyword">operator</span>[](size_type pos);</span><br><span class="line"><span class="comment">// * 获取容器中某位置pos（序号）上的元素。适用于vector、deque和basic_string。</span></span><br><span class="line">ValueType&amp; <span class="keyword">operator</span>[](<span class="keyword">const</span> KeyType&amp; key); </span><br><span class="line"><span class="comment">// * 获取容器中某个关键字所关联的值。适用于map。</span></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="comment">// * 获取指向容器中第一个元素位置的迭代器。适用于除queue、stack和priority_queue以外的所有容器。</span></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="comment">// * 获取指向容器中最后一个元素的下一个位置的迭代器。适用于除queue、stack和priority_queue以外的所有容器。</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator pos, <span class="keyword">const</span> T&amp; x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator pos, InputIt first, InputIt last)</span></span>;</span><br><span class="line"><span class="comment">// * 分别在容器中的指定位置pos（迭代器）之前插入一个和多个元素，返回插入的(第一个)元素的迭代器。适用于vector、list和deque。</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span>;</span><br><span class="line"><span class="comment">// * 分别在容器中删除指定位置pos（迭代器）上的一个和某范围内的多个元素，返回删除后下一个元素的迭代器。适用于vector、list、deque、map/multimap、set/multiset以及basic_string。</span></span><br><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> T&amp; key)</span></span>;</span><br><span class="line"><span class="comment">// * 根据关键字在容器中查找某个元素，返回指向元素的迭代器（找到）或最后一个元素的下一个位置（未找到）。适用于map/multimap和set/multiset。</span></span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="comment">// * 获取容器中元素个数。适用于所有容器。</span></span><br><span class="line"><span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="comment">// * 获取容器中所允许的元素最大个数。适用于除stack、queue和priority_queue以外的所有容器。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：如果容器的元素类型是一个类，则针对该类可能需要：</p>
<ul>
<li>自定义拷贝构造函数和赋值操作符重载函数<ul>
<li>对容器进行的一些操作中可能会创建新的元素（对象的拷贝构造）或进行元素间的赋值（对象赋值）。</li>
</ul>
</li>
<li>重载小于操作符（&lt;）<ul>
<li>对容器进行的一些操作中可能要进行元素比较运算。<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2></li>
</ul>
</li>
</ul>
</li>
<li>迭代器（iterator）实现了抽象的指针（智能指针）功能，它们用于指向容器中的元素，对容器中的元素进行访问和遍历</li>
<li>迭代器(类模板实现)的类型<ul>
<li>输出迭代器（output iterator，记为：OutIt）<ul>
<li>可以修改它所指向的容器元素</li>
<li>间接访问操作（*）</li>
<li>++操作</li>
</ul>
</li>
<li>输入迭代器（input iterator，记为：InIt）<ul>
<li>只能读取它所指向的容器元素</li>
<li>间接访问操作（*）和元素成员间接访问（-&gt;）</li>
<li>++、==、!=操作。</li>
</ul>
</li>
<li>前向迭代器（forward iterator，记为：FwdIt）<ul>
<li>可以读取/修改它所指向的容器元素</li>
<li>元素间接访问操作（*）和元素成员间接访问操作（-&gt;）</li>
<li>++、==、!=操作</li>
</ul>
</li>
<li>双向迭代器（bidirectional iterator，记为：BidIt）<ul>
<li>可以读取/修改它所指向的容器元素</li>
<li>元素间接访问操作（*）和元素成员间接访问操作（-&gt;）</li>
<li>++、–、==、!=操作</li>
</ul>
</li>
<li>随机访问迭代器（random-access iterator，记为：RanIt）<ul>
<li>可以读取/修改它所指向的容器元素</li>
<li>元素间接访问操作（*）、元素成员间接访问操作（-&gt;）和下标访问元素操作（[]）</li>
<li>++、–、+、-、+=、-=、==、!=、&lt;、&gt;、&lt;=、&gt;=操作</li>
</ul>
</li>
</ul>
</li>
<li>容器的迭代器<ul>
<li>vector, deque, basic_string: RanIt</li>
<li>list, map/multimap, set/multiset: BidIt</li>
<li>queue, stack, priority_queue: 不支持迭代器</li>
</ul>
</li>
<li>迭代器相容<ul>
<li>InIt/OutIt &lt;- FwdIt &lt;- BidIt &lt;- RanIt<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2></li>
</ul>
</li>
<li>在STL中，除了用容器类模板自身提供的成员函数来操作容器元素外，还提供了一系列<strong>通用的对容器中元素进行操作</strong>的函数模板，称为算法（algorithm）</li>
<li>大部分STL算法都是遍历指定容器中某范围内的元素，对满足条件的元素执行某项操作</li>
<li>算法的内部实现往往隐含着循环操作，但这对使用者是隐藏的。使用者只需要提供：<strong>容器（迭代器）</strong>、<strong>操作条件</strong>以及可能的<strong>自定义操作</strong>，而算法的控制逻辑则由算法内部实现，这体现了一种抽象的编程模式。</li>
<li>算法与容器之间的关系<ul>
<li>不是把容器传给算法，而是把容器的某些<strong>迭代器</strong>传给它们</li>
<li>这样做的好处是：使得<strong>算法不依赖于具体的容器</strong>，提高了算法的通用性</li>
</ul>
</li>
<li><p>一个算法能接收的迭代器的类型是通过算法模板参数的名字来体现的。例如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt</span>, <span class="title">class</span> <span class="title">OutIt</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutIt</span> <span class="title">copy</span>(<span class="title">InIt</span> <span class="title">src_first</span>, <span class="title">InIt</span> <span class="title">src_last</span>, <span class="title">OutIt</span> <span class="title">dst_first</span>) &#123;</span> ...... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法的操作范围</p>
<ul>
<li><p>用算法对容器中的元素进行操作时，大都需要用<strong>两个迭代器</strong>来指出要操作的元素的范围</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(RanIt first, RanIt last)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>first是第一个元素的位置</li>
<li>last是最后一个元素的[下一个位置]</li>
</ul>
</li>
<li>有些算法可以有<strong>多个操作范围</strong>，这时，除第一个范围外，其它范围可以不指定最后一个元素位置，它由第一个范围中元素的个数决定</li>
<li>一个操作范围的两个迭代器必须属于<strong>同一个容器</strong>，而不同操作范围的迭代器可以属于不同的容器</li>
</ul>
</li>
<li><p>算法的自定义操作条件</p>
<ul>
<li>有些算法可以让使用者提供一个函数或函数对象来作为自定义操作条件（或称为谓词），其参数类型为相应容器的元素类型，返回值类型为bool</li>
<li><p>自定义操作条件可分为：</p>
<ul>
<li><p>Pred：一元“谓词”，需要一个元素作为参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> count_if(InIt first, InIt last, Pred cond);</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &gt; <span class="number">0</span>; &#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">...... <span class="comment">//往容器中放了元素</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;count_if(v.begin(),v.end(),f); <span class="comment">//统计v中正数的个数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>BinPred：二元“谓词”，需要两个元素作为参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(RanIt first, RanIt last)</span></span>; <span class="comment">//按“&lt;”排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(RanIt first, RanIt last, BinPred comp)</span></span>;  <span class="comment">//按comp返回true规定的次序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">greater</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2)</span> </span>&#123; <span class="keyword">return</span> x1&gt;x2; &#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">...... <span class="comment">//往容器中放了元素</span></span><br><span class="line">sort(v.begin(),v.end()); <span class="comment">//从小到大排序</span></span><br><span class="line">sort(v.begin(),v.end(),greater); <span class="comment">//从大到小排序</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>算法的自定义操作</p>
<ul>
<li>有些算法可以让使用者提供一个函数或函数对象作为自定义操作，其参数和返回值类型由相应的算法决定。</li>
<li><p>自定义操作可分为：</p>
<ul>
<li><p>Op或Fun：一元操作，需要一个参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Fun <span class="title">for_each</span><span class="params">(InIt first, InIt last, Fun f)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; x; &#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">...... <span class="comment">//往容器中放了元素</span></span><br><span class="line">for_each(v.begin(),v.end(),f); <span class="comment">//对v中的每个元素去调用函数f进行操作</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>BinOp或BinFun：二元操作，需要两个参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">accumulate</span><span class="params">(InIt first, InIt last, T val)</span></span>; <span class="comment">//按“+”操作</span></span><br><span class="line"><span class="function">T <span class="title">accumulate</span><span class="params">(InIt first, InIt last, T val, BinOp op)</span></span>; <span class="comment">//由op决定累积的含义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> partial, <span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> partial*x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> partial, <span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> partial+x*x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f3</span><span class="params">(<span class="keyword">double</span> partial, <span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> partial+<span class="number">1.0</span>/x; &#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">...... <span class="comment">//往容器中放了元素</span></span><br><span class="line">accumulate(v.begin(),v.end(),<span class="number">0</span>); <span class="comment">//所有元素和</span></span><br><span class="line">accumulate(v.begin(),v.end(),<span class="number">1</span>,f1); <span class="comment">//所有元素的乘积</span></span><br><span class="line">accumulate(v.begin(),v.end(),<span class="number">0</span>,f2); <span class="comment">//所有元素平方和</span></span><br><span class="line">accumulate(v.begin(),v.end(),<span class="number">0.0</span>,f3); <span class="comment">//所有元素倒数和</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OutIt <span class="title">transform</span><span class="params">(InIt src_first, InIt src_last,  OutIt dst_first, Op f)</span></span>;</span><br><span class="line"><span class="function">OutIt <span class="title">transform</span><span class="params">(InIt1 src_first1, InIt1 src_last1,  InIt2 src_first2, OutIt dst_first, BinOp f)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x*x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2)</span> </span>&#123; <span class="keyword">return</span> x1+x2; &#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1,v2,v3,v4;</span><br><span class="line">...... <span class="comment">//往v1和v2容器中放了元素</span></span><br><span class="line">transform(v1.begin(),v1.end(),v3.begin(),f1);  <span class="comment">//v3中的元素是v1相应元素的平方</span></span><br><span class="line">transform(v1.begin(),v1.end(),v2.begin(),v4.begin(),f2);  <span class="comment">//v4中的元素是v1和v2相应元素的和</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="23-输入输出-面向对象"><a href="#23-输入输出-面向对象" class="headerlink" title="23.输入输出(面向对象)"></a>23.输入输出(面向对象)</h1><h2 id="输入-输出（I-O）概述"><a href="#输入-输出（I-O）概述" class="headerlink" title="输入/输出（I/O）概述"></a>输入/输出（I/O）概述</h2><ul>
<li>在C++中，输入/输出是一种基于<strong>字节流</strong>的操作：<ul>
<li>输入的数据看成逐个字节地从外设流入到计算机内部（内存）</li>
<li>输出的数据看成逐个字节地从内存流出到外设</li>
</ul>
</li>
<li>在C++的标准类库提供了用于C++基本数据类型数据的输入/输出操作：<ul>
<li>在这些操作的内部实现了基本数据类型与字节流之间的<strong>转换</strong>。</li>
</ul>
</li>
<li>另外，还可以对“&lt;&lt;”和“&gt;&gt;”进行<strong>重载</strong>，以实现对自定义类型的数据（对象）进行输入/输出操作。</li>
<li>C++输入输出的实现途径<ul>
<li>过程式——通过从C语言保留下来的函数库中的输入/输出函数来实现。<ul>
<li>不是强类型，不利于类型检查，会导致类型相关的运行错误</li>
</ul>
</li>
<li>面向对象——通过C++的I/O类库中的类/对象来实现。<ul>
<li>不需要额外指定数据的类型和个数，由数据本身决定，避免了类型与个数相关的错误！</li>
</ul>
</li>
</ul>
</li>
<li>I/O分类<ul>
<li>面向控制台的I/O<ul>
<li>从标准输入设备（如：键盘）获得数据</li>
<li>把程序结果从标准输出设备（如：显示器）输出</li>
</ul>
</li>
<li>面向文件的I/O<ul>
<li>从外存文件获得数据</li>
<li>把程序结果保存到外存文件中</li>
</ul>
</li>
<li>面向字符串变量的I/O<ul>
<li>从程序中的字符串变量中获得数据</li>
<li>把程序结果保存到字符串变量中</li>
</ul>
</li>
</ul>
</li>
<li>I/O类<ul>
<li>ios<ul>
<li>istream: ifstream, istrstream</li>
<li>ostream: ofstream, ostrstream</li>
<li>iostream: fstream, strstream</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="面向控制台的I-O"><a href="#面向控制台的I-O" class="headerlink" title="面向控制台的I/O"></a>面向控制台的I/O</h2><ul>
<li>预定义的io对象<ul>
<li>cin（istream类的对象）对应着计算机系统的标准输入设备。（通常为键盘）</li>
<li>cout（ostream类的对象）对应着计算机系统的用于输出程序正常运行结果的标准输出设备。（通常为显示器）</li>
<li>cerr和clog（ostream类的对象）对应着计算机系统的用于输出程序错误信息的设备（不带和带缓冲），通常情况下它们都对应着显示器。（不受输出重定向的影响）<h3 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h3></li>
</ul>
</li>
<li>输出格式控制<ul>
<li>操纵符<ul>
<li>dec, oct, hex: 进制</li>
<li>endl: 换行+flush</li>
<li>flush: 缓存中内容立刻输出</li>
<li>setprecision(int n): <ul>
<li>当输出格式为ios::scientific或ios::fixed时，操纵符setprecision用于设置浮点数小数点后面的位数；</li>
<li>当输出格式为自动方式（既不为ios::scientific也不为ios::fixed，或两者都有）时，操纵符setprecision用于设置浮点数有效数字的个数，这时的输出格式根据有效数字自动确定</li>
</ul>
</li>
<li>setiosflags(long flags)/resetiosflags(long flags) : </li>
</ul>
</li>
<li>基于字节流的操作<ul>
<li>cout.put(char)</li>
<li>cout.write(const char *, int)<h3 id="控制台输入"><a href="#控制台输入" class="headerlink" title="控制台输入"></a>控制台输入</h3></li>
</ul>
</li>
</ul>
</li>
<li>空白符（空格、\t、\n）分开输入的各个数据</li>
<li>操纵符<ul>
<li>cin &gt;&gt; setw(10) &gt;&gt; str; //把输入的字符串和一个’\0’放入str中，最多输入9个字符。</li>
</ul>
</li>
<li>基于字节流的操作<ul>
<li>get(char &amp;ch); </li>
<li>getline(char *p, int count, char delim=’\n’); 输入count个或遇到delim</li>
<li>read(char *p,int count);</li>
</ul>
</li>
<li><p>输入/输出操作符“&gt;&gt;”和“&lt;&lt;”的重载</p>
<ul>
<li><p>一般情况</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>	</span><br><span class="line">  <span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; out, <span class="keyword">const</span> A &amp;a)；</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; out, <span class="keyword">const</span> A &amp;a)</span><br><span class="line">&#123;	out &lt;&lt; a.x &lt;&lt; <span class="string">','</span> &lt;&lt; a.y; <span class="keyword">return</span> out; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>派生类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>		</span><br><span class="line">  <span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ......	</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(ostream&amp; out)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;	out &lt;&lt; x &lt;&lt; <span class="string">','</span> &lt;&lt; y ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A &#123;		</span><br><span class="line">  <span class="keyword">double</span> z;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  ......</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(ostream&amp; out)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;	A::display(out); out &lt;&lt; <span class="string">','</span> &lt;&lt; z ;   	&#125;</span><br><span class="line">&#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; out, <span class="keyword">const</span> A&amp; a) &#123;</span><br><span class="line">  a.display(out); <span class="comment">//动态绑定到A类或B类对象的display。</span></span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">A a1; B b1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; b1 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="面向文件的I-O"><a href="#面向文件的I-O" class="headerlink" title="面向文件的I/O"></a>面向文件的I/O</h2><ul>
<li>文件基本概念<ul>
<li>在C++中，把文件看成是由一系列字节所构成的字节串，对文件中数据的操作（输入/输出）通常是逐个字节顺序进行，因此称为流式文件。 </li>
<li>每个打开的文件都有一个隐藏的位置指针，它指出文件的当前读写位置。</li>
<li>进行读/写操作时，每读入/写出一个字节，文件位置指针会自动往后移动一个字节的位置。 </li>
</ul>
</li>
<li>文件数据的存储方式<ul>
<li>文本方式（text）: 只包含可显示的字符和有限的几个控制字符（如：‘\r’、‘\n’、‘\t’等）的编码。<ul>
<li>一般用于存储具有“行”结构的文本数据。（可用记事本等软件打开察看）</li>
</ul>
</li>
<li>二进制方式（binary）: 包含任意的没有显式含义的纯二进制字节。<ul>
<li>一般用于存储无显式结构的数据。</li>
</ul>
</li>
</ul>
</li>
<li>对文件数据进行读写的过程：<ul>
<li>打开文件：把程序内部的一个表示文件的变量/对象与外部的一个具体文件关联起来，并创建内存缓冲区。</li>
<li>文件读/写：存取文件中的内容。</li>
<li>关闭文件：把暂存在内存缓冲区中的内容写入到文件中，并归还打开文件时申请的内存资源。  <h3 id="文件输出"><a href="#文件输出" class="headerlink" title="文件输出"></a>文件输出</h3></li>
</ul>
</li>
<li>首先创建一个ofstream类的对象，并建立与外部文件之间的联系（打开文件）。<ul>
<li>直接方式：ofstream out_file(&lt;文件名&gt;,&lt;打开方式&gt;);<br>例如：ofstream out_file(“d:\\myfile.txt”,ios::out);</li>
<li>间接方式: ofstream out_file; out_file.open(&lt;文件名&gt;,&lt;打开方式&gt;);<br>例如：out_file.open(“d:\\myfile.txt”,ios::out);</li>
</ul>
</li>
<li>打开方式<ul>
<li>打开方式 <ul>
<li>ios::out 默认打开方式<ul>
<li>打开一个外部文件用于写操作。</li>
<li>如果外部文件已存在，则首先把它的内容清除；否则，先创建该外部文件。</li>
</ul>
</li>
<li>ios::app<ul>
<li>打开一个外部文件用于添加（文件位置指针在末尾）操作。</li>
<li>如果外部文件不存在，则先创建该外部文件。 </li>
</ul>
</li>
<li>ios::out或ios::app分别与ios::binary的按位或（|）<ul>
<li>表示按二进制方式打开文件。（默认的是文本方式）</li>
<li>对以文本方式打开的文件，当输出的字符为’\n’时，在某些平台上（如：DOS和Windows平台）将自动转换成’\r’和’\n’两个字符写入外部文件。 </li>
</ul>
</li>
</ul>
</li>
<li>判断打开操作是否成功<ul>
<li>!out_file.is_open()  或 out_file.fail()  或 !out_file</li>
</ul>
</li>
</ul>
</li>
<li>输出数据: &lt;&lt;或成员函数, 与控制台类似</li>
<li>关闭文件<ul>
<li>文件输出操作结束时，要使用ofstream的成员函数close关闭文件：out_file.close(); </li>
<li>关闭文件的目的：<ul>
<li>把文件内存缓冲区的内容写到磁盘文件中！</li>
</ul>
</li>
<li>程序正常结束时，系统也会自动关闭打开的文件。<ul>
<li>程序中为什么要显式关闭文件？</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="文件输入"><a href="#文件输入" class="headerlink" title="文件输入"></a>文件输入</h3><ul>
<li>首先创建一个ifstream类（istream类的派生类）的对象，并与外部文件建立联系。<ul>
<li>例如：ifstream in_file(&lt;文件名&gt;,&lt;打开方式&gt;); </li>
<li>或: fstream in_file; in_file.open(&lt;文件名&gt;,&lt;打开方式&gt;); </li>
</ul>
</li>
<li>打开方式<ul>
<li>ios::in，打开一个外部文件用于读操作。<ul>
<li>也可以把ios::in与ios::binary通过按位或操作（|）实现二进制打开方式。默认为文本方式。</li>
<li>对以文本方式打开的文件，当文件中的字符为连续的’\r’和’\n’时，在某些平台上（如：DOS和Windows平台）将自动转换成一个字符’\n’输入。</li>
</ul>
</li>
<li>打开文件时要判断打开是否成功。<ul>
<li>判断方式与文件输出的判断一样。</li>
</ul>
</li>
</ul>
</li>
<li>判断成功与否: 读取数据过程中有时需要判断是否正确读入了数据（尤其是在文件末尾处）。<ul>
<li>判断是否正确读入了数据，可以调用ios类的成员函数fail来实现：</li>
<li>bool ios::fail() const;</li>
<li>该函数返回true表示文件操作失败；返回false表示操作成功。 </li>
</ul>
</li>
<li>文件输入操作结束时，要使用ifstream的一个成员函数close关闭文件：in_file.close(); </li>
<li>有关文件读写的几点注意: <ul>
<li>输入输出格式统一<ul>
<li>以文本方式输出的文件要以文本方式输入；以二进制方式输出的文件要以二进制方式输入！</li>
<li>以文本方式读写的文件要以文本方式打开；以二进制方式读写的文件要以二进制方式打开！</li>
</ul>
</li>
<li>以二进制方式存取文件不利于程序的兼容性和可移植性。例如，<ul>
<li>在不同计算机平台上，整型数的各字节在内存中的存储次序可能不一样。</li>
<li>在不同的编译环境下，同样的结构类型数据的尺寸（字节数）可能不一样。</li>
</ul>
</li>
</ul>
</li>
<li>文件输入/输出<ul>
<li>如果需要打开一个既能读入数据、也能输出数据的文件，则需要创建一个fstream类的对象。 </li>
<li>在创建fstream类的对象并建立与外部文件的联系时，文件打开方式应为下面之一：<ul>
<li>ios::in|ios::out（可在文件任意位置写）</li>
<li>ios::in|ios::app（只能在文件末尾写） </li>
</ul>
</li>
</ul>
</li>
<li>文件随机存取<ul>
<li>为了能够随机读写文件中的数据，可以显示地指出读写的位置。</li>
<li>对于以输入方式打开的文件，可用下面的操作来指定文件内部指针位置： <ul>
<li>istream&amp; istream::seekg(&lt;位置&gt;)；//指定绝对位置</li>
<li>istream&amp; istream::seekg(&lt;偏移量&gt;,&lt;参照位置&gt;);  //指定相对位置</li>
<li>streampos istream::tellg();  //获得指针位置</li>
</ul>
</li>
<li>对于输出文件，可用下面的操作来指定文件内部指针位置： <ul>
<li>ostream&amp; ostream::seekp(&lt;位置&gt;)；//指定绝对位置</li>
<li>ostream&amp; ostream::seekp(&lt;偏移量&gt;,&lt;参照位置&gt;); //指定相对位置</li>
<li>streampos ostream::tellp();  //获得指针位置 </li>
</ul>
</li>
<li>&lt;参照位置&gt;可以是：ios::beg（文件头），ios::cur（当前位置）和ios::end（文件尾）。</li>
</ul>
</li>
</ul>
<h1 id="24-异常处理"><a href="#24-异常处理" class="headerlink" title="24.异常处理"></a>24.异常处理</h1><h2 id="异常概述"><a href="#异常概述" class="headerlink" title="异常概述"></a>异常概述</h2><ul>
<li>程序的错误通常包括：<ul>
<li><strong>语法错误</strong>：指程序的书写不符合语言的语法规则。<br>例如：<br>使用了未定义或未声明的标识符<br>左右括号不匹配<br>……<br>这类错误可由编译程序发现。</li>
<li><strong>逻辑错误</strong>（或语义错误）：指程序设计不当造成程序没有完成预期的功能。<br>例如：<br>把两个数相加写成了相乘<br>排序功能未能正确排序<br>……<br>这类错误可通过对程序进行静态分析和动态测试发现。</li>
<li><strong>运行异常</strong>：指程序设计对程序运行环境考虑不周而造成的程序运行错误。<br>例如：<br>对于“x/y”操作，给y输入了“零”。<br>由内存空间不足导致的内存访问错误：<br>int <em>p=new int; //动态分配空间，可能失败！
</em>p = 10; //如果上面new操作失败，p可能为空指针！<br>输入数据的数量超过存放它们的数组的大小，导致数组下标越界。<br>多任务环境可能导致的文件操作错误。</li>
</ul>
</li>
<li>在程序运行环境正常的情况下，运行异常的错误是不会出现的。</li>
<li>导致程序运行异常的情况是<strong>可以预料</strong>的，但它是<strong>无法避免</strong>的。</li>
<li>为了保证程序的<strong>鲁棒性</strong>（Robustness），必须在程序中对<strong>可能出现的异常进行预见性处理</strong>。</li>
<li>异常处理的策略<ul>
<li>就地处理: 在发现异常错误的地方处理异常</li>
<li>异地处理: 在其它地方（非异常发现地）处理异常<h3 id="异常的就地处理"><a href="#异常的就地处理" class="headerlink" title="异常的就地处理"></a>异常的就地处理</h3></li>
</ul>
</li>
<li>常用做法是调用C++标准库中的函数exit或abort终止程序执行（在cstdlib或stdlib.h中声明）<ul>
<li>abort立即终止程序的执行，不作任何的善后处理工作。</li>
<li>exit在终止程序的运行前，会做关闭被程序打开的文件、调用全局对象和static存储类的局部对象的析构函数（注意：不要在这些对象类的析构函数中调用exit）等工作。<h3 id="异常的异地处理"><a href="#异常的异地处理" class="headerlink" title="异常的异地处理"></a>异常的异地处理</h3></li>
</ul>
</li>
<li>发现异常时，在发现地（如在被调用的函数中）有时不知道如何处理这个异常，或者不能很好地处理这个异常，要由程序的其它地方（如函数的调用者）来处理</li>
<li>一种途径<ul>
<li>通过函数的返回值，或指针/引用类型的参数，或全局变量把异常情况通知函数的调用者，由调用者处理异常</li>
<li>通过函数的返回值返回异常情况会导致正常返回值和异常返回值交织在一起，有时无法区分。<ul>
<li>通过指针/引用类型的参数返回异常情况，需要引入额外的参数，给函数的使用带来负担。</li>
<li>通过全局变量返回异常情况会导致使用者忽视这个全局变量的问题。（不知道它的存在）</li>
<li>程序的可读性差！程序的正常处理与异常处理混杂在一起。<h2 id="C-异常处理机制"><a href="#C-异常处理机制" class="headerlink" title="C++异常处理机制"></a>C++异常处理机制</h2></li>
</ul>
</li>
</ul>
</li>
<li>把有可能遭遇异常的一系列操作（语句或函数调用）构成一个try语句块。</li>
<li>如果try语句块中的某个操作在执行中发现了异常，则通过执行一个throw语句抛掷（产生）一个异常对象，之后的操作不再进行。</li>
<li><p>抛掷的异常对象将由程序中能够处理这个异常的地方通过catch语句块来捕获并处理之。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span> *filename)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="function">ifstream <span class="title">file</span><span class="params">(filename)</span></span>;</span><br><span class="line">   <span class="keyword">if</span> (file.fail()) </span><br><span class="line">     <span class="keyword">throw</span> filename; <span class="comment">//产生异常对象，报告错误情况</span></span><br><span class="line">   <span class="keyword">int</span> x;</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">   ......</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123; f(str); &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">char</span> *fn) <span class="comment">//捕获异常</span></span><br><span class="line">    &#123; ...... <span class="comment">//处理异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...... <span class="comment">//正常情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>try语句</p>
<ul>
<li>try语句块的作用是启动异常处理机制, 上述的&lt;语句序列&gt;中可以有函数调用。格式为：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> </span><br><span class="line">&#123; &lt;语句序列&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>throw语句</p>
<ul>
<li>throw语句用于在发现异常情况时抛掷（产生）异常对象; 执行throw语句后，接在其后的语句将不再继续执行，而是转向异常处理（由某个catch语句给出）<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> &lt;表达式&gt;;</span><br><span class="line">&lt;表达式&gt;为任意类型的C++表达式（<span class="keyword">void</span>除外）。</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>catch语句</p>
<ul>
<li><p>catch语句块用于捕获throw抛掷的异常对象并处理相应的异常, catch语句块要紧接在某个try语句的后面</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (&lt;类型&gt; [&lt;变量&gt;])</span><br><span class="line">&#123; &lt;语句序列&gt;</span><br><span class="line">&#125;</span><br><span class="line">&lt;类型&gt;用于指出捕获何种异常对象，它与<span class="keyword">throw</span>所产生的异常对象的类型匹配规则与函数重载的绑定规则类似；</span><br><span class="line">&lt;变量&gt;用于存储异常对象，它可以缺省，缺省时表明<span class="keyword">catch</span>语句块只关心异常对象的类型，而不考虑具体的异常对象。</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个try语句块的后面可以跟多个catch语句块，用于捕获不同类型的异常对象并进行处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; ......</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123; f();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (<span class="keyword">int</span>) <span class="comment">//处理函数f中的throw 1;</span></span><br><span class="line">  &#123; &lt;语句序列<span class="number">1</span>&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (<span class="keyword">double</span>) <span class="comment">//处理函数f中的throw 1.0</span></span><br><span class="line">  &#123; &lt;语句序列<span class="number">2</span>&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (<span class="keyword">char</span> *) <span class="comment">//处理函数f中的throw "abcd"</span></span><br><span class="line">  &#123; &lt;语句序列<span class="number">3</span>&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  &lt;非<span class="keyword">catch</span>语句&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>如果在try语句块的&lt;语句序列&gt;执行中没有抛掷（throw）异常对象，则其后的catch语句不执行，而是继续执行try语句块之后的非catch语句。</p>
</li>
<li>如果在try语句块的&lt;语句序列&gt;执行中抛掷了（throw）异常对象，<ul>
<li>如果该try语句块之后有能够捕获该异常对象的catch语句，则执行这个catch语句中的&lt;语句序列&gt;，然后继续执行这个catch语句之后的非catch语句。</li>
<li>如果该try语句块之后没有能够捕获该异常对象的catch语句，则按嵌套的异常处理规则进行处理。<h3 id="异常处理的嵌套"><a href="#异常处理的嵌套" class="headerlink" title="异常处理的嵌套"></a>异常处理的嵌套</h3></li>
</ul>
</li>
<li>try语句是可以嵌套的：<ul>
<li>在try语句块的语句序列执行过程中还可以包含try语句块。</li>
</ul>
</li>
<li>当在内层的try语句的执行中产生了异常，则首先在内层try语句块之后的catch语句序列中查找与之匹配的处理，如果内层不存在能捕获相应异常的catch，则逐步向外层进行查找。 </li>
<li>如果抛掷的异常对象在程序的函数调用链上没有给出捕获，则调用系统的terminate函数进行标准的异常处理。<ul>
<li>默认情况下，terminate函数将会去调用abort函数。</li>
</ul>
</li>
<li>实现机制示意<ul>
<li>每个函数都有一个catch表。</li>
<li>每进入一个try，都会把其后的所有catch入口地址记录在相应函数的catch表中。</li>
<li>执行throw时，<ul>
<li>顺着函数调用链去搜索catch入口；</li>
<li>对之前函数调用的栈空间进行退栈处理；</li>
<li>转到搜索到的catch入口。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="基于断言的程序调试"><a href="#基于断言的程序调试" class="headerlink" title="基于断言的程序调试"></a>基于断言的程序调试</h2><ul>
<li>一个处于开发阶段的程序可能会含有一些错误（逻辑错误或异常）。<ul>
<li>通过测试可以发现程序存在错误。</li>
<li>通过调试可以对错误进行定位。</li>
</ul>
</li>
<li>除了利用调试工具以外，一种常用的调试手段是：<ul>
<li>在程序中的某些地方加上一些输出语句，在程序运行时把一些调试信息（如变量的值）输出到显示器。</li>
</ul>
</li>
<li>这种调试手段存在以下问题：<ul>
<li>调试者需要对输出的值做一定的分析才能知道程序是否有错。</li>
<li>在开发结束后，去掉调试信息有时是一件很繁琐的工作。</li>
</ul>
</li>
<li>实际上，在调试程序时输出程序在一些地方的某些变量或表达式的值，其目的是为了确认程序运行到这些地方时状态是否正确。</li>
<li>上述目的可以在程序的一些关键或容易出错的点上插入一些断言来表达。<ul>
<li>断言（assertion）是一个逻辑表达式，它描述了程序执行到断言处应满足的条件。</li>
<li>如果条件满足则程序继续执行下去，否则程序异常终止。</li>
</ul>
</li>
<li>在程序开发阶段，断言既可以用来帮助开发者发现程序的错误，也可以用于错误定位。<h3 id="宏ASSERT"><a href="#宏ASSERT" class="headerlink" title="宏ASSERT"></a>宏ASSERT</h3></li>
<li>C++标准库提供的一个宏assert（在头文件cassert或assert.h中定义），可以用来实现断言。其格式为：<ul>
<li>assert(&lt;表达式&gt;);</li>
<li>&lt;表达式&gt;一般为一个关系/逻辑表达式</li>
</ul>
</li>
<li>assert执行时，<ul>
<li>如果&lt;表达式&gt;的值为true，程序继续正常执行。</li>
<li>如果&lt;表达式&gt;的值为false，则它会:<ul>
<li>首先，显示出相应的表达式、该assert所在的源文件名以及所在的行号等诊断信息；</li>
<li>然后，调用库函数abort终止程序的运行。<h3 id="宏ASSERT的实现"><a href="#宏ASSERT的实现" class="headerlink" title="宏ASSERT的实现"></a>宏ASSERT的实现</h3></li>
</ul>
</li>
</ul>
</li>
<li><p>宏assert是通过条件编译预处理命令来实现的，其实现细节大致如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cassert 或 assert.h</span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> assert(exp)  ((void)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> assert(exp)  ((exp)?(void)0:<span class="meta-string">&lt;输出诊断信息并调用库函数abort&gt;)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
</li>
<li><p>宏assert只有在宏名NDEBUG没定义时才有效，这时，程序一般处于开发、测试阶段。程序开发结束提交时，应该让宏名NDEBUG有定义，然后重新编译程序，这样，assert就不再有效了。</p>
</li>
<li>宏名NDEBUG在哪儿定义？<ul>
<li>在编译命令中指出。例如：<br><code>cl &lt;源文件1&gt; &lt;源文件2&gt; ... -D NDEBUG ...</code></li>
<li>在开发环境中的“项目|…属性|C/C++|预处理器|预处理器定义”中指出。（VC++2015）</li>
</ul>
</li>
</ul>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2020-05-09T07:25:06.988Z" itemprop="dateUpdated">2020-05-09 15:25:06</time>
</span><br>


        
        Link：<a href="/2020/03/26/Learn-AP-AP-ALL/" target="_blank" rel="external">https://Maxwell-lyu.github.io/2020/03/26/Learn-AP-AP-ALL/</a>
        
    </div>
    
    <footer>
        <a href="https://Maxwell-lyu.github.io">
            <img src="/img/avatar.png" alt="Maxwell Lyu">
            Maxwell Lyu
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">
        <i class="icon icon-coffee"></i>
    </a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Advanced-Programming/">Advanced Programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Course/">Course</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://Maxwell-lyu.github.io/2020/03/26/Learn-AP-AP-ALL/&title=《Advanced Programming》 — Maxwell's Blog&pic=https://Maxwell-lyu.github.io/img/avatar.png" data-title="Weibo">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="WeChat">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://Maxwell-lyu.github.io/2020/03/26/Learn-AP-AP-ALL/&title=《Advanced Programming》 — Maxwell's Blog&source=高级程序设计 课程的重点知识" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://Maxwell-lyu.github.io/2020/03/26/Learn-AP-AP-ALL/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Advanced Programming》 — Maxwell's Blog&url=https://Maxwell-lyu.github.io/2020/03/26/Learn-AP-AP-ALL/&via=https://Maxwell-lyu.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://Maxwell-lyu.github.io/2020/03/26/Learn-AP-AP-ALL/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2020/04/02/Learn-PTC-20200402-PTC-06/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">编译原理 6</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2020/03/17/Learn-PTC-20200317-PTC-05/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">编译原理 5</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'false' == 'true',
            appId: "mVhn5w80vLd48Du7XTGLVw71-9Nh9j0Va",
            appKey: "mpnUAHaby8utnEkqWK354Q3w",
            avatar: "mm",
            placeholder: "Empty here...",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10", 
            lang:'en' 
        })
    </script>
    <!-- Valine Comments end -->







</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        Buy Maxwell a Coffee
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.png" data-alipay="/img/alipay.png">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">Wechat</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">Alipay</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        Total Visitors：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        Total Visits：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Maxwell Lyu &copy; 2019 - 2020</span>
            <span>
                
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://Maxwell-lyu.github.io/2020/03/26/Learn-AP-AP-ALL/&title=《Advanced Programming》 — Maxwell's Blog&pic=https://Maxwell-lyu.github.io/img/avatar.png" data-title="Weibo">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="WeChat">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://Maxwell-lyu.github.io/2020/03/26/Learn-AP-AP-ALL/&title=《Advanced Programming》 — Maxwell's Blog&source=高级程序设计 课程的重点知识" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://Maxwell-lyu.github.io/2020/03/26/Learn-AP-AP-ALL/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Advanced Programming》 — Maxwell's Blog&url=https://Maxwell-lyu.github.io/2020/03/26/Learn-AP-AP-ALL/&via=https://Maxwell-lyu.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://Maxwell-lyu.github.io/2020/03/26/Learn-AP-AP-ALL/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://Maxwell-lyu.github.io/2020/03/26/Learn-AP-AP-ALL/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '_(:з」∠)_';
            clearTimeout(titleTime);
        } else {
            document.title = 'ヾ(^▽^*)';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



</body>
</html>
