<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Maxwell&#39;s Blog</title>
  
  <subtitle>Think &amp; Write</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://Maxwell-lyu.github.io/"/>
  <updated>2019-10-11T03:30:42.000Z</updated>
  <id>https://Maxwell-lyu.github.io/</id>
  
  <author>
    <name>Maxwell Lyu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在VSCode中使用Jupyter Notebook</title>
    <link href="https://Maxwell-lyu.github.io/2019/10/11/Tech-20191011-juptyer-vscode/"/>
    <id>https://Maxwell-lyu.github.io/2019/10/11/Tech-20191011-juptyer-vscode/</id>
    <published>2019-10-11T02:04:03.000Z</published>
    <updated>2019-10-11T03:30:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这个不是Jupyter Notebook的介绍啦, 默认本文的读者拥有使用Jupyter Notebook的经验<br><a id="more"></a> </p></blockquote><p>环境:  </p><ul><li>Python 3.7.4 64-bit  </li><li>VSCode 1.39.0</li><li>Windows 10 1903 <del>x64, 废话</del>  </li></ul><p>2019年10月9日, M$发布了Python插件的更新, 提供对<code>*.ipynb</code>文件的支持, 即Jupyter支持. 于是就可以通过更新Python插件, 直接在VSCode里面使用Jupyter nb啦</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装Python插件"><a href="#安装Python插件" class="headerlink" title="安装Python插件"></a>安装Python插件</h2><p>点击插件信息页, 查看Extensions-Installed, 确认你的插件版本是<code>2019.10.41019</code>, 若不是, 请检查自动更新插件设置, 应当为以下:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"extensions.autoUpdate": true</span><br></pre></td></tr></table></figure></p><p>或者手动点击<code>Update</code>, 或者卸载插件重装</p><p>你可能会遇到以下问题:  </p><ul><li>我不是<strong>Insider</strong>: 根本不需要Insider版</li><li>没安装过Python插件: <del>咋回事啊小老弟</del> 在Extensions当中搜索<code>python @sort:installs</code>, 列表顶端的即为所需的插件, 点击<code>Install</code>安装  </li></ul><h2 id="重启VSCode"><a href="#重启VSCode" class="headerlink" title="重启VSCode"></a>重启VSCode</h2><p><strong>重启VSCode</strong>,请<strong>重启VSCode</strong><br>这个重启可以解决: </p><ul><li><strong>Command Panel</strong> 没有 Jupyter NB 相关命令</li><li>我没遇到的<strong>疑难杂症</strong>中的一部分</li></ul><h2 id="安装Jupyter及其依赖"><a href="#安装Jupyter及其依赖" class="headerlink" title="安装Jupyter及其依赖"></a>安装Jupyter及其依赖</h2><blockquote><p>如果你已经在用Jupyter NB, 这段不用看辣  </p></blockquote><p>按下组合键<code>Ctrl+Shift+P</code>, 输入<code>&gt; Python: Create New Blank Jupyter Notebook</code>, 按<code>Enter</code>, 可以建立一个<code>*.ipynb</code>文件<br>在一个新的cell当中写<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'anything'</span>)</span><br></pre></td></tr></table></figure></p><p>点按钮执行cell, 如果未曾安装过Jupyter, 将会报错, 点击报错信息中的<code>Install</code>按钮, VSCode会帮你<strong>搞定一切</strong>, 除非你网络不好</p><h2 id="重启VSCode-1"><a href="#重启VSCode-1" class="headerlink" title="重启VSCode"></a>重启VSCode</h2><p><strong>重启VSCode</strong>,请<strong>重启VSCode</strong><br>这个重启可以解决: </p><ul><li><code>*.ipynb</code>文件<strong>没有Intellisense</strong></li><li>我没遇到的<strong>疑难杂症</strong>中的一部分</li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>这里主要说点废话  </p><ul><li>打开VSCode后, 如果你的Jupyter Server是local, 建议你随便执行点什么cell, 这时会start jupyter server(嗯, 半自动), 要等一会儿, 之后就可以丝滑写码了  </li><li><strong>导出图像</strong>, 想要啥配色就先换VSCode的color theme, 导出图像目前还是只能按照这个来</li><li><p><strong>远程配置</strong>? 我不会, 用的local, url贴在这里, token应该包含在url里面</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"python.dataScience.jupyterServerURI": "&gt;&gt;&gt;YOUR URL HERE&lt;&lt;&lt;"</span><br></pre></td></tr></table></figure></li><li><p>BUG: </p><ul><li>没法<strong>折叠执行结果框</strong></li><li>文件末尾的cell执行时, 会<strong>自动创建一个新cell</strong>, 有时候很烦, 这其实可以说是feature</li><li><del>convert to python script 之后, 里面还会显示<code>Run Cell</code>等按钮, 尽量别点, 有可能<strong>VSCode直接崩溃</strong></del><br>当我没说, 重启VSCode之后问题就消失了, 重启大法好</li></ul></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/85445777" target="_blank" rel="noopener">韩骏的知乎专栏</a><br>请给这篇文章点赞, 另外评论区有很多问题的解决方案, 遇到问题可以看下评论区</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这个不是Jupyter Notebook的介绍啦, 默认本文的读者拥有使用Jupyter Notebook的经验&lt;br&gt;
    
    </summary>
    
      <category term="Technique" scheme="https://Maxwell-lyu.github.io/categories/Technique/"/>
    
    
      <category term="Utility" scheme="https://Maxwell-lyu.github.io/tags/Utility/"/>
    
  </entry>
  
  <entry>
    <title>DIP-ALL</title>
    <link href="https://Maxwell-lyu.github.io/2019/09/12/Learn-DIP-20190912-DIP-ALL/"/>
    <id>https://Maxwell-lyu.github.io/2019/09/12/Learn-DIP-20190912-DIP-ALL/</id>
    <published>2019-09-12T04:53:15.000Z</published>
    <updated>2019-10-12T07:44:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-空间域图像增强-Part-I"><a href="#第二章-空间域图像增强-Part-I" class="headerlink" title="第二章: 空间域图像增强(Part I)"></a>第二章: 空间域图像增强(Part I)</h1><h2 id="图像内插"><a href="#图像内插" class="headerlink" title="图像内插"></a>图像内插</h2><ul><li>用已知的数据来估计未知位置的数值</li><li>按照边角对齐像素点阵, 之后有如下插值方法</li></ul><h3 id="最近邻内插法"><a href="#最近邻内插法" class="headerlink" title="最近邻内插法"></a>最近邻内插法</h3><ul><li>取最近邻像素的灰度为此像素的灰度</li></ul><h3 id="双线性内插法"><a href="#双线性内插法" class="headerlink" title="双线性内插法"></a>双线性内插法</h3><ul><li>4个最近邻进行估计, 解有4个等式组成的方程组<br>$$v(x,y)=ax+by+cxy+d$$</li></ul><h3 id="双三次内插法"><a href="#双三次内插法" class="headerlink" title="双三次内插法"></a>双三次内插法</h3><ul><li>16个最近邻去估计, 解16个等式组成的方程组<br>$$v(x,y)=\sum_{i=0}^3\sum_{j=0}^3a_{ij}x^iy^j$$</li></ul><h2 id="像素间的基本关系"><a href="#像素间的基本关系" class="headerlink" title="像素间的基本关系"></a>像素间的基本关系</h2><h3 id="相邻像素"><a href="#相邻像素" class="headerlink" title="相邻像素"></a>相邻像素</h3><p>设$p:(x,y)$为一像素</p><ul><li>4邻域: 上下左右<br>$$N_4(p)=(x-1,y), (x+1,y), (x,y-1), (x,y+1)$$</li><li>4对角邻域: 对角线四个方向<br>$$N_D(p)=(x-1,y-1), (x-1,y+1), (x+1,y-1), (x+1,y+1)$$</li><li>8邻域(p): 周围的8个像素<br>$$N_8=N_4+N_D$$</li></ul><h3 id="邻接性"><a href="#邻接性" class="headerlink" title="邻接性"></a>邻接性</h3><ul><li>定义: 令$V$为用于定义邻接性的灰度值集合<ul><li>二值图像: $V=\{1\}$或$V=\{0\}$</li><li>非二值图像: 灰度级的子集, 如$V=\{128, 129,\cdots, 255\}$</li></ul></li><li>$V$集合将灰度级化为2个等价类, 也可认为它将灰度图像染成二值图像</li><li>4邻接: $q\in N_4(p)$, $q$与$p$的灰度都在$V$中</li><li>8邻接: $q\in N_8(p)$, $q$与$p$的灰度都在$V$中</li><li>m邻接(混合邻接): $q$与$p$的灰度都在$V$中, 且:<br>若$q\in N_4(p)$;<br>或$q\in N_D(p)$, 且$N_4(p)\cap N_4(q)$的灰度都不在集合$V$中</li></ul><h3 id="连通性"><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h3><ul><li>通路: $(x_0=x, y_0=y),(x_1, y_1), \cdots, (x_{N-1}, y_{N-1}),(x_N=s,y_N=t)$<ul><li>相邻的像素点是邻接的</li><li>长度为$N$</li><li>若$(x,y)=(s,t)$, 则为闭合通路</li></ul></li><li>连通集<ul><li>在$S$中是连通: 取$S$额外i图像中像素的子集. 如果在$S$中全部u像素之间存在一条$p$到$q$的通路, 则说明$p$和$q$在$S$中是连通的</li><li>连通分量: 对于$S$中任何像素$p$, $S$中连通到该像素的像素集叫做$S$的连通分量</li><li>连通集: 若$S$仅有一个连通分量, 则$S$叫做连通集</li></ul></li></ul><h3 id="区域"><a href="#区域" class="headerlink" title="区域"></a>区域</h3><ul><li>区域: $R$为连通集, 则$R$称为区域</li><li>邻接区域: 如果两个区域联合形成一个连通集, 那么他们是邻接区域</li><li>假设图像包括$K$个不连接的区域, 即$R_1, R_2, \cdots, R_K$, 且不接触边界<ul><li>前景: $K$个区域的并集$R_u$</li><li>背景: 其补集$(R_u)^C$</li></ul></li></ul><h3 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h3><ul><li>一个区域R的边界（也称为边缘或轮廓线）是区域$R$中像素的集合<ul><li>这些点与R补集中的点邻近</li><li>这些点至少有一个背景邻点</li></ul></li><li>用8连通定义</li><li>边界与边缘<ul><li>边界：一个有限区域的边界（通常）形成一条闭合通路, 是个“整体”概念</li><li>边缘：具有某些导数值（超过预先设定的阈值）的像素形成, 是个“局部”概念</li><li>边界只考察其邻点是否属于集合V, 属于二值判断。边缘考察灰度级的差别, 粒度更细。边缘可能不闭合</li><li>什么时候边缘=边界？二值图像</li></ul></li></ul><h3 id="距离度量"><a href="#距离度量" class="headerlink" title="距离度量"></a>距离度量</h3><ul><li>$D$为距离函数, 若<ul><li>$D(p,q)\geq 0$, 且$D(p,q)=0$当且仅当$p=q$</li><li>$D(p,q)=D(q,p)$</li><li>$D(p,z)\leq D(p,q)+D(q,z)$</li></ul></li><li>欧式距离<br>$$D_r(p,q)=\sqrt{(x-s)^2+(y-t)^2}$$</li><li>$D_4$距离(曼哈顿距离)<br>$$D_4(p,q)=|x-s| + |y-t|$$</li><li>$D_8$距离(棋盘距离)<br>$$D_8(p,q)=\max(|x-s|,|y-t|)$$</li></ul><h2 id="空间域图像增强背景知识"><a href="#空间域图像增强背景知识" class="headerlink" title="空间域图像增强背景知识"></a>空间域图像增强背景知识</h2><ul><li>增强的首要目标是处理图像, 使其比原始图像更适合于特定应用, 没有通用的理论和标准</li><li>方法<ul><li>空间域方法: 图像平面本身, 直接处理像素: 离散</li><li>变换域方法: 频域(傅里叶变换): 连续<blockquote><p>空间域-&gt;变换域-&gt;处理-&gt;空间域</p></blockquote></li></ul></li><li>空间域方法是直接对像素操作的过程<br>$g(x,y)=T(f(x,y))$<br>$g$: 输出图像; $T$: 操作算子, 定义在$(x,y)$的邻域; $f$: 原始图像<blockquote><p>边界: 忽略外部, 填充</p></blockquote></li><li>类型<ul><li>空间滤波<ul><li>空间滤波器: 邻域, 预定义的操作</li></ul></li><li>灰度变换<ul><li>邻域大小为1的空间滤波</li><li>灰度变换函数$s=T(r)$</li><li>函数可以存储在一维数组, 查表实现映射</li></ul></li></ul></li></ul><h2 id="基本灰度变换"><a href="#基本灰度变换" class="headerlink" title="基本灰度变换"></a>基本灰度变换</h2><ul><li>线性函数<ul><li>图像反转公式: $s=L-1-r$, $L=2^b$</li><li>改变分析图象的难易</li></ul></li><li>对数函数<ul><li>低灰度值拉伸, 高灰度值压缩: $s=c\log(1+r)$</li><li>看到更多细节</li></ul></li><li>幂律函数<ul><li>伽马变换: $s=cr^\gamma$</li><li>更接近真实值(显示器)</li><li>调节参数$\gamma$可以在细节和对比度当中权衡</li></ul></li><li><p>分段线性函数</p><blockquote><p>折线: $(0,0)-&gt;(r_1,s_1)-&gt;(r_2,s_2)-&gt;(L-1, L-1)$</p><ul><li>对比拉伸变换: 单调递增</li><li>线性函数: $s_1=r_1$, $s_2=r_2$</li><li>阈值处理函数: $r_1=r_2$, $s_1=0$, $s_2=L-1$</li><li>灰度级分层: 突出特定灰度范围的亮度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   +---+</span><br><span class="line">   |   |</span><br><span class="line">---+   +---</span><br></pre></td></tr></table></figure></li></ul></blockquote></li><li><p>比特平面分层</p><ul><li>突出特定比特的作用: 8比特图像可认为有8个1比特平面组成</li><li>高阶比特: 视觉上重要的数据</li><li>低阶比特: 精细的灰度细节</li><li>函数实现: 第$n$比特平面: $r=(s&gt;&gt;(n-1)) \&amp; 1$</li><li>应用: 确定量化该图像比特数的充分性, 图像压缩(伪轮廓)</li></ul></li></ul><h2 id="直方图处理"><a href="#直方图处理" class="headerlink" title="直方图处理"></a>直方图处理</h2><ul><li>灰度直方图$H(D)$<ul><li>横坐标: 灰度级</li><li>纵坐标: 该灰度级出现的频率(此灰度级像素的数量)</li></ul></li><li>阈值面积函数$A(D)$<ul><li>连续图像中具有灰度级$\geq D$的轮廓线所包围的面积<br>$$A(D)-\int_D^\infty H(p)dp$$</li></ul></li><li>概率密度函数(PDF)<ul><li>归一化到单位面积的直方图<br>$$PDF=P(D)=\frac{1}{A_0}H(D)$$</li></ul></li><li>累计分布函数(CDF)<ul><li>归一化后灰度级$\geq D$的轮廓线所包围的面积<br>$$CDF=P(D)=\inf_0^Dp(u)du=\frac{1}{A_0}H(u)du$$</li></ul></li><li>严格的数学定义<br>$$H(D=\lim_{\delta D\to 0}\frac{A(D)-A(D+\delta D)}{D+\delta D-D}=\lim_{\delta D\to 0}\frac{A(D)-A(D+\delta D)}{\delta D}=-\frac{d}{dD}A(D)$$<ul><li>数字图像时, 简化为<br>$$H(D)=A(D)-A(D+1)$$</li></ul></li><li>实现<ol><li>初始化hist[k]=0; k=0, …, L-1</li><li>统计hist[f(x,y)]++; x=0, …, M-1; y=0, …,N-1</li><li>归一化hist[f(x,y)]/(M*N)</li></ol></li><li>应用<ol><li>图像快速检测: 是否合理的利用了全部被允许的灰度级范围, 从而及早发现数字化中出现的问题</li><li>分割前景背景: 双峰直方图, 取低谷灰度值作为分割点</li><li>面积计算: 类似前景背景, 用直方图计数像素</li></ol></li></ul><h1 id="第三章-空间与图像增强-Part-II"><a href="#第三章-空间与图像增强-Part-II" class="headerlink" title="第三章: 空间与图像增强(Part II)"></a>第三章: 空间与图像增强(Part II)</h1><h2 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h2><ul><li>直方图均匀分布时, 对比度会有明显增强</li><li>通过灰度变换函数, 将原图像直方图的分布均衡化, 这一过程称为直方图均衡化用灰度变换函数让直方图均匀分布</li><li>线性运算: $s=T(r)=a\times r + b$</li><li>灰度变换函数与直方图<ul><li>输入图像的概率密度: $p_r(r)$; 输出图像的概率密度: $p_s(s)$; 变换函数$T$<blockquote><p>这里只考虑单调递增函数</p></blockquote></li><li>单调连续函数<ul><li>$r\in [0,L-1]$<br>$$s=T(r)$$<ul><li>$T(r)$在区间$[0,L-1]$内是单调递增函数</li><li>当$0\leq r\leq L-1$时, $0\leq T(r)\leq L-1$</li></ul></li><li>更强的假设<ul><li>$T(r)$在区间$[0,L-1]$是严格单调递增函数, 此时有逆函数<br>$$r=T^{-1}(s)$$</li></ul></li></ul></li><li>概率密度公式<br>$$p_s(s)=p_r(r)|\frac{dr}{ds}|=p_r(r)|(\frac{ds}{dr}06{-1}|=p_r(T^{-1}(s))|\frac{1}{T’(T^{-1}(s))}|$$</li></ul></li><li>连续函数<ul><li>设计$T(r)$, 使得$p_s(s)$是均匀分布<br>$$s=T(r)=(L-1)\int_0^rp_r(w)dw$$</li></ul></li><li>离散直方图<br>$$s_k=T(r_k)=(L-1)\sum_{j=0}^k p_r(r_j)$$<h2 id="直方图匹配-规定化"><a href="#直方图匹配-规定化" class="headerlink" title="直方图匹配(规定化)"></a>直方图匹配(规定化)</h2></li><li>处理后的图像具有某种指定的直方图形状</li><li>这种用于产生处理后有特殊直方图的图像的方法, 叫做直方图匹配或直方图规定化处理</li><li>以均衡化直方图为桥梁: A:$p_r(r)$–&gt;B(均衡化图像):$p_s(s)$–&gt;C:$p_z(z)$<ul><li>输入图像灰度值概率密度$p_r(r)$<br>$$s=T(r)=(L-1)\int_0^rp_r(w)dw$$</li><li>指定灰度值概率密度$p_z(z)$<br>$$G(z)=(L-1)\int_0^zp_z(t)dt=s$$</li><li>反函数唯一<br>$$z=G^{-1}(s)=G^{-1}(T(r))$$</li></ul></li><li>离散直方图<ul><li>输入离散直方图$p_r(r_k)$<br>$$s_k=\frac{L-1}{MN}\sum_{j=0}^kn_j$$</li><li>指定离散直方图$p_z(z_k)$<br>$$G(z_q)=(L-1)\sum_{i=0}^qp_z(z_i)=s_k$$</li><li>查表实现: 取邻近值, 不唯一时取最小的<br>$$z_q=G^{-1}(s_k)$$<h2 id="局部直方图均衡化"><a href="#局部直方图均衡化" class="headerlink" title="局部直方图均衡化"></a>局部直方图均衡化</h2></li></ul></li><li>特性<ul><li>整体处理, 小细节易被忽略</li><li>只希望对局部进行增强</li><li>图像中每个像素的邻域中灰度分布为基础设计变换函数</li></ul></li><li>步骤<ul><li>定义一个邻域, 不断平移中心位置<ul><li>每一位置, 计算该领域中, 点的直方图</li><li>利用直方图均衡化或匹配得到变换函数</li><li>将变换函数作用到邻域中心像素</li></ul></li><li>重复上述过程<h2 id="直方图统计量用于局部图像增强"><a href="#直方图统计量用于局部图像增强" class="headerlink" title="直方图统计量用于局部图像增强"></a>直方图统计量用于局部图像增强</h2></li></ul></li><li>局部均值<br>$$m_{s_{xy}}=\sum_{i=0}^{L-1}r_ip_{s_{xy}}(r_i)$$</li><li>局部方差<br>$$\sigma^2_{s_{xy}}=\sum_{i=0}^{L-1}(r_i-m_{s_{xy}})^2p_{s_{xy}}(r_i)$$</li><li>局部直方图统计增强<br>$$g(x,y)=\begin{cases}<br>  E\cdot f(x,y) &amp;\textrm{if }m_{s_{xy}}\leq k_0m_G\textrm{ AND }k_1\sigma_G\leq \sigma_{s_{xy}}\leq k_2\sigma_G \\<br>  f(x,y) &amp;\textrm{otherwise}<br>\end{cases}$$</li></ul><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><h2 id="空间滤波"><a href="#空间滤波" class="headerlink" title="空间滤波"></a>空间滤波</h2><h3 id="空间滤波基础"><a href="#空间滤波基础" class="headerlink" title="空间滤波基础"></a>空间滤波基础</h3><ul><li>空间滤波机理<ul><li>空间滤波器<ul><li>邻域(矩形)</li><li>预定义的操作</li></ul></li><li>$m\times n$的模板<ul><li>$m=2a+1$, $n=2b+1$</li><li>最小为$3\times3$</li></ul></li><li>滤波操作</li><li>线性滤波<->频率域滤波</-></li></ul></li><li>空间相关与卷积<ul><li>相关: 平移滤波器模板, 计算每个位置乘积求和<ul><li>补零, 计算, 滑动, 裁剪</li><li>[补公式]</li><li>寻找匹配: 归一化乘积(向量长度为1), 值最大时, 图像与模板相同</li></ul></li><li>卷积: 滤波器要旋转180, 其他与相关相同<ul><li>旋转, 补零, 计算, 滑动, 裁剪</li><li>[补公式]</li></ul></li><li>线性滤波的向量表示: 矩阵相乘拉成向量相乘</li></ul></li><li>空间滤波器模板<ul><li>计算平均灰度</li><li>两变量的连续函数</li><li>非线性滤波器<h3 id="平滑空间滤波器"><a href="#平滑空间滤波器" class="headerlink" title="平滑空间滤波器"></a>平滑空间滤波器</h3></li></ul></li><li>均值滤波器<ul><li>优点: 降低噪声; 缺点: 边缘模糊</li><li>先求和, 再归一化(先乘全1矩阵, 后除以9)</li></ul></li><li>加权线性滤波器<ul><li>非均匀权重, 降低模糊</li></ul></li><li>非线性滤波器<ul><li>对滤波器覆盖的像素排序, 排序决定的值替代中心线像素</li></ul></li><li>中值滤波器, 最大值滤波器, 最小值滤波器<h3 id="锐化空间滤波器"><a href="#锐化空间滤波器" class="headerlink" title="锐化空间滤波器"></a>锐化空间滤波器</h3>突出灰度的过渡部分</li><li>数学基础<ul><li>微分取值<br>||恒定灰度|恒定斜率|突变|<br>|-|-|-|-|<br>|一阶微分|0|非0|非0|<br>|二阶微分|0|0|非0|</li><li>使用二阶微分对图像锐化</li></ul></li><li>各向同性滤波器</li><li>拉普拉斯算子<ul><li>标准形式: 四角0, 四边1, 中间-4</li><li>对角形式: 四角四边1, 中间-8</li><li>拉普拉斯算子的结果叠加到图像中, 取中心系数为-1</li></ul></li><li>非锐化掩蔽<ul><li>模糊图像, 原图减去模糊图像得到模板, 加到原图像</li></ul></li><li>梯度<ul><li>利用梯度的大小<ul><li>梯度: 最大变化率的方向<br>$$\nabla f\equiv\mathrm{grad}(f)\equiv \begin{bmatrix} g_x \\ g_y \end{bmatrix} = \begin{bmatrix} \frac{\partial f}{\partial x} \\ \frac{\partial f}{\partial y} \end{bmatrix}$$</li><li>大小:<br>$$M(x,y)=\mathrm{mag}(\nabla f)=\sqrt{g_x^2 + g_y^2}\approx |g_x|+|g_y|$$</li></ul></li><li>梯度的离散近似<ul><li>最简单的近似:<br>$$\begin{aligned}<br>  g_x &amp;= z_8 - z_5\\<br>  g_y &amp;= z_6 - z_5\\<br>\end{aligned}$$</li><li>交叉差分: 罗伯特交叉梯度算子<br>$$\begin{aligned}<br>  g_x &amp;= (z_7+2z_8+z_9) - (z_1+2z_2+z_3)\\<br>  g_y &amp;= (z_3+2z_6+z_9) - (z_1+2z_4+z_7)\\<br>\end{aligned}$$</li><li>对称模板: Soble算子<h3 id="混合空间增强法"><a href="#混合空间增强法" class="headerlink" title="混合空间增强法"></a>混合空间增强法</h3></li></ul></li></ul></li><li>综合使用各种增强方法</li></ul><h2 id="算术操作增强"><a href="#算术操作增强" class="headerlink" title="算术操作增强"></a>算术操作增强</h2><p>像素对像素为基础, 在两幅或多幅图像之间进行</p><ul><li>加法<ul><li>定理: 对M幅加性噪声图像进行平均, 可以使图像的平方信噪比提高M倍</li></ul></li><li>减法<ul><li>图像差别的细节被观察到</li></ul></li><li>乘法：通常用来进行掩模运算</li><li>除法：通常可以用来归一化</li></ul><h1 id="频率域图像变化"><a href="#频率域图像变化" class="headerlink" title="频率域图像变化"></a>频率域图像变化</h1><p>## </p><ul><li>图像是连续信号的量化采样<ul><li>信号通常包括丰富的频域信息</li><li>傅里叶级数<ul><li>周期函数: 表示为不同频率的正/余弦函数的 加权之和</li><li>非周期函数: 表示为不同频率的正/余弦函数 加权求和的积分</li></ul></li><li>意义: 热扩散, 信号处理</li></ul></li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>复数$C$<br>  $$C=R+jH$$<br>$R,H\in\mathbb{R}, i=\sqrt{-1}$ </li><li>欧拉公式<br>$$e^{j\theta}=\cos\theta+j\sin\theta$$</li></ul><h3 id="连续冲激与采样"><a href="#连续冲激与采样" class="headerlink" title="连续冲激与采样"></a>连续冲激与采样</h3><ul><li>在0处的连续单位冲激<br>$$\delta=\begin{cases}<br>  \infty\quad&amp;\text{if }t=0\\<br>  0\quad &amp;\text{if }t\ne0<br>\end{cases}$$<br>$$\int_{-\infty}^{\infty}\delta(t)dt=1$$</li><li><p>采样性质</p><ul><li>$\int_{1}^{2}$</li></ul></li><li><p>离散冲激</p></li><li>连续离散冲激</li></ul><h3 id="傅里叶级数"><a href="#傅里叶级数" class="headerlink" title="傅里叶级数"></a>傅里叶级数</h3><ul><li>周期为$T$的连续函数$f(t)$可以表示为正弦和余弦函数的加权之和<br>$$\mathfrak{J}\{f(t)\}=\sum_{n=-\infty}^\infty c_ne^{j\frac{2\pi n}{T}t}$$<br>其中<br>$$c_n=\int_{}^{}$$</li><li>傅里叶变换的幅值<br>$|F(\mu)|=AT\mathfrak{J}$</li></ul><ul><li><p>连续卷积<br>$$f(t)\star h(t)=\int_{-\infty}^\infty f(\tau)h(t-\tau)d\tau$$<br>$$\mathfrak{J}\{f(t)\star h(t)\}=H(\mu)F(\mu)$$<br>$$\mathfrak{J}\{f(t)h(t)\}=H(\mu)\star F(\mu)$$</p></li><li><p>连续函数采样<br>采样是有限的</p><p>带限函数一定是$-\infty$到$\infty$的<br>有限长度的采样, 混淆是不可避免的</p><p>平滑输入函数, 减少高频分量(图像散焦)</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第二章-空间域图像增强-Part-I&quot;&gt;&lt;a href=&quot;#第二章-空间域图像增强-Part-I&quot; class=&quot;headerlink&quot; title=&quot;第二章: 空间域图像增强(Part I)&quot;&gt;&lt;/a&gt;第二章: 空间域图像增强(Part I)&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
      <category term="Course" scheme="https://Maxwell-lyu.github.io/tags/Course/"/>
    
      <category term="Digital Image Processing" scheme="https://Maxwell-lyu.github.io/tags/Digital-Image-Processing/"/>
    
  </entry>
  
  <entry>
    <title>CM-ALL</title>
    <link href="https://Maxwell-lyu.github.io/2019/09/04/Learn-CM-20190904-CM-ALL/"/>
    <id>https://Maxwell-lyu.github.io/2019/09/04/Learn-CM-20190904-CM-ALL/</id>
    <published>2019-09-04T06:02:01.000Z</published>
    <updated>2019-10-09T13:00:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lesson-1"><a href="#Lesson-1" class="headerlink" title="Lesson 1"></a>Lesson 1</h1><ul><li><p>combinatorial $\sim$ discrete &amp; finite</p><ul><li>solution combinatorial object</li><li>constraint combinatorial structure</li></ul></li><li><p>Enumeration: How many solutions satisfying the constraints</p></li><li>Existence: Does there exist a solution</li><li>Extremal: How large/small a solution can be to preserve/avoid structure</li><li>Ramsey: when a solution is sufficiently large, some structures must emerge</li><li>Optimization: find the optimal solution</li><li><p>Construction: construct a solution</p></li><li><p>Enumeration(Counting)</p><ul><li>How many ways are there:<ol><li>$n!$ to rank $n$ people</li><li>$12^n$ to assign $m$ zodiac signs to $n$ people</li><li>$n \choose m$ to choose $m$ people out of $n$ people</li><li>$n-1 \choose m-1$ to partition $n$ people into $m$ groups</li><li>$?$ to distribute $m$ yuan to $n$ people </li><li>$?$ to partition $m$ yuan to $n$ parts </li></ol></li></ul></li></ul><table><thead><tr><th>Name</th><th>Description</th><th>Notation</th><th>Number</th><th>Repetition</th><th>Ordered</th></tr></thead><tbody><tr><td>Tuple</td><td>$n$-tuples of $[m]$</td><td>$[m]^n$</td><td>$m^n$</td><td>Y</td><td>Y</td></tr><tr><td>Nultiset</td><td>$k$-multiset of $n$-set</td><td>-</td><td>${n+k-1\choose k}$</td><td>Y</td><td>N</td></tr><tr><td>Subset</td><td>$k$-uniform of $n$-set, $\</td><td>S\</td><td>=n$</td><td>-</td><td>$\binom{n}{k}$</td><td>N</td><td>N</td></tr><tr><td>Partition</td><td>$k$-partition of $n$-set</td><td>-</td><td>$\{ {n\atop k} \}$</td><td>N</td><td>N</td></tr></tbody></table><ul><li>The product rule: $|S\times T|=|S|\cdot|T|$ </li><li>The bijection rule: if there exists a bijection between finite sets $S$ and $T$, then $|S|=|T|$.</li></ul><ul><li>Tuples<ul><li>$[m]=\{1,2,\cdots,m\}$</li><li>$[m]^n=[m] \times [m] \times\cdots\times [m]$</li><li>$#$ of tuples: $|[m]^n|=m^n$</li></ul></li><li>Functions<ul><li>$f:[n]\to[m]$</li><li>$#$ of functions: $m^n$<blockquote><p>Proof: $f:[n]\to[m]\Leftrightarrow v_f\in[m]^n$</p></blockquote></li></ul></li><li>Subsets<ul><li>Power set: $2^{[n]}={S|S\subseteq [n]}$</li><li>$|2^{[n]}|=2^n$</li><li>Proof: $S\subseteq [n]\leftrightarrow \{0,1\}^n$</li></ul></li><li>Subsets of fixed size<ul><li>$#$ of $k$-uniform: ${n \choose k}=\frac{n!}{k!(n-k)!}$</li><li>$(n)_k=n(n-1)\cdots(n-k+1)$ is $n$ lower factorial of $k$</li></ul></li><li>Binomial coefficients<ul><li>${n \choose k}={n\choose n-k}$</li><li>$\sum_{k=0}^{n}{n \choose k}=2^n$</li><li>$(1+x)^n=\sum_{k=0}^{n}{n \choose k}x^k$<blockquote><p>Proof: $(1+x)^n=(1+x)(1+x)\cdots(1+x)$, $#$ of $x^k$ is $n\choose k$</p></blockquote></li><li>$S=\{x_1, x_2,\cdots,x_n\}$, $#$ of odd subsets $=$ $#$ of even subsets<blockquote><p>proof: let $x=-1$</p></blockquote></li></ul></li><li>Compositions of an integer<ul><li>$k$-composition of $n$: $k$-tuple that $x_1+x_2+\cdots+x_n=n$, $x_i\in\{1,2,\cdots x_n\}$</li><li>$#$ of $k$-composition: $n-1 \choose k-1$</li><li>weak $k$-composition of $n$: $x_i$ can be 0, aka $(x_1+1)+(x_2+1)+\cdots+(x_n+1)=n+k$</li><li>$#$ of weak $k$-composition: $n+k-1\choose k-1$</li></ul></li><li>Multisets<ul><li>Combinations with repetitions can be formally defined as multisets.</li><li>$({n \choose k})={n+k-1\choose k}$</li></ul></li><li>Multinomial coefficients<ul><li>$\binom{n}{m_1,m_2,\cdots, m_k}=\frac{n!}{m_1!m_2!\cdots m_k!}$, $\sum_i m_i=n$</li><li>$\binom{n}{m, n-m}=\binom{n}{m}$</li><li>$(x_1,x_2,\cdots,x_k)^n=\sum_{m_1+m_2+\cdots+m_k=n}\binom{n}{m_1,m_2,\cdots, m_k}x_1^{m_1}\cdots x_k^{m_k}$</li></ul></li><li>Partitions of a set<ul><li>partition of $S$: $P={S_1,S_2,\cdots,S_k}$, $S_i\ne\emptyset$, $S_i\cap S_j$ if $i\ne j$, $\bigcup S_i=S$</li><li>if $|P|=k$, then $P$ is a $k$-partition of $S$</li><li>$#$ of $k$-partitions of a $n$-set is $\{ {n\atop k} \}$</li><li>Stirling number of the second kind</li></ul></li><li>The twelvfold way  </li></ul><table><thead><tr><th style="text-align:center">$n$ balls</th><th style="text-align:center">$m$ bins</th><th style="text-align:center">unrestricted</th><th style="text-align:center">$\leq 1$ for all bin</th><th style="text-align:center">$\geq 1$ for all bin</th></tr></thead><tbody><tr><td style="text-align:center">distinct</td><td style="text-align:center">distinct</td><td style="text-align:center">$m^n$</td><td style="text-align:center">$(m)_n=n!\binom{m}{n}$</td><td style="text-align:center">$m!\{ {n\atop m} \}$</td></tr><tr><td style="text-align:center">identical</td><td style="text-align:center">distinct</td><td style="text-align:center">$(\binom{m}{n})$</td><td style="text-align:center">$m\choose n$</td><td style="text-align:center">$\binom{m-1}{n-1}$</td></tr><tr><td style="text-align:center">distinct</td><td style="text-align:center">identical</td><td style="text-align:center">$\sum_{k=1}^m\{ {n\atop k} \}$</td><td style="text-align:center">$1$</td><td style="text-align:center">$\{ {n\atop m} \}$</td></tr><tr><td style="text-align:center">identical</td><td style="text-align:center">identical</td><td style="text-align:center">$-$</td><td style="text-align:center">$-$</td><td style="text-align:center">$-$</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Lesson-1&quot;&gt;&lt;a href=&quot;#Lesson-1&quot; class=&quot;headerlink&quot; title=&quot;Lesson 1&quot;&gt;&lt;/a&gt;Lesson 1&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;combinatorial $\sim$ discrete &amp;amp; f
      
    
    </summary>
    
    
      <category term="Course" scheme="https://Maxwell-lyu.github.io/tags/Course/"/>
    
      <category term="Combinatorics" scheme="https://Maxwell-lyu.github.io/tags/Combinatorics/"/>
    
  </entry>
  
  <entry>
    <title>CN-ALL</title>
    <link href="https://Maxwell-lyu.github.io/2019/09/04/Learn-CN-20190904-CN-ALL/"/>
    <id>https://Maxwell-lyu.github.io/2019/09/04/Learn-CN-20190904-CN-ALL/</id>
    <published>2019-09-04T01:33:26.000Z</published>
    <updated>2019-10-08T09:49:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>[Textbook]: Computer Networking: A Top-Down Approach(7th Edition) by James F. Kurose, Keith W. Ross<br><a id="more"></a> </p><h1 id="Chapter-1-Introduction-of-Networking"><a href="#Chapter-1-Introduction-of-Networking" class="headerlink" title="Chapter 1: Introduction of Networking"></a>Chapter 1: Introduction of Networking</h1><blockquote><p>[Textbook] 1.x, 2.7 </p></blockquote><h2 id="What’s-the-Internet"><a href="#What’s-the-Internet" class="headerlink" title="What’s the Internet"></a>What’s the Internet</h2><ul><li>Connected Devices<ul><li>Hosts = End systems</li><li>Run network applications</li></ul></li><li>Communication links<ul><li>Optical fiber, Copper, Radio, Satellite</li><li>Build physical networks</li></ul></li><li>Routers<ul><li>Forward packets between physical networks</li></ul></li></ul><blockquote><p>Com.Dev. <ruby>—&gt;<rt>Com.Lnk.</rt></ruby>Phys.NtWk<ruby>—&gt;<rt>Router</rt></ruby>Internet</p></blockquote><h2 id="Building-Internet"><a href="#Building-Internet" class="headerlink" title="Building Internet"></a>Building Internet</h2><ul><li>Communication Infrastructure<ul><li>Enables distributed applications</li><li>e.g: Web, VoIP, email, online games, e-commerce, file sharing</li></ul></li><li>Communication Services Provided<ul><li>IP: Unreliable, data delivery</li><li>TCP: Reliable data delivery</li><li>QoS: Guaranteed delay and throughput<blockquote><p>Delay: 延迟; Throughput: 吞吐量/网速</p></blockquote></li></ul></li><li>Network Protocols<ul><li>Control sending, receiving of messages</li><li>e.g: HTTP, Skype; TCP, IP; PPP, Ethernet</li></ul></li><li>Internet Standards <ul><li>IETF: Internet Engineering Task Force</li><li>RFC: Request for comments</li></ul></li><li>Internet: “network of networks”<ul><li>Public Internet versus private Intranet</li><li>Loosely hierarchical<blockquote><p>Intranet: 内部网</p></blockquote></li></ul></li></ul><h2 id="Internet-History"><a href="#Internet-History" class="headerlink" title="Internet History"></a>Internet History</h2><ul><li>1961-1972: Early packet-switching principles</li><li>1972-1980: Internetworking, new and proprietary nets</li><li>1980-1990: new protocols, a proliferation of networks</li><li>1990’s, 2000’s: commercialization, the Web, new apps</li><li>2007~Now:<ul><li>P2P applications</li><li>Iot: Internet of things</li><li>SON: Self-Organizing Network</li><li>SDN: Software Defined Network</li><li>CDN: Content Distribution Network</li><li>ICN: Information-Centric Network</li></ul></li></ul><h2 id="Access-Internet"><a href="#Access-Internet" class="headerlink" title="Access Internet"></a>Access Internet</h2><h3 id="Network-Edge"><a href="#Network-Edge" class="headerlink" title="Network Edge"></a>Network Edge</h3><ul><li>End systems (hosts)<ul><li>Run application programs</li><li>e.g. Web, Email </li></ul></li><li>Client/Server model(P2S)<ul><li>Client host requests, receives service from always-on server</li><li>e.g. Web browser/server; Email client/server</li></ul></li><li>Peer-to-peer model(P2P)<ul><li>Minimal (or no) use of dedicated servers</li><li>e.g. Skype, BitTorrent</li></ul></li></ul><h3 id="Access-Networks"><a href="#Access-Networks" class="headerlink" title="Access Networks"></a>Access Networks</h3><ul><li>Physical media(Wired and wireless com.lnk.)</li><li>Connect end systems to edge router<ul><li>Residential access networks (Home)<ul><li>Dialup vis modem: <ul><li>Up to 56Kbps</li><li>direct access to router</li></ul></li><li>DSL: Digital Subscriber line<ul><li>Deployment: Telephone company </li><li>Upstream: 1~3Mbps, Downstream: 8~24Mbps</li><li>Dedicated physical line to telephone central office</li></ul></li></ul></li><li>HFC: hybrid fiber coax<ul><li>Asymmetric: up to 30Mbps downstream, 2 Mbps upstream</li><li>Homes share access to ISP router</li><li>Deployment: cable TV companies</li></ul></li><li>Institutional networks (school, company)<ul><li>LAN connects end systems to router</li><li>Ethernet:<ul><li>10Mbps, 100Mbps, 1Gbps, 10Gbps</li><li>Modern configuration: Ethernet switch backbone connect end systems</li></ul></li></ul></li><li>Mobile access networks<ul><li><blockquote><p>End systems <ruby><--------><rt>Shared wireless media</rt></--------></ruby>Router</p></blockquote></li><li>Wireless LANs (WLAN)<ul><li>802.11b/g(WiFi): 11 or 54Mbps</li></ul></li><li>Wider-area wireless access<ul><li>Provided by telecommunication operator</li><li>10Mbps over cell network</li><li>LTE(4G) and WiMAX</li><li>20Gbps(5G?)</li></ul></li><li>Modern family<ul><li><blockquote><p><ruby>———=<rt>to/from cable headend</rt></ruby> Modem =—-= Router/Firewall =—-= Wireless AP - - - - Wireless Device</p></blockquote></li><li><blockquote><p><ruby>———=<rt>to/from cable headend</rt></ruby> Modem =—-= Router/Firewall <ruby>=—-=<rt>Ethernet</rt></ruby> Device</p></blockquote></li></ul></li></ul></li></ul></li><li>Performance<ul><li>Bandwidth (bps)</li><li>Shared or dedicated<blockquote><p>Dedicated: 专用的</p></blockquote></li></ul></li></ul><h3 id="Network-Core"><a href="#Network-Core" class="headerlink" title="Network Core"></a>Network Core</h3><ul><li>Interconnected routers(Network of networks)</li><li>Circuit Switching<ul><li>Performance: Link bandwidth, switch capacity</li><li>Dedicated circuit per call, e.g: telephone</li><li>Circuit-like (guaranteed) performance</li><li>Require call setup/teardown</li></ul></li><li>Packet Switching<ul><li>Each end-to-end data stream divided into packets</li><li>Application A, B packets share network resources</li><li>Store and forward: packets move one hop at a time, stored (queued) at switches</li><li>Each packet uses full link bandwidth</li><li>Resource contention: aggregate (burst-up) resource demand can exceed amount available</li><li>Congestion: packets queue and wait for link use</li></ul></li><li>Statistical Multiplexing<ul><li>Link bandwidth dedicated or shared</li><li>Sequence of packets have or have not fixed pattern</li><li>Source that has higher bit rate occupies more time intervals</li></ul></li><li>Virtual Circuit<ul><li>Circuit Swithching + Packet Switching</li><li>Fixed router and main cross roads</li><li>Shared resource, requird congestion control</li><li>Resource can be preserved, leadingto different performance</li><li>Require connection setup/teardown</li></ul></li><li>Internet Structure – Network of Networks<ul><li>Roughly hierarchical</li><li>At center: “Tier-1” (National) ISPs</li><li>“Tier-2” ISPs: smaller (often regional) ISPs</li><li>“Tier-3” ISPs and local/edge ISPs, connect access networks</li></ul></li></ul><h2 id="Typical-Network-Applications"><a href="#Typical-Network-Applications" class="headerlink" title="Typical Network Applications"></a>Typical Network Applications</h2><ul><li>Client/Server Applications</li><li>P2P Applications</li><li><h3 id="Client-Server-Architecture"><a href="#Client-Server-Architecture" class="headerlink" title="Client-Server Architecture"></a>Client-Server Architecture</h3></li></ul><ul><li>Server<ul><li>Always-on host</li><li>Permanent IP address</li><li>Server farms for scaling</li></ul></li><li>Clients<ul><li>Communicate with server</li><li>May be intermittently connected</li><li>May have dynamic IP addresses</li><li>Do not communicate directly with each other</li></ul></li><li>Web and HTTP<ul><li>Request: Clients use browser to send URL(URI)s via HTTP to servers requesting a Web page</li><li>Construct: Web pages constructed using HTML (or other markup language), inter-connected by URL</li><li>Respond: Servers (or caches) respond with requested Web page</li><li>Display: Client’s browser displays Web page returned by server</li></ul></li><li>FTP<ul><li>Transfer file to/from remote host</li><li>Control connection: Login/logout, file trans command/reply</li><li>Data connection: File contents, client side initiates file transfer</li></ul></li><li>E-Mail<ul><li>MIME: Multi-purpose Internet Mail<blockquote><p>Non-text data</p></blockquote></li><li>SMTP: Simple Mail Transfer Protocol<blockquote><p>Simple text mail</p></blockquote></li><li>POP: Post Office Protocol<blockquote><p>Mail retrieval from server, including authorization and download</p></blockquote></li><li>IMAP: Internet Mail Access Protocol<blockquote><p>Manipulation of stored mails on server</p></blockquote></li></ul></li></ul><h3 id="P2P-Application"><a href="#P2P-Application" class="headerlink" title="P2P Application"></a>P2P Application</h3><ul><li>BitTorrent<ul><li>File divided into chunks</li><li>Peer join torrent<ul><li>Register to tracker to get list of peers</li><li>Connect to some peers</li><li>Issue requests for missing chunks</li></ul></li><li>Upload chunks<ul><li>send </li></ul></li><li>Peers may come and go </li></ul></li><li>Skype<ul><li>P2P VoIP: PC/Phone</li><li>Proprietary application layer protocol<blockquote><p>Proprietary: 专有的</p></blockquote></li><li>Make a call<ul><li>Register: SC(skype client) register with SN(super node)</li><li>Authenticate: SC authenticate(log in)</li><li>Call: SC contact SN with caller ID</li><li>SN contacts other SNs to find callee address</li><li>SC directly contacts callee over UDP/TCP</li></ul></li><li>Login server: authentication; Super node: exchange address</li><li><h2 id="Protocol-Layers-and-Service-Model"><a href="#Protocol-Layers-and-Service-Model" class="headerlink" title="Protocol Layers and Service Model"></a>Protocol Layers and Service Model</h2></li></ul></li></ul><h3 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h3><ul><li>Physical<ul><li>bits across link</li><li>Physical interface</li><li>Physical aspects: Mechanical, Electrical/Optical, Functional/Procedural</li></ul></li><li>Data Link<ul><li>frames</li><li>activation, maintenance, deactivation of connection</li><li>medium access control for muiltiple access</li><li>error detection and retransmission: error-free transmission</li><li>flow control</li></ul></li><li>Network<ul><li>packet across mulltiple links/networks</li><li>addressing and routing</li><li>Forwarding transfers packet across a node</li><li>Congestion control to deal with traffic surges</li><li>Connection setup, maintenance, and teardown</li></ul></li><li>Transport<ul><li>data between end systems</li><li>Reliable stream transfer or quick-and-simple single-block transfer</li><li>Connection setup, maintenance, and release</li></ul></li><li>-Session- into App.</li><li>-Presentation- into App.</li><li>Application<ul><li>Means for applications to access OSI environment</li></ul></li><li>Service Primitives and Parameters<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      ServiceUserA                  ServiceUserB</span><br><span class="line">          +  |                            +  |</span><br><span class="line">Confirm   |  |   Request     Indication   |  |  Response</span><br><span class="line">          |  +                            |  +</span><br><span class="line">             (N-1) Layer Service Provider</span><br></pre></td></tr></table></figure></li></ul><h3 id="TCP-IP-Protocol-Architecture"><a href="#TCP-IP-Protocol-Architecture" class="headerlink" title="TCP/IP Protocol Architecture"></a>TCP/IP Protocol Architecture</h3><blockquote><p>Used by global Internet</p></blockquote><ul><li>Application: supporting network applications<blockquote><p>FTP, SMTP, HTTP</p></blockquote></li><li>Transport: process-process data transfer<blockquote><p>TCP, UDP</p></blockquote></li><li>Internetwork: routing of datagrams across net of nets<blockquote><p>IP, routing protocols</p></blockquote></li><li>Link: data transfer between neighboring routers / hosts<blockquote><p>PPP, Ethernet</p></blockquote></li><li>Physical: bits “on the wire”<br>Protocol Data Units(PDU)</li><li>Control info is added to user data at each layer</li><li>Segment and Header: Transport layer segments application data, a transport header added<ul><li>Destination SAP, Sequence number, Error detection code<br>The IP Layer in Detail</li></ul></li><li>Sender encapsulates segments into datagrams</li><li>Receiver delivers segments to transport layer</li><li>Router examines header fields in all IP datagrams</li></ul><h2 id="Network-Programming"><a href="#Network-Programming" class="headerlink" title="Network Programming"></a>Network Programming</h2><ul><li>Socket programming<ul><li>Build client/server application that communicate using sockets</li><li>A socket is a pair of [IP addresses, port]</li></ul></li><li>Socket API<ul><li>Introduced in BSD4.1 UNIX, 1981</li><li>Explicitly created, used, and released by applications</li><li>Implementing client/server paradigm</li></ul></li><li>2 types of transport service via socket API<ul><li>Unreliable datagram, i.e. UDP</li><li>Reliable, byte stream-oriented, i.e. TCP</li></ul></li></ul><h3 id="Socket-Programming-with-TCP"><a href="#Socket-Programming-with-TCP" class="headerlink" title="Socket Programming with TCP"></a>Socket Programming with TCP</h3><ul><li>Client: Create socket-&gt;Specify [IP<sub>s</sub>, Port<sub>s</sub>]-&gt;Recieve reply, connection [IP<sub>c</sub>, Port<sub>c</sub>; IP<sub>s</sub>,Port<sub>s</sub>]</li><li>Server: Create listening Socket-&gt;Accept contact, create new socket-&gt;connection [IP<sub>c</sub>, Port<sub>c</sub>; IP<sub>s</sub>, Port<sub>s</sub>]</li><li>Server distinguish clients using [IP<sub>c</sub>, Port<sub>c</sub>]</li><li>Interaction:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    SERVER                                        CLIENT </span><br><span class="line">    create listening socket  </span><br><span class="line">      |                         TCP con. setup</span><br><span class="line">+-&gt; wait for connection      &lt;----------------&gt;  create socket</span><br><span class="line">|     |                                             |</span><br><span class="line">|   read request             &lt;-----------------  send request</span><br><span class="line">|     |                                             |</span><br><span class="line">|   write reply              -----------------&gt;  read reply</span><br><span class="line">|     |                                             |</span><br><span class="line">+-- close                                         close</span><br></pre></td></tr></table></figure></li></ul><h3 id="Socket-Programming-with-UDP"><a href="#Socket-Programming-with-UDP" class="headerlink" title="Socket Programming with UDP"></a>Socket Programming with UDP</h3><ul><li>No connection</li><li>Sender attaches IP address, port of destination to each packet</li><li>Receiver extract IP address, port of sender from received packet</li><li>Transmitted data may be received out of order, or lost</li><li>Interaction:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    SERVER                                        CLIENT </span><br><span class="line">    create listening socket  </span><br><span class="line">      |                                             </span><br><span class="line">+-&gt; read request             &lt;-----------------  send request</span><br><span class="line">|     |                                             |</span><br><span class="line">|   write reply              -----------------&gt;  read reply</span><br><span class="line">|     |                                             |</span><br><span class="line">+-- close                                         close</span><br></pre></td></tr></table></figure></li></ul><h2 id="Delay-Loss-and-Throughput"><a href="#Delay-Loss-and-Throughput" class="headerlink" title="Delay, Loss and Throughput"></a>Delay, Loss and Throughput</h2><h3 id="Delay"><a href="#Delay" class="headerlink" title="Delay"></a>Delay</h3><ul><li>Source of delay<ul><li>Transmission: $L/R$; microseconds</li><li>Propagation: $d/s$; microseconds</li><li>Nodal processing: Error-check &amp; determine link; microseconds</li><li>Queuing: wait in queue, congestion level; seconds</li></ul></li><li>Queuing Delay<ul><li>Traffic intensity: $\rho = L\times\alpha/R$<blockquote><p>$\alpha$: average packet arrival rate</p><ul><li>$\rho\sim 0$: average queuing delay small</li><li>$\rho\to 1$: delays become large</li><li>$\rho\geq 1$: delays infinite</li></ul></blockquote></li></ul></li><li>“Real” Internet Delays and Routes<ul><li>traceroute<ul><li>Provides delay measurement from source to router along end-to-end Internet path towards destination</li><li>Each intermediate router will return packets to sender</li><li>Sender records time interval between transmission and reply</li></ul></li></ul></li></ul><h3 id="Loss"><a href="#Loss" class="headerlink" title="Loss"></a>Loss</h3><ul><li>Buffer of a router has finite capacity</li><li>Packet arriving to full queue dropped</li><li>Lost packet may be retransmitted, if not, it’s lost</li></ul><h3 id="Throughput"><a href="#Throughput" class="headerlink" title="Throughput"></a>Throughput</h3><ul><li>Rate (bits/unit per time) at which bits transferred between sender/receiver</li><li>Instantaneous or Average</li><li>Multiplexing: $\min(R_c, R_s, R/N_l)$</li></ul><h2 id="Networks-under-Attack-Security"><a href="#Networks-under-Attack-Security" class="headerlink" title="Networks under Attack: Security"></a>Networks under Attack: Security</h2><ul><li>Attacks on Internet infrastructure<ul><li>Infecting/attacking hosts: malware, spyware, worms,   unauthorized access</li><li>Packet sniffing, replay, masquerade</li><li>Denial of service: deny access to resources (servers, link bandwidth)</li></ul></li><li>Internet not originally designed with security in mind<ul><li>Original vision: “a group of mutually trusting users attached to a transparent network”</li><li>Internet protocol designers playing “catch-up”</li><li>Security considerations in all layers!</li></ul></li></ul><h3 id="Different-Types-of-Malware"><a href="#Different-Types-of-Malware" class="headerlink" title="Different Types of Malware"></a>Different Types of Malware</h3><ul><li>Virus: Infection, Run executables, Self-replicating</li><li>Worm:  Transmitting over a network</li><li>Trojan horses: Disguised as innocuous or desirable, Tempting user to run</li><li>Backdoor: Bypassing authentication procedures</li><li>Adware: Advertisements</li><li>Spyware: Recording activity</li></ul><h3 id="Types-of-Attack"><a href="#Types-of-Attack" class="headerlink" title="Types of Attack"></a>Types of Attack</h3><ul><li>Denial of Service(DoS)<ul><li>overwhelming resource with bogus traffic</li><li>Break into hosts -&gt; use compromised hosts to send packets to target</li></ul></li><li>Packet Sniffing<ul><li>Broadcast media required</li><li>Promiscuous NIC reads/records all packets passing by</li></ul></li><li>IP Spoofing<ul><li>putting any value into IP source address field</li><li>Receiver can’t tell if source is spoofed</li></ul></li><li>Masquerade<ul><li>IP spoofing: send packet with false source address</li><li>Record-and-playback: sniff sensitive info (e.g.,password), and use later</li></ul></li></ul><h3 id="Catch-Up"><a href="#Catch-Up" class="headerlink" title="Catch-Up"></a>Catch-Up</h3><ul><li>What Trudy Might Do<ul><li>Eavesdrop: intercept messages</li><li>Insert messages into connection</li><li>Impersonation: can fake (spoof) source address</li><li>Hijacking: “take over” ongoing connection by removing sender or receiver, inserting himself in place</li><li>Denial of service: prevent service from being used by others</li></ul></li><li>How to Handle This<ul><li>Encryption: the message cannot be understood</li><li>MAC: the message cannot be altered</li><li>Sign: the source cannot be forged</li></ul></li></ul><h1 id="Chapter-2-Direct-Link-Networks"><a href="#Chapter-2-Direct-Link-Networks" class="headerlink" title="Chapter 2. Direct Link Networks"></a>Chapter 2. Direct Link Networks</h1><blockquote><p>[Textbook] 6.x, 7.x</p></blockquote><h2 id="必考内容"><a href="#必考内容" class="headerlink" title="必考内容"></a>必考内容</h2><p>冲突检测（以太网）CSMA/DA<br>1234567890-=·qwertyuiooppp[]\asdfghjkl;’<br>zxcvbnm</p><h1 id="Chapter-3-Packet-Switching-Networks"><a href="#Chapter-3-Packet-Switching-Networks" class="headerlink" title="Chapter 3. Packet Switching Networks"></a>Chapter 3. Packet Switching Networks</h1><blockquote><p>[Textbook] 4.1, 4.2, 5.1, 5.2</p></blockquote><h1 id="Chapter-4-Internetworking"><a href="#Chapter-4-Internetworking" class="headerlink" title="Chapter 4. Internetworking"></a>Chapter 4. Internetworking</h1><blockquote><p>[Textbook] 4.3, 5.3, 5.4, 5.5, 5.6</p></blockquote><h1 id="Chapter-5-End-to-End-Protocols"><a href="#Chapter-5-End-to-End-Protocols" class="headerlink" title="Chapter 5. End-to-End Protocols"></a>Chapter 5. End-to-End Protocols</h1><blockquote><p>[Textbook] 3.1, 3.2, 3.3, 3.4, 3.5, 9.x </p></blockquote><h1 id="Chapter-6-Congestion-Control-and-QoS"><a href="#Chapter-6-Congestion-Control-and-QoS" class="headerlink" title="Chapter 6. Congestion Control and QoS"></a>Chapter 6. Congestion Control and QoS</h1><blockquote><p>[Textbook] 3.6, 3.7</p></blockquote><h1 id="Chapter-7-Network-Security"><a href="#Chapter-7-Network-Security" class="headerlink" title="Chapter 7. Network Security"></a>Chapter 7. Network Security</h1><blockquote><p>[Textbook] 8.x</p></blockquote><h1 id="Chapter-8-Internet-Applications"><a href="#Chapter-8-Internet-Applications" class="headerlink" title="Chapter 8. Internet Applications"></a>Chapter 8. Internet Applications</h1><blockquote><p>[Textbook] 2.x</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[Textbook]: Computer Networking: A Top-Down Approach(7th Edition) by James F. Kurose, Keith W. Ross&lt;br&gt;
    
    </summary>
    
    
      <category term="Course" scheme="https://Maxwell-lyu.github.io/tags/Course/"/>
    
      <category term="Computer Network" scheme="https://Maxwell-lyu.github.io/tags/Computer-Network/"/>
    
  </entry>
  
  <entry>
    <title>DB-ALL</title>
    <link href="https://Maxwell-lyu.github.io/2019/09/02/Learn-DB-20190902-DB-ALL/"/>
    <id>https://Maxwell-lyu.github.io/2019/09/02/Learn-DB-20190902-DB-ALL/</id>
    <published>2019-09-02T02:15:09.000Z</published>
    <updated>2019-09-02T02:16:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章:"></a>第一章:</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章:&quot;&gt;&lt;/a&gt;第一章:&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="Course" scheme="https://Maxwell-lyu.github.io/tags/Course/"/>
    
      <category term="Introduction to Database" scheme="https://Maxwell-lyu.github.io/tags/Introduction-to-Database/"/>
    
  </entry>
  
  <entry>
    <title>DB-KEY</title>
    <link href="https://Maxwell-lyu.github.io/2019/09/02/Learn-DB-20190902-DB-KEY/"/>
    <id>https://Maxwell-lyu.github.io/2019/09/02/Learn-DB-20190902-DB-KEY/</id>
    <published>2019-09-02T01:29:02.000Z</published>
    <updated>2019-09-02T01:46:28.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>数据库系统概述<ul><li>概念<ul><li>数据: 现实客体的抽象表示,计算机内的符号串 <ul><li>特性: 多样性, 可构造性, 挥发/持久性, 私有/共享性, 海量性</li><li>变化: 量变大, 非结构化到结构化, 私有到共享, 挥发到持久</li></ul></li><li></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;数据库系统概述&lt;ul&gt;
&lt;li&gt;概念&lt;ul&gt;
&lt;li&gt;数据: 现实客体的抽象表示,计算机内的符号串 &lt;ul&gt;
&lt;li&gt;特性: 多样性, 可构造性, 挥发/持久性, 私有/共享性, 海量性&lt;/li&gt;
&lt;li&gt;变化: 量变大, 非结构化到结构化, 私有到共享, 挥发
      
    
    </summary>
    
    
      <category term="Course" scheme="https://Maxwell-lyu.github.io/tags/Course/"/>
    
      <category term="Introduction to Database" scheme="https://Maxwell-lyu.github.io/tags/Introduction-to-Database/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript</title>
    <link href="https://Maxwell-lyu.github.io/2019/08/05/Tech-JS-20190805-JS/"/>
    <id>https://Maxwell-lyu.github.io/2019/08/05/Tech-JS-20190805-JS/</id>
    <published>2019-08-05T14:36:20.000Z</published>
    <updated>2019-10-13T12:48:29.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Where-to-Insert-JavaScript"><a href="#Where-to-Insert-JavaScript" class="headerlink" title="Where to Insert JavaScript"></a>Where to Insert JavaScript</h1><ol><li><p>Header or Body, use <code>&lt;script&gt; ... &lt;/script&gt;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  function myFunction() &#123;&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>External File or URL, use <code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/myScript.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://www.dummy.com/js/myScript.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="JavaScript-Output"><a href="#JavaScript-Output" class="headerlink" title="JavaScript Output"></a>JavaScript Output</h1><ol><li>to Document: <code>document.write(&quot;...&quot;)</code></li><li>to Element: <code>document.getElementById(&quot;elementName&quot;).innerHTML = ...</code></li><li>to Alert Window: <code>window.alert(...);</code> <code>alert(...)</code></li><li>to Console: <code>console.log(...)</code></li></ol><h1 id="JavaScript-Syntax"><a href="#JavaScript-Syntax" class="headerlink" title="JavaScript Syntax"></a>JavaScript Syntax</h1><p>I know C, so nothing new</p><h1 id="JavaScript-Statements"><a href="#JavaScript-Statements" class="headerlink" title="JavaScript Statements"></a>JavaScript Statements</h1><ol><li>“;” is not required, but recommended</li><li>line break after operator?????</li><li>use <code>function</code> as code blocks</li><li>keywords: <ol><li><code>break</code>, <code>continue</code>, <code>do ... while</code>, <code>for</code>, <code>if ... else</code>, <code>return</code>, <code>switch</code> similar to C</li><li><code>try ... catch</code> similar to java</li><li><code>debugger</code>: Stops the execution of JavaScript, and calls (if available) the debugging function</li><li><code>function</code>, <code>var</code> explained above</li></ol></li></ol><h1 id="JavaScript-Comments"><a href="#JavaScript-Comments" class="headerlink" title="JavaScript Comments"></a>JavaScript Comments</h1><p>Nothing new here</p><h1 id="JavaScript-Variables"><a href="#JavaScript-Variables" class="headerlink" title="JavaScript Variables"></a>JavaScript Variables</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Where-to-Insert-JavaScript&quot;&gt;&lt;a href=&quot;#Where-to-Insert-JavaScript&quot; class=&quot;headerlink&quot; title=&quot;Where to Insert JavaScript&quot;&gt;&lt;/a&gt;Where to
      
    
    </summary>
    
      <category term="Technique" scheme="https://Maxwell-lyu.github.io/categories/Technique/"/>
    
    
      <category term="JavaScript" scheme="https://Maxwell-lyu.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>DB-PRE</title>
    <link href="https://Maxwell-lyu.github.io/2019/07/11/Learn-DB-20190711-DB-PRE/"/>
    <id>https://Maxwell-lyu.github.io/2019/07/11/Learn-DB-20190711-DB-PRE/</id>
    <published>2019-07-11T11:44:05.000Z</published>
    <updated>2019-10-10T07:03:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-数据库系统概述"><a href="#第一章-数据库系统概述" class="headerlink" title="第一章: 数据库系统概述"></a>第一章: 数据库系统概述</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><strong>信息</strong>: 用于反映现实世界中事物的<strong>物理状态</strong>, 向人们提供一些已知的、客观存在的事实和知识</li><li><strong>数据</strong>: 是指具有一定的语义含义, 并且可以被记录下来的<strong>已知事实</strong>. 在计算机中, 数据被表示为具有一定格式（或结构）的<strong>符号串</strong>, 它是计算机软件中程序加工的原料与结果, 属于软件范畴</li><li>数据是信息的载体, 信息则是数据的内涵</li><li><p><strong>数据的特性</strong>  </p><ol><li>表现的多样性</li><li>可构造性: 型(数据类型, 数据结构, 数据模式), 值</li><li>挥发性/持久性</li><li>私有性/共享性</li><li>‘量’的表示: 少量/大量/海量</li></ol></li><li><p><strong>数据特性的变化</strong>  </p><ol><li>量: 少量-&gt;大量-&gt;海量</li><li>结构: 简单-&gt;复杂</li><li>服务范围: 私有-&gt;共享</li><li>在软件中的地位: 附属地位(程序是主体)-&gt;主导地位(数据为中心, 应用程序共享数据)</li></ol></li><li><p><strong>数据库应用系统</strong>DBAS: 利用数据库系统作应用开发所构成的集成化的独立运行系统</p><ul><li><strong>数据库系统</strong>DBS: 是一个以对海量的、具有复杂数据结构的、可以持久保存的、可供多 户共享的数据进行统一管理为目标的计算机系统<ul><li><strong>数据库</strong>DB: 是数据集合, 具有统一的结构形式并存放于统一的存储介质内, 它由多种应用数据集成, 并可被应用所共享</li><li><strong>数据库管理系统</strong>DBMS: <ul><li>是管理数据库的系统软件</li><li>特点: 管理持久性数据, 大量数据, 数据共享</li><li>作用: 数据库应用程序与数据库的接口, 安全可靠+简明方便</li><li>功能: 组织, 操纵, 维护, 控制及保护, 交换, 服务, 字典</li><li>数据子语言: (SQL语言的组成部分<ul><li>数据定义语言: DDL</li><li>数据操纵语言: DML</li><li>数据控制语言: DCL</li></ul></li><li>数据子语言的使用方式: 交互式命令(终端直接操作), 宿主型(嵌入到宿主语言中)</li></ul></li><li><strong>数据库管理员</strong>DBA: 对数据库进行规划、设计、维护、监视的专职人员</li><li><strong>软件平台</strong>: 操作系统, 语言, 数据库应用开发工具, 通用的数据库访问接口</li><li><strong>硬件平台</strong></li></ul></li><li><strong>应用软件</strong>, <strong>应用界面</strong></li><li><strong>数据库用户</strong><ul><li><strong>最终用户</strong>: 终端查询用户, 应用程序的使用者</li><li><strong>应用程序开发人员</strong></li><li><strong>数据库管理员</strong></li></ul></li></ul></li><li><p>数据库应用系统层次结构(9)</p><blockquote><p>硬件平台-&gt;操作系统-&gt;数据-&gt;数据库管理系统-&gt;数据交换与中间件-&gt;开发工具-&gt;应用软件-&gt;应用界面-&gt;用户</p></blockquote></li></ul><h2 id="数据库系统的发展及趋势"><a href="#数据库系统的发展及趋势" class="headerlink" title="数据库系统的发展及趋势"></a>数据库系统的发展及趋势</h2><ul><li>数据管理技术的发展历史<blockquote><p>人工管理-&gt;文件系统管理-&gt;数据库系统管理</p></blockquote></li><li>数据库管理系统的发展阶段<ul><li>层次/网状数据库: 20世纪60年代~70年代<ul><li>从无到有, 简单的共享数据读写</li></ul></li><li>关系数据库: 20世纪70年代~<ul><li>从有到大规模商业化应用</li><li>面向事务处理型引用OLTP</li></ul></li><li>数据仓库: 20世纪90年代~<ul><li>面向数据分析型婴童OLAP</li></ul></li><li>新型数据库管理系统: 21世纪<ul><li>NoSQL数据库/大数据管理系统</li></ul></li></ul></li><li>数据库系统的发展历史<ul><li><strong>文件系统阶段</strong>: 仅是数据库系统的雏形<ul><li>优点: 利用文件系统来参与数据管理, 向用户提供简单的数据管理和共享能力</li><li>缺点: 数据管理功能不完整不统一, 数据共享能力弱, 不利于数据库系统的移植</li></ul></li><li><strong>层次数据库与网状数据库</strong>: 是真正的数据库系统<ul><li>优点: 统一的数据管理工具, 数据共享能力</li><li>缺点: 受文件物理影响大, 数据构造繁琐</li></ul></li><li><strong>关系数据库</strong>: 80年代潮流<ul><li>优点: 结构简单、使用方便、逻辑性强、物理性少</li><li>缺点: 模型的描述能力不足, 数据操纵功能有待扩展</li><li>扩充: <strong>专用数据库系统</strong>: 专用性有余而通用性不足</li></ul></li><li><strong>通用数据库系统</strong>: 90年代重点<ul><li>面向对象数据库系统</li><li>知识库系统</li><li>关系数据库系统扩充</li></ul></li><li><strong>新一代数据库系统</strong>: 关系数据库系统的进一步扩充与改造<ul><li>对象关系数据库系统, 数据仓库(Data Warehouse), Web数据库, 安全数据库, (嵌入式数据库, 移动数据库, 实时数据库网格数据库, 传感器网络数据库</li></ul></li></ul></li></ul><h2 id="数据库系统的基本特点"><a href="#数据库系统的基本特点" class="headerlink" title="数据库系统的基本特点"></a>数据库系统的基本特点</h2><ul><li><strong>集成性</strong>: 集多种应用数据于一体<ul><li>统一的数据结构</li><li>全局统一的数据模式</li><li>根据应用需要构造局部模式</li></ul></li><li><strong>高共享性</strong>与<strong>低冗余性</strong><ul><li>数据共享<ul><li>多个应用程序使用, 可用于不同的目的</li><li>已有的数据库系统上开发新的应用程序</li><li>向外界提供信息服务功能</li></ul></li><li>数据冗余<ul><li>同一个数据在不同的地方重复存储</li></ul></li><li>减少不必要的存储空间, 避免数据的不一致性</li></ul></li><li><strong>独立性</strong><ul><li>数据或数据结构的改变不会导致对使用这些数据的应用程序的修改, 反之亦然</li><li>物理独立性: 物理结构（包括存储结构、存取方式等）的改变, 不影响数据库的逻辑结构, 不致引起应用程序的变化</li><li>逻辑独立性: 数据库总体逻辑结构的改变, 如修改数据模式、增加新的数据类型、改变数据间联系等, 不需要相应修改应用程序</li></ul></li><li><strong>数据的统一管理与控制</strong><ul><li>数据的完整性检查</li><li>数据的安全性保护</li><li>并发控制</li><li>数据库故障恢复</li></ul></li></ul><h2 id="数据库内部结构体系"><a href="#数据库内部结构体系" class="headerlink" title="数据库内部结构体系"></a>数据库内部结构体系</h2><ul><li><strong>数据库系统的三级模式</strong><ul><li><strong>概念模式</strong>简称<strong>模式</strong>-&gt;概念数据库<ul><li>整个数据库中数据的全局逻辑结构的描述</li><li>基于数据模型, 利用数据定义语言DDL描述</li><li>数据类型, 长度, 特征, 数据间联系, 安全性完整性的要求</li></ul></li><li><strong>外模式</strong>(<strong>子模式</strong>, <strong>用户模式</strong>)-&gt;用户数据库<ul><li>是关于某个用户所需数据的逻辑结构的描述</li><li>是概念模式的子集, 同一概念模式可有多个外模式, 针对用户</li><li>简化用户接口易用, 降低冗余, 利于安全保密</li></ul></li><li><strong>内模式</strong>(<strong>物理模式</strong>)-&gt;物理数据库<ul><li>是关于数据库中数据的物理存储结构和物理存取方法的描述</li></ul></li><li>物理数据库: 真实存在; 其他两种数据库由物理数据库通过数据库管理系统构造</li></ul></li><li><strong>数据库系统的两级映射</strong>: DBMS提供<ul><li><strong>概念模式到内模式</strong>: 物理独立性: 全局逻辑结构到数据的物理存储结构间的对应关系</li><li><strong>外模式到概念模式</strong>: 逻辑独立性: 一个概念模式中可以定义多个外模式, 而每个外模式是概念模式的一个基本视图</li><li>两级映射建立三级模式间的联系与转换, 保证了数据库系统中数据独立性的实现</li></ul></li></ul><h1 id="第二章-数据模型"><a href="#第二章-数据模型" class="headerlink" title="第二章: 数据模型"></a>第二章: 数据模型</h1><h2 id="数据模型的基本概念"><a href="#数据模型的基本概念" class="headerlink" title="数据模型的基本概念"></a>数据模型的基本概念</h2><ul><li><strong>数据</strong>: 现实世界中客体符号化抽象</li><li><strong>数据模型</strong>: 数据基本特征的抽象, 描述<strong>数据的结构</strong>, 定义在该数据结构上<strong>可以执行的操作</strong>以及数据之间必须满足的<strong>约束条件</strong><blockquote><p>数据模型应该能比较真实地模拟现实世界, 易于人理解, 便于在计算机上实现</p><ul><li><strong>数据结构</strong>: 数据的类型, 内容, 性质, 数据间联系</li><li><strong>数据操作</strong>: 操作类型, 操作方式</li><li><strong>数据约束</strong>: 数据结构内数据间的相互关系: 语法语义联系, 制约与依存, 动态变化规则</li></ul></blockquote></li><li>数据模型的<strong>类型</strong><blockquote><p>数据模型的核心是数据结构, 现实中数据及其关系到数据库, 有逐步转化的过程, 以数据模型表示其转化结果<br> 概念数据模型<ruby>–&gt;<rt>转化</rt></ruby>逻辑数据模型<ruby>–&gt;<rt>DBMS</rt></ruby>物理数据模型(可实现)</p><ul><li><strong>概念数据模型</strong>: 面向客观世界, 面向用户, 无关于数据库管理系统和计算机平台<br>种类: E-R模型, EE-R模型; 面向对象模型; 谓词模型<br>描述客观对象的数据特征及相互关系</li><li><strong>逻辑数据模型</strong>: 面向数据库系统, 着重于DBMS实现, 承上启下<br>种类: 层次, 网状模型; 关系, 面向对象, 谓词模型; 对象关系模型<br>描述事物及关系在选定的DBMS中的实现结构, 即据DBMS定义事物及关系的实现结构</li><li><strong>物理数据模型</strong>: 面向计算机物理表示, 给出数据模型在计算机上的物理表示<br>也性用户提供与物理存储结构与存取方法相关的定义: 索引, 集簇, 存储区域的选择<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">客观世界                 用户1    ...   用户n</span><br><span class="line">  |                        |              |</span><br><span class="line">  |                        |              |</span><br><span class="line">  |                        |              |</span><br><span class="line">概念模型   +-----------&gt;外模式1   ...  外模式n</span><br><span class="line">  |       /                |              |</span><br><span class="line">  |      /                 |              |</span><br><span class="line">  |     /                  |              |</span><br><span class="line">逻辑模型---------------&gt;概念模式---------+</span><br><span class="line">  |                        |</span><br><span class="line">  |                        |</span><br><span class="line">  |                        |</span><br><span class="line">物理模型---------------&gt;内模式</span><br></pre></td></tr></table></figure></li></ul></blockquote></li></ul><h2 id="数据模型的四个世界"><a href="#数据模型的四个世界" class="headerlink" title="数据模型的四个世界"></a>数据模型的四个世界</h2><ul><li><strong>现实世界</strong>: 客观世界中, 据用户需求目标, 划定边界的应用环境<blockquote><p>用户需求: 数据需求, 处理要求<br>提供转换过程的: 客观基础, 启动环境</p></blockquote></li><li><strong>概念世界</strong>: 基于现实世界, 进一步的抽象而形成<blockquote><p>基本术语: (实体, 属性, 联系)E-R模型, (对象, 类, 方法, 继承)OO模型<br>无关于具体的DBMS和计算机</p></blockquote></li><li><strong>信息世界</strong>: 基于概念世界, 用特定的DBMS构造而成的逻辑数据模型<blockquote><p>用特定的DBMS所提供的工具来定义逻辑数据模型, 侧重于概念数据模型的细化和在数据库系统一级的实现<br>有关于具体的DBMS</p></blockquote></li><li><strong>计算机世界</strong>: 基于逻辑数据模型在计算机中的物理实现, 形成物理数据模型<blockquote><p>侧重于数据库物理存储结构的描述: 存储结构设计, 存取路径设计, 存储空间分配<br>DB的最终实现结构</p></blockquote></li></ul><h2 id="概念世界与概念模型"><a href="#概念世界与概念模型" class="headerlink" title="概念世界与概念模型"></a>概念世界与概念模型</h2><ul><li><strong>概念世界</strong>:  概念世界是一个较为抽象, 概念化的世界; 给出数据的概念化结构; 概念世界一般用概念模型表示</li><li>概念模型种类: 实体-联系(E-R), 扩充的实体-联系(EE-R), 面向对象, 谓词模型</li></ul><h3 id="E-R模型"><a href="#E-R模型" class="headerlink" title="E-R模型"></a>E-R模型</h3><ul><li>概念化模型: 现实世界的要求 转化成 实体, 联系, 属性 及 两种基本关系; 用E-R图表示</li><li><strong>实体</strong><ul><li>客观存在且又能相互区别的事物<blockquote><p>客观事物的抽象, 概念世界中的基本单位</p></blockquote></li><li><strong>实体集</strong>: 具有共性的实体所构成的集合</li></ul></li><li><strong>属性</strong><ul><li>实体所具有的某种特性或特征<blockquote><p>属性有值, 取值集合为<strong>值域</strong></p></blockquote></li><li>一个实体可有多个属性<blockquote><p>共性实体有相同的属性组成<br>不同实体在其属性取值上有区别</p></blockquote></li></ul></li><li><strong>联系</strong><ul><li>一个实体集中的实体与另一个实体集中的实体之间的对应关系</li><li>种类(与联系相关的实体集数): 二元联系, 多元联系, 内部联系</li><li>例子<ul><li>二元(隶属, 学习, 借阅)</li><li>多元(供应: 工厂, 产品, 用户)</li><li>内部(围棋比赛: 黑方, 白方)</li></ul></li><li>相同实体集之间的多种联系<ul><li>在同一组实体集之间可以存在多种联系</li></ul></li><li>联系的函数对应关系<ul><li>一一对应（one to one）</li><li>一多对应（one to many, 多一对应（many to one）</li><li>多多对应（many to many）</li></ul></li><li>联系所具有的特性<ul><li>因联系的发生而产生的特性可以通过<strong>联系上的属性</strong>来表示</li></ul></li></ul></li><li>基本概念之间的<strong>连接关系</strong><ol><li>实体集（联系）与属性间的连接关系</li><li>实体集与联系间的连接关系</li></ol><ul><li>实体(集), 属性及其连接关系的描述<ul><li>属性的描述: 属性名, 属性域</li><li>实体的描述: <ul><li>实体名</li><li>实体型: 实体名+一组属性名<blockquote><p>描述实体的组成结构信息</p></blockquote></li><li>实体值 <blockquote><p>所有属性值的集合称为实体值, 又称元组</p></blockquote></li></ul></li><li>实体集的描述<ul><li>属性集合+关键字<blockquote><p>关键字: 是可用于区分同一个实体集中不同实体的 ‘最小属性集合’</p></blockquote></li></ul></li></ul></li><li>联系及其与实体集之间的连接关系的描述<ul><li>联系名</li><li>属性: 联系拥有属性<blockquote><p>由一个‘联系名’ + 与该联系相关的‘实体集的名称’, 以及联系上的属性, 从而构成联系及其与实体集之间的连接关系的描述  </p></blockquote></li><li>函数对应关系</li></ul></li><li>E-R图<ul><li>基本概念表示: 图形内写名称<ul><li>实体集: 矩形框</li><li>属性: 椭圆</li><li>关键字: 椭圆, 属性名加下划线</li><li>联系: 菱形框</li></ul></li><li>联系表示: 无向线段<blockquote><p>每个属性只能隶属于一个实体集, 哪怕同名<br>实体集与联系的连线旁边, 用数字标明涉及的实体数量</p></blockquote></li></ul></li><li>设计E-R模型<ul><li>实体 or 属性<blockquote><p>考虑取值, 若某一性质仅有一个重要的信息, 则作为属性, 如仅使用身份证号码的身份证; 若有多个重要信息, 则作为实体, 这些信息作为属性, 如身份证与其号码, 有效期, 签发机关等</p></blockquote></li><li>实体 or 联系<blockquote><p>与多个对象有关, 往往是联系; 一些事件有相关的物品, 例如交易与其合同, 交易可作为关系, 也可用合同表示为实体</p></blockquote></li><li>二元 or 多元<blockquote><p>只需考虑两两关系且无歧义时, 多元可转化为多个二元  </p></blockquote></li><li>属性依附对象<blockquote><p>实体的属性: 内在特征, 与联系无关; 联系的属性: 联系消失则消失的属性</p></blockquote></li></ul></li></ul></li></ul><h3 id="EE-R模型"><a href="#EE-R模型" class="headerlink" title="EE-R模型"></a>EE-R模型</h3><ul><li>扩充的内容<ul><li>IS_A联系 (Generalization Hierarchies): 继承, 即超(实体)集与子(实体)集关系<blockquote><p>用子集到超集的有向箭头表示, 书中箭头带圈</p><ul><li>继承性: 子集继承超集中的所有属性, 亦可有自己专有的属性; 超集关键字也是子集关键字</li><li>传递性</li><li>优点: 更好地映射到面向对象方法; 统一共性, 又能体现差异, 更好地模拟现实世界</li><li>覆盖约束: 所有子集的并集等价于超集, 一个实体至少属于一个子集</li><li>不相交约束: 子集互不相交, 一个实体至多属于一个子集</li></ul></blockquote></li><li>弱实体(Weak Entity): 某个实体依附于其他实体的存在<blockquote><p>用从弱实体集到联系的有向箭头表示</p></blockquote></li><li>属性的划分<ul><li>Identifier（标识符）: 又称关键字</li><li>Descriptor（描述符）</li><li>a composite attribute（组合属性）: 一组简单属性, 组合为一个组合属性, 描述一个性质, 例如姓名=名+姓</li><li>a multi-valued attribute（多值属性）: 一个实体在一个属性有多个值</li></ul></li><li>属性基数 (Cardinality of Attributes): 二元组表示属性取值数量特征<blockquote><p>标注在属性到实体集的连线上 </p><ul><li>(0,?): 可取空值, 不加限制</li><li>(1,?): 不可空值</li><li>(?,1): 单值属性</li><li>(?,N): 可取空值, 至多N值</li></ul></blockquote></li><li>实体在一个联系中的参与基数(Cardinality of Entity Participation in a Relationship)<blockquote><p>标注在联系到实体集的连线上</p><ul><li>card(E,R) = (min-card(E,R), max-card(E,R)), 实体集E中一个实体, 通过联系R连接到实体集F中, 所能连接的实体数量范围<ul><li>单值参与: max = 1; 否则多值参与</li><li>可选参与: min = 0; 否则强制参与</li></ul></li><li>用“参与方式”代替函数对应关系,  描述实体在联系中的数量对应关系</li><li>[解题技巧] 观察每个实体连了几根线, 这个数值的范围就是参与基数</li></ul></blockquote></li></ul></li><li>| Classification | Description |<br>| :-: | - |<br>| Entity | A collection of distinguishable real-world objects with common properties. |<br>| Attribute | A data item that describes a property of an entity or a relationship. |<br>| Identifier | (set of attributes) | Uniquely identifies an entity instance or relationship occurrence. |<br>| Descriptor | Non-key attribute, describing an entity or relationship. |<br>| Composite attribute | A group of simple attributes that together describe a property of an object. |<br>| Multi-valued attribute | An entity attribute that takes on multiple values for a single entity instance. |<br>| Relationship | Named set of m-tuples, identifies subset of the Cartesian product E1×E2×…×Em |<br>| Binary relationship | A relationship on two distinct entities |<br>| Ring, recursive relationship | A relationship relating an entity to itself |<br>| N-ary (N&gt;2) relationship | A relationship on more than two entities |</li></ul><h3 id="面向对象模型"><a href="#面向对象模型" class="headerlink" title="面向对象模型"></a>面向对象模型</h3><ul><li>概念<ul><li>面向对象技术引入到数据库领域, 借鉴面向对象的设计方法而发展起来的一种新的数据模型</li><li>采用了面向对象方法中的基本概念和方法来构造数据库的数据模型</li><li>提升了模型的表达能力, 特别是在表示非传统的、复杂数据关系方面具有极强的表达力</li></ul></li><li>对象<ul><li>客观世界中能够相互区别开来的事物(同E-R模型中实体定义)</li><li>区别<br>| | 对象 | 实体 |<br>| - | - | - |<br>| 描述特征 | 属性组成+行为特征 | 属性取值 |<br>| 区分实体 | 对象标识符 | 属性取值 |</li><li>组成<ul><li>标识符: OID: 每对象仅有一个, 用以相互区别</li><li>静态特征: 属性, 反应状态与特性</li><li>动态特性: 方法, 施加在对象上的程序, 可审视或改变属性值</li></ul></li><li>特点<ul><li>封装<ul><li>[属性+方法]合为整体</li><li>封装产生划分:<ul><li>内部表示: 属性的组成, 方法的实现</li><li>外部表示: 方法的调用接口, 亦称对象界面</li></ul></li><li>优点: 利于保护, 力与维护, 提高可靠性和重用性</li></ul></li><li>标识符的独立性<ul><li>独立于属性, 由系统定义并赋值, 唯一标识一个对象</li><li>特性: 唯一性, 持久性, 不可重用性</li></ul></li><li>属性值的多值性<ul><li>可以是: 单值, 值的集合, 另一个对象</li></ul></li></ul></li></ul></li><li>类(class)<ul><li>具有相同属性, 方法的对象集合</li><li>定义类, 以描述其中对象的静态特性和动态特性</li><li>实例: 类抽象为”类对象”, 而类的对象称为”实例”</li><li>元类: 由所有类对象构成的对象集合</li><li>类间关系<ul><li>继承: IS-A<ul><li>单向不循环的层次结构, 共享实现和定义</li><li>普化: 子类到超类, 对象集合合并</li><li>特化: 超类到子类, 对象集合分解</li><li>单继承: 每个子类只有唯一的直接超类</li><li>多继承: 每个子类可有多个直接超类</li><li>继承的作用: 支持共享与重用, 有助于扩充</li><li>问题<ul><li>重载: 解决在继承过程中, 超类与子类（或超类与超类）之间的冲突</li><li>冲突: 方法或属性的名字相同但语义或实现不同</li></ul></li></ul></li><li>聚合与分解: IS-PART-OF<ul><li>聚合: 若干个简单类聚合成一个复杂的类的过程</li><li>分解: 复杂类分解成若干层次上的简单类的过程</li><li>语义: 组成语义, 嵌套语义, 联系语义 </li></ul></li><li>两种联系来构成类的层次结构, 描述复杂的数据关系, 以它们为主要手段来构造面向对象的数据模型</li></ul></li></ul></li><li>消息<ul><li>对象协作机制</li><li>发送消息以调用其他对象中的方法</li><li>仅作用于对象界面</li><li>用户操作也可看成消息<ul><li>消息组成: (type) A.Op(O1, O2, …, On) (形同函数调用)</li><li>消息与方法: 方法是内部操作(接口+实现), 消息是跨对象的操作</li></ul></li></ul></li><li>C++与OODB<br>| C++ | OODB |<br>| - | - |<br>| - | 有OID |<br>| 管理对象 | 管理类 |<br>| 关心继承 | 关心继承和合成 |<br>| 挥发性 | 持久性 |<br>| - | 重视安全, 完整, 并发和故障恢复 |</li></ul><h3 id="谓词模型"><a href="#谓词模型" class="headerlink" title="谓词模型"></a>谓词模型</h3><ul><li>概念<ul><li>谓词模型又称谓词逻辑模型, 使用一阶谓词演算公式表示数据模型</li><li>用于构建: 概念数据模型 和 逻辑数据模型</li></ul></li><li>实体集<ul><li>谓词: 标识符号+若干变元, 变元取值, 判断是否成立</li><li>n个属性的实体集, 用含n个变元的谓词表示该实体集</li><li>在此实体集中的元组, 使此谓词为真, 不在则为假</li></ul></li><li>属性<ul><li>用变元取值表示属性</li><li>属性的域也可用谓词表示</li><li>对变元的约束可用统一的约束谓词表示</li><li>n属性的实体集有此表示: $P(x_1,x_2,\cdots,x_n)\wedge C(x_1)\wedge C(x_2)\wedge\cdots\wedge C(x_n)$</li></ul></li><li>联系<ul><li>谓词来表示联系, 谓词中的变元由参与该联系的实体（通常用实体的关键字属性代替）以及联系本身所具有的属性组成</li></ul></li><li>操作<ul><li>$x_i$为操作对象, $X$为结果: $Op(x_1,x_2,\cdots,x_n, X)$</li></ul></li><li>完整性约束<ul><li>谓词或谓词公式来表示属性间的完整性约束条件</li></ul></li></ul><h2 id="信息世界与逻辑模型"><a href="#信息世界与逻辑模型" class="headerlink" title="信息世界与逻辑模型"></a>信息世界与逻辑模型</h2><ul><li>信息世界是数据库的世界, 它着重于数据模型在数据库系统一级的构造与操作<ul><li>信息世界用逻辑数据模型来进行描述</li></ul></li></ul><h3 id="逻辑模型的分类"><a href="#逻辑模型的分类" class="headerlink" title="逻辑模型的分类"></a>逻辑模型的分类</h3><ul><li>层次模型和网状模型</li><li>关系模型和对象关系模型</li><li>面向对象模型</li><li>谓词模型</li></ul><h3 id="简史"><a href="#简史" class="headerlink" title="简史"></a>简史</h3><ul><li>The ’60s: 数据库技术的萌芽阶段</li><li>1961: IDS (Integrated Data Store)网络数据模型</li><li>1965-1970: IMS (Information Management System)层次数据模型, 多用户</li><li>1970: 关系数据模型 </li><li>1975: 著名的国际会议<ul><li>SIGMOD: ACM Special Interest Group on Management Of Data</li><li>VLDB: Very Large Data Bases</li><li>ICDE: IEEE International Conference on Data Engineering</li></ul></li><li>1976: Entity-Relationship (ER) model</li><li>The ’80s: 商用关系数据库管理系统的兴起</li><li>The ’90s<ul><li>专用数据库系统</li><li>商用面向对象数据库管理系统</li><li>对象关系数据库管理系统</li></ul></li><li>新世纪以来<ul><li>数据仓库, 安全数据库, XML数据库, 嵌入式、移动、实时、内存, NoSQL ……</li></ul></li><li>早期有影响的研究工作<ul><li>System R (IBM)</li><li>INGRES (University of California, Berkeley)</li><li>System 2000 (University of Texas, Austin)</li><li>Socrate Project (University of Grenoble, France)</li><li>ADABAS (Technical University of Darmstadt, W. Germany)</li></ul></li><li>数据库语言<ul><li>SQUARE, SEQUEL (SQL), QBE, QUEL</li></ul></li><li>其它方向: <ul><li>Expert Database Systems</li><li>Object-oriented DBMSs</li></ul></li><li>概念模型与逻辑模型对应关系表<br>| 概念模型 | E-R模型 | EE-R模型 | 面型对象模型 | 谓词模型 |<br>| - | - | - | - | - |<br>| 逻辑模型 | 层次模型, 网状模型, 关系模型 | 对象关系模型 | 面型对象模型 | 谓词模型 |</li></ul><h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><ul><li>概念: 关系模型是一种新的逻辑模型</li><li>基本数据结构: 二维表(简称表)</li><li>数据操纵: 表查询, 表的删除插入修改</li><li>二维表<ul><li>二维表由表框架与元组所组成, 表框架由若干个属性组成</li><li>存放于框架内的每‘一行数据’都被称为 ‘一个元组’ (Tuple), 或称‘行’(Row)</li><li>一张二维表是由一个有n个属性的框架及m个元组组成</li></ul></li><li>关系<ul><li>由行和列组成的二维表格</li><li>关系的约束<ul><li>同一表中的属性名各不相同</li><li>表中的属性与属性的排放次序无关</li><li>表中的元组均不相同</li><li>表中的元组与元组的排列次序无关</li><li>表中的每一分量必须是一个不可分割的基本数据项</li></ul></li><li>概念<ul><li>关系模式: 一个关系的关系名及其属性名的集合构成该关系的关系模式</li><li>关系数据库模式: 该关系数据库中所有关系的关系模式的集合</li><li>元组: 关系中的每一行</li><li>关键字<ul><li>一个属性集的值能唯一标识关系中的一个元组, 且又不含多余的属性值</li><li>每一个关系都有关键字</li><li>一个关系也可以有多个关键字, 所以关键字也被称为‘候选关键字’</li><li>主关键字: 关系的候选关键字中选取一个</li><li>外关键字: 设关系R中的属性集F, 其取值来自于关系S中的主关键字K, 则称属性集F是关系R的外关键字(取值来自外部关键字 的 属性集)</li></ul></li></ul></li><li>关系模型上的数据操作<ul><li>关系模型数据操作的对象是‘关系’；</li><li>关系模型数据操作的结果也是一个‘关系’；</li><li>关系模型的五种基本操作: 属性指定, 元组选择, 关系的合并, 元组插入, 元组删除</li></ul></li></ul></li></ul><h2 id="计算机世界与物理模型"><a href="#计算机世界与物理模型" class="headerlink" title="计算机世界与物理模型"></a>计算机世界与物理模型</h2><ul><li>物理模型是面向计算机的模型, 它构作数据库系统的物理实现: 操作系统级文件组织, 硬件级数据组织</li></ul><h3 id="文件系统的组成"><a href="#文件系统的组成" class="headerlink" title="文件系统的组成"></a>文件系统的组成</h3><ul><li>文件系统的组成<ul><li>项 (Item) : 文件系统中最小基本单位, 项内符号是不能继续分割的</li><li>记录 (Record): 由若干项组成, 记录内的各项间有内在语义联系<ul><li>记录有型与值的区别</li></ul></li><li>文件 (file): 记录的集合<ul><li>一般讲, 一个文件所包含的记录都是同型的</li></ul></li><li>文件集 (file set): 由若干个文件构成</li></ul></li><li>提高文件读写操作效率的方法<ul><li>索引(Index)<ul><li>将文件中的记录与其物理地址(即磁盘块)间建立一张对应关系表以便于快速查找, 这就是索引</li><li>索引一般也是一个文件. 当数据文件中的记录数很大时, 索引文件本身也还需要建立索引, 这叫二级索引</li><li>依此类推, 可以建立多级索引</li><li>B+树是关系数据库的物理实现中最常用的一种多级索引技术</li></ul></li><li>hash法<ul><li>一种函数转换法, 其主要思想是: 通过一个hash函数将要查找的记录转换成该记录所在的物理地址, 然后可以直接进行记录的定位读取操作</li></ul></li><li>集簇(Cluster)<ul><li>在记录查找中往往需要按某项的项值查找, 将具有相同或相邻项值的记录聚集在相同磁盘块内或圆柱体内以减少读盘次数, 提高查找速度, 这被称为集簇</li></ul></li></ul></li></ul><h1 id="第三章-关系数据库系统"><a href="#第三章-关系数据库系统" class="headerlink" title="第三章: 关系数据库系统"></a>第三章: 关系数据库系统</h1><h2 id="关系数据库系统概述"><a href="#关系数据库系统概述" class="headerlink" title="关系数据库系统概述"></a>关系数据库系统概述</h2><h3 id="关系数据库系统的优点"><a href="#关系数据库系统的优点" class="headerlink" title="关系数据库系统的优点"></a>关系数据库系统的优点</h3><ol><li>数据结构简单<ul><li>二维表: 记录-字段</li></ul></li><li>使用方便<ul><li>不涉及物理结构, 非过程性数据子语言</li></ul></li><li>功能强<ul><li>表达能力强, 便于修改数据间联系, 灵活选取数据存取路径, 高级的数据操纵语言</li></ul></li><li>数据独立性高<ul><li>不涉及物理因素, 操作非过程性</li></ul></li><li>理论基础深<ul><li>关系代数+关系演算理论-&gt;系统实现</li></ul></li><li>可移植性好</li><li>标准化程度高<ul><li>数据子语言的标准化: SQL语言标准</li></ul></li><li>分布式功能<ul><li>Client/Server(C/S); Browser/Server(B/S); 分布式数据库</li></ul></li><li>开放性<ul><li>数据访问接口实现与其它系统的互连: OBDC, JDBC</li></ul></li><li>其它方面的功能扩展</li></ol><h2 id="关系数据库系统衡量准则"><a href="#关系数据库系统衡量准则" class="headerlink" title="关系数据库系统衡量准则"></a>关系数据库系统衡量准则</h2><h3 id="六条准则1974"><a href="#六条准则1974" class="headerlink" title="六条准则1974"></a>六条准则1974</h3><p>提供高度的数据独立性<br>提供严格的数据视图<br>减轻DBA的工作<br>建立理论基础<br>事务管理与文件管理相结合: 为商业及其它行业的服务作准备<br>操作对象是记录集合, 而不是单个记录  </p><h3 id="完全关系型的12条严格标准1985"><a href="#完全关系型的12条严格标准1985" class="headerlink" title="完全关系型的12条严格标准1985"></a>完全关系型的12条严格标准1985</h3><ol><li>信息准则: 逻辑一级<ul><li>所有信息 -&gt; 表中的值, 唯一且显式地表示</li><li>结构描述信息 -&gt; 组织成关系形式</li></ul></li><li>确保访问准则<ul><li>表名+关键字值+列名 -&gt; 访问到每一个原子数据</li></ul></li><li>空值的关系处理准则<ul><li>空值: 无意义/当前未知</li><li>系统应当可以处理有空值参与的: 比较运算, 表达式运算, 统计运算</li></ul></li><li>基于资源管理的动态联机目录<ul><li>数据库的描述信息(数据字典) 与 用户数据 有 相同的表示形式和操作方式</li><li>被授权用户可对 数据库的描述信息 进行 查询与扩充</li></ul></li><li>统一易用的数据子语言: 至少一种子语言支持以下功能<ul><li>数据定义</li><li>视图(view)定义</li><li>数据操纵</li><li>完整性约束能力</li><li>授权机制</li><li>事务处理能力</li></ul></li><li>视图更新准则: 视图除查询外, 还可增加, 删除, 修改数据</li><li>高级的插入、删除及修改操作: 一条命令可以插入、删除及修改操作多条元组</li><li>物理数据独立性</li><li>逻辑数据独立性</li><li>数据完整性准则: 提供三类数据完整性约束的定义功能</li><li>分布独立性: 数据分布的改变不影响原有的应用程序</li><li>无损害原则: 对提供低级数据子语言的要求</li></ol><h3 id="关系数据库产品的类别划分"><a href="#关系数据库产品的类别划分" class="headerlink" title="关系数据库产品的类别划分"></a>关系数据库产品的类别划分</h3><ul><li>半关系型系统<ul><li>基本数据结构: 关系</li><li>满足12条准则中的 少量要求</li></ul></li><li>基本关系型系统<ul><li>基本数据结构: 关系</li><li>满足12条准则中的 大部分要求</li></ul></li><li>完全关系型系统<ul><li>严格符合 上述的12条准则</li></ul></li></ul><h2 id="关系模型数学理论-—-关系代数"><a href="#关系模型数学理论-—-关系代数" class="headerlink" title="关系模型数学理论 — 关系代数"></a>关系模型数学理论 — 关系代数</h2><h3 id="关系模型-1"><a href="#关系模型-1" class="headerlink" title="关系模型"></a>关系模型</h3><h4 id="关系数据结构"><a href="#关系数据结构" class="headerlink" title="关系数据结构"></a>关系数据结构</h4><ul><li>术语对应关系<br>| 关系模型 | DBMS(SQL) | 文件系统 |<br>| - | - | - |<br>| Relation 关系 | Table 表 | File of Records |<br>| Attribute 属性 | Column 列 | Field |<br>| Tuple 元组 | Row 行 | Record |<br>| Schema 模式 | Table Heading 表头 | Type of Record | </li><li>表结构<br>表 = n元表框架 + m个元组<ul><li>表框架<br>属性组成表框架; n个属性 - 表的元数; 属性取值范围 - 值域</li><li>元组<br>行 - 元组; n元表 - 元组n个分量; m行 - 表的基数 - 元组数量</li></ul></li><li>关系<ul><li>被称为关系的二维表必须满足的性质<ul><li>元组: 个数有限, 唯一, 次序无关, 分量原子性, 分量值域同一</li><li>属性: 名称唯一, 次序无关</li></ul></li><li>满足以上关系的二维表, 所建立的模型称为关系模型</li><li>二维表 –(抽象)–&gt; 关系; n个属性 - n元关系</li><li>关系 - 关系名; 属性 - 属性名; 关系名($R$) + n*属性名($A_1, \cdots, A_n$) = 关系框架($R(A_1, \cdots, A_n)$)</li></ul></li><li>键<ul><li>键: 唯一最小标识元组的属性集, 每张表至少一个</li><li>主键: 被选中的键; 候选键: 其他</li><li>超键: 唯一标识元组的属性集(键是极小超键, 其任意子集均不能标识元组)</li><li>外键: 如果表A中的属性集F是表B的键, 则称该属性集F为表A的外键</li></ul></li></ul><h4 id="关系操纵"><a href="#关系操纵" class="headerlink" title="关系操纵"></a>关系操纵</h4><ul><li>查询<ul><li>单张表内<ul><li>目标: 某(行 - 元组)的(属性值 - 元组分量)</li><li>过程: (纵向定位 - 行选择)选符合条件的元组 -&gt; (横向定位 - 列指定)指定属性</li></ul></li><li>多张表<ul><li>先合并-&gt;单张表查询</li></ul></li></ul></li><li>删除<ul><li>基本单位: 元组</li><li>过程<ul><li>确定被删除的元组: 单个关系内的选择操作来确定</li><li>删除操作: 一次操作只能删除一个关系内的元组</li></ul></li></ul></li><li>插入<ul><li>一条操作只能向一个关系中增加新的元组</li></ul></li><li>修改<ul><li>修改不是基本操作, 修改 = 删除(旧元组) + 插入(修改后的新元组)</li></ul></li><li>小结: 关系-(操纵)-&gt;(新)关系</li><li>五种基本操作<ul><li>元组选择: 选择满足条件的元组</li><li>属性指定: 选择结果需要的属性</li><li>关系合并: 多个关系两两合并, 最终合并为一个关系</li><li>元组插入</li><li>元组删除</li></ul></li><li>空值处理<ul><li>数据完整性约束: 主键不允许空值</li><li>空值运算<ul><li>算数表达式中有空值, 则结果为空值</li><li>逻辑表达式中有空值, 则结果为逻辑假</li><li>统计计算:<ul><li>集合中的空值元素不计算在内: SUM, AVG, MAX, MIN, COUNT</li><li>空集: [ SUM, AVG, MAX, MIN ] = 空元素; [ COUNT ] = 0</li></ul></li></ul></li></ul></li></ul><h4 id="关系中的数据约束"><a href="#关系中的数据约束" class="headerlink" title="关系中的数据约束"></a>关系中的数据约束</h4><ul><li>三类数据完整性约束<ul><li>实体完整性约束: 属性不为空值</li><li>参照完整性约束: 外键要么取空值, 要么是被引用表中的主键值</li><li>用户定义的完整性: 用户自己定义的属性取值约束</li></ul></li><li>关系代数<ul><li>关系的表示 </li><li>关系操纵的表示</li><li>关系代数与关系模型</li><li>关系代数的扩充运算</li></ul></li></ul><h3 id="关系的表示"><a href="#关系的表示" class="headerlink" title="关系的表示"></a>关系的表示</h3><ul><li>笛卡尔积<br>$D_1, D_2, \cdots, D_n$是$n$个集合<br>$D_1\times D_2\times\cdots\times D_n=\{(d_1, d_2, \cdots, d_n): d_i\in D_i, i\in (1, 2, \cdots, n)\}$<br>$|D_1\times D_2\times\cdots\times D_n| = \prod_{i=1}^n |D_i|$  </li><li>关系<br>设属性域为$D_1, D_2, \cdots, D_n$<br>关系$R\subseteq D_1\times D_2\times\cdots\times D_n$  </li></ul><h3 id="关系操纵的表示"><a href="#关系操纵的表示" class="headerlink" title="关系操纵的表示"></a>关系操纵的表示</h3><ul><li>对应关系<br>| 关系基本操作 | 关系代数运算 |<br>| :-: | :-: |<br>| 元组选择 | 选择运算 |<br>| 属性指定 | 投影运算 |<br>| 关系合并 | 笛卡尔积 |<br>| 元组插入 | 并运算 |<br>| 元组删除 | 差运算 |<br>注意运算的: 执行条件, 执行结果</li><li>相容表/同类关系: 相同的表头: 同数量, 同名, 同值域</li><li>关系运算<ul><li>交运算: 同类关系<ul><li>用$R\cap S = R-(R-S)$代替, 不是基本运算</li></ul></li><li>并运算: 同类关系: 交换律, 结合律<ul><li>关系模式不变, 属于$R$或者$S$</li></ul></li><li>差运算: 同类关系: 无交换律, 无结合律<ul><li>关系模式不变, 属于$R$且不属于$S$</li></ul></li><li>投影运算: $\pi_A(R)$: 无交换律<ul><li>略去某些列, 重排剩余列的次序<br>关系$R$有属性$\{A_1,A_2, \cdots, A_n\}$, 在其中$m$个属性上的投影运算如下<br>$\pi_{B_1, B_2, \cdots, B_n}(R), B_i\in\{A_1,A_2, \cdots, A_n\}$  </li><li>注意消除可能出现的重复元组</li></ul></li><li>选择运算: $\sigma_F(R)$: 交换律<ul><li>关系模式不变, 由属于$R$且满足条件$F$的元组构成</li></ul></li><li>笛卡尔乘积 - 关系的合并: 交换律, 结合律<ul><li>若有相同的属性名, 必须在结果关系中对其中一个换名</li></ul></li></ul></li><li>关系操作<ul><li>插入: $R^*=R\cup R_{new}$</li><li>删除: $R^* = R-R_{old}$</li><li>修改: $R^* = (R-R_{old})\cup R_{new}$</li><li>查询: $\pi_A(\sigma_B(R))$简写为$\pi_A\sigma_B(R)$: 不能交换位置</li></ul></li></ul><h3 id="关系模型与关系代数"><a href="#关系模型与关系代数" class="headerlink" title="关系模型与关系代数"></a>关系模型与关系代数</h3><ul><li>关系: $n$元有序组的集合</li><li>关系操纵: 关系上的集合运算</li><li>关系代数: 关系集合$A$及5种基运算构成的代数</li><li>关系模型<ul><li>关系模型的数据结构</li><li>关系模型上的数据操纵</li><li>关系模型上的数据约束</li></ul></li></ul><h3 id="关系代数中的扩充运算"><a href="#关系代数中的扩充运算" class="headerlink" title="关系代数中的扩充运算"></a>关系代数中的扩充运算</h3><ul><li>交运算: 同类关系: 交换律, 结合律<ul><li>关系模式不变, 既属于$R$也属于$S$的元组组成的集合</li><li>可由差运算实现: $R\cap S=R-(R-S)=S-(S-R)$</li></ul></li><li>除运算: $\textrm{Head}(S)\subset \textrm{Head}(R)$<ul><li>关系模式: $\textrm{Head}(T)=\textrm{Head}(R) - \textrm{Head}(S)$</li><li>设$x\in T$, 则$\forall y\in S$, $(x,y)\in R$, 所有满足条件的$x$构成结果</li><li>如果$R=T\times S$, 则$T=R\div S$, $S=R\div T$; 如果$T=R\div S$, 则$T\times S\subseteq R$</li><li>$R\div S=\pi_{A_1,\cdots A_n}(R)-\pi_{A_1,\cdots A_n}((\pi_{A_1,\cdots A_n}(R)\times S)-R)$</li></ul></li><li>联接运算<ul><li>根据联接条件合并: $R\bowtie_F S=\sigma_F(R\times S)$</li><li>自然联接: $R\bowtie S$所有同名属性上的取值都一样, 就联接元组, 同名属性保留一份</li><li>外联接: 有”外”的一侧, 其所有元组均出现, 另一侧无匹配元组就用null代替</li></ul></li></ul><h3 id="关系代数实例"><a href="#关系代数实例" class="headerlink" title="关系代数实例"></a>关系代数实例</h3><h4 id="解题技巧"><a href="#解题技巧" class="headerlink" title="解题技巧"></a>解题技巧</h4><ul><li>“所有A都…的B”, 用除法, 被除的对象应当先投影, 以免遗漏</li><li>用公共属性查私有属性, 先笛卡尔积, 之后用选择, 条件设为同名属性取值相等, 最后投影</li><li>正面难构造, 就构造反面, 然后用笛卡尔积减去反面</li><li>最大值最小值, 例子: 取C中最大, C为key-value对<br>$$D\coloneqq C$$<br>$$M = C - \pi_{C.key,C.val}\sigma_{C.val &lt; D.val}(C\times D)$$<br>原理: 每取值跟所有取值比较, 存在更大就会保留, 找出所有的非最大值, 之后减去</li><li>同时满足多个条件, 则取交; 满足多个条件中的一个, 则取并</li><li>联接可以实现”之一”的效果, 也可以实现相等关系</li></ul><h4 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h4><ul><li>确定查询目标（结果关系中的属性）</li><li>明确查询条件</li><li>选择从条件到目标的查找路径，并据此确定操作对象，即: <ul><li>在操作过程中需要使用到那些关系?</li><li>这些关系又是如何被联接成一个关系的?</li></ul></li><li>关系的合并<ul><li>根据步骤 3) 的分析结果进行关系的联接</li></ul></li><li>元组的选择<ul><li>根据步骤 2) 的分析结果(查询条件)进行元组的选择</li></ul></li><li>属性的指定<ul><li>根据步骤 1) 的分析结果执行投影操作</li></ul></li></ul><h4 id="更多技巧"><a href="#更多技巧" class="headerlink" title="更多技巧"></a>更多技巧</h4><ul><li>差运算<ul><li>当查询条件带有‘否定’语义，或者具有明显的‘排它性’的时候，通常需要使用两个子查询之间的‘差’运算</li><li>‘差’运算的运算对象（关系）中，通常需要包含其关键字</li></ul></li><li><p>“笛卡尔积/θ-连接/自然连接”的使用方法</p><ul><li>都是关系的合并运算<ul><li>笛卡尔积是基本运算，θ-连接和自然连接则是扩充运算, 请注意三者的结果关系的关系模式之间的区别</li></ul></li><li>笛卡尔积<ul><li>是实现跨不同关系表进行数据访问的基础, 在笛卡尔积的结果关系中，存在着很多无意义的结果元组，通常需要通过后续的选择运算过滤掉</li></ul></li><li>θ-连接<ul><li><strong>相邻的“笛卡尔积+选择运算”可以合并为一个θ-连接</strong></li></ul></li><li>自然连接<ul><li>如果连接条件是基于“两张表中的所有同名属性的相等比较”，可以将θ-连接进一步简写为自然连接</li></ul></li><li>一般方法: 笛卡尔积+选择  or  θ-连接<ul><li>不存在同名属性，或者连接条件不是基于同名属性的相等比较</li><li>在结果关系中可能存在同名属性，需要加以区别</li></ul></li><li>常用方法: 自然连接<ul><li>连接条件是隐含的（所有同名属性的相等比较）</li><li>如果在两个关系之间存在多对‘同名属性’，而本次查询又不需要‘所有’的同名属性都相等，此时有两种选择: </li><li>采用前述的一般方法来实现关系的合并</li><li><strong>先对其中的一个关系执行投影运算</strong>，过滤掉其中不需要相等的那些同名属性，然后再使用自然连接运算</li></ul></li><li>难点: 关系的自连接<ul><li>使用<strong>赋值运算定义‘同质不同名’的两个中间关系</strong>(元组集合相同，但关系名不同)，当然也可以对中间关系中的属性进行重命名</li><li>然后再使用前述的一般方法实现两个中间关系的合并</li></ul></li></ul></li><li><p>除</p><ul><li>‘除’ 运算与‘联接’运算的区别</li><li>我们将查询的结果关系称为‘目标对象’，用于定义查询条件的关系称为‘条件对象’</li><li>在决定某个元组t是否属于结果关系时，<ul><li>如果只需要从条件对象中找到<strong>一个元组</strong>c并使得查询条件成立，那么就直接使用‘联接’运算（包括笛卡尔积、θ-连接和自然连接）</li><li>如果需要条件对象集中的<strong>所有元组</strong>都能使得查询条件成立，那么就使用‘除’运算</li></ul></li><li>‘除’ 运算表达式的表示方法<ul><li>被除数关系中必须包含目标对象和条件对象的<strong>关键字</strong></li><li>除数关系中只含条件对象的关键字</li><li>被除数和除数关系中<strong>不能含其它‘不必要’的多余属性</strong>, 先投影再除</li></ul></li></ul></li></ul><h2 id="关系演算"><a href="#关系演算" class="headerlink" title="关系演算"></a>关系演算</h2><h3 id="一阶谓词演算"><a href="#一阶谓词演算" class="headerlink" title="一阶谓词演算"></a>一阶谓词演算</h3><ul><li>命题:  可以判断真假的语句<ul><li>个体词: 可以独立存在的客体<ul><li>个体常量: $a,b,c,\cdots$: 具体特定</li><li>个体变元: $x,y,z,\cdots$: 抽象泛指</li><li>个体域: 指个体变元的取值范围</li><li>全总个体域: 由宇宙间的一切事物组成</li></ul></li><li>谓词: 个体性质或个体间关系: $P(x_1,x_2,\cdots,x_n)$<ul><li>常项/变项: 具体性质或关系/抽象泛指的性质或关系</li><li>n/0元谓词: 含n个/不含个体变元的谓词</li><li>根据变元的取值来判断其是否成立</li></ul></li></ul></li><li>指派: $(v_1,v_2,\cdots,v_n)$为$P(x_1,x_2,\cdots,x_n)$的指派, $x_i$取值$v_i$<ul><li>成真指派/成假指派: $P(v_1,v_2,\cdots,v_n)$为逻辑真/假</li></ul></li><li>量词: 个体常量或个体变元之间数量关系<ul><li>全称/存在量词: 每一个/至少有一个 个体域中的个体满足谓词</li><li>约束/自由变元: 受到/不受量词约束的变元</li><li>顺序: 既有全称量词也有存在量词，那么它们的书写顺序是相关的, 无括号则从左到右依次处理</li><li>指派: 只对自由变元取值</li></ul></li><li>连接符<ul><li>非, 与, 或, 蕴含</li></ul></li></ul><h3 id="关系的表示-1"><a href="#关系的表示-1" class="headerlink" title="关系的表示"></a>关系的表示</h3><p>关系-&gt;谓词<br>关系操作-&gt;关系演算公式</p><ul><li>关系演算系统<ul><li>元组关系演算: 变元取值为元组, 元组变量<br>$n$元关系$R$-&gt;谓词$R(t)$, $t$为元组变量, $t(i)$为关系$R$中第$i$属性</li><li>域关系演算: 变元取值为单个属性值, 域变量<br>$n$元关系$R$-&gt;$n$元谓词$R(x_1,x_2,\cdots,x_n)$, $x_i$为属性变量, 为关系$R$中第$i$属性</li></ul></li><li>关系表示<ul><li>关系$R$中的每个元组都是成真指派, 其他不出现在$R$中的任何元组都是成假指派</li><li>元组关系演算: $R=\{t|P(t)\}$</li><li>域关系演算: $R=\{&lt;x_1,x_2,\cdots,x_n&gt;|P(x_1,x_2,\cdots,x_n)\}$</li></ul></li></ul><h3 id="关系操纵的表示-1"><a href="#关系操纵的表示-1" class="headerlink" title="关系操纵的表示"></a>关系操纵的表示</h3><ul><li>并<br>$$R\cup S=\{t|R(t)\vee S(t)\}$$</li><li>差<br>$$R-S=\{t|R(t)\wedge \neg S(t)\}$$</li><li>选择<br>$$\sigma_F(R)=\{t|R(t)\wedge F\}$$</li><li>投影<br>$$\pi_{A_{i_1},A_{i_2},\cdots,A_{i_k}}(R)=\{u^{(k)}|\exists t, (R(t)\wedge \bigwedge^ku(k)=t(i_k))\}$$</li><li>笛卡尔积<br>$$R\times S=\{t^{(m+n)}|\exists u\exists v, (R(u)\wedge S(v)\wedge\bigwedge_{i=1}^m t(i) = u(i)\wedge \bigwedge_{j=1}^n t(m+j)=v(j))\}$$</li><li>关系演算表达式<br>$\{t|\phi(t)\}$, 简写为$\phi(t)$</li><li>公式, 原子公式: 见数理逻辑</li><li>优先顺序<ul><li>比较运算符&gt;量词&gt;否定操作&gt;逻辑运算符, 有括号的优先</li></ul></li></ul><h3 id="关系演算的例子"><a href="#关系演算的例子" class="headerlink" title="关系演算的例子"></a>关系演算的例子</h3><ul><li>投影<br>$$\pi_{A_{1},A_{2},\cdots,A_{k}}(R)=\exists x_{k+1},x_{k+2},\cdots ,x_n(R(x_1,x_2,\cdots,x_n))$$</li><li>选择<br>$$\sigma_F(R)=R(x_1,x_2,\cdots,x_n)\wedge F$$<ul><li>相等比较可以直接用常量代替: $\sigma_{x_1=’a’}(R)=R(‘a’,x_2,\cdots,x_n)\wedge F$</li></ul></li><li>笛卡尔积<br>$$R\times S = R(p)\wedge S(q)$$</li><li>$\theta$-联接<br>$$R\underset{F}{\bowtie} S = R(p)\wedge S(q)\wedge F$$</li><li>自然联接<br>$$R\bowtie S = R(x,y,z)\wedge S(t,u,v)$$</li><li>自联接, 重命名<br>$$R(x, g_1)\wedge R(x, g_2)$$</li><li>除法<br>$$R\div S=\forall y(S(y)\rightarrow R(x,y))$$</li><li>删除<br>$$R-S = R(u)\wedge \neg S$$</li><li>插入<br>$$R\cup S = R(t)\vee S(t)$$</li><li>修改 = 删除再插入</li></ul><h3 id="关系演算的安全限制"><a href="#关系演算的安全限制" class="headerlink" title="关系演算的安全限制"></a>关系演算的安全限制</h3><ul><li>无限性问题<ul><li>无限关系: 无限个元组</li><li>无穷验证: 量词引发无穷验证</li></ul></li><li>安全公式: 不产生无限性问题的公式</li><li>约束集: $\text{DOM}(\phi)$<ul><li>构成: 公式中出现的关系中的某些分量, 公式中显式出现的常量符号</li><li>以公式$\phi$作特性可以构造出一个元组集合，其中的每个元组只能由出现在$\text{DOM}(\phi)$中的符号构成，则这样的公式$\phi$是安全的</li></ul></li><li>判定条件<ul><li>如$t$满足公式$\phi$，则$t$的每个分量必定是$\text{DOM}(\phi)$的元素<br>不产生无限关系</li><li>对$\phi$中每一个形为$\exists t(W(t))$的子公式，若 t满足 W, 则$t$的每个分量一定属于$\text{DOM}(\phi)$<br>不因为量词$\exists$而无穷验证</li><li>对$\phi$中每一形为$\forall t(W(t))$的子公式，如果t 的任一分量不在 $\text{DOM}(\phi)$中，则$t$必定满足W<br>不因为量词$\forall$而无穷验证</li></ul></li></ul><h3 id="关系代数与关系演算"><a href="#关系代数与关系演算" class="headerlink" title="关系代数与关系演算"></a>关系代数与关系演算</h3><ul><li>‘关系代数’  等价于  ‘安全的关系演算’<ul><li>用关系演算表达式可以表示关系代数中的五种基本运算</li><li>用关系代数表达式可以表示安全的关系演算<ul><li>可以将一个安全的关系演算公式转换成等价的一个关系代数表达式</li><li>关系演算公式的构成方式: 原子公式, 原子公式的量词和演算</li><li>原子公式的表示: 量词/属性间比较/属性与常量比较</li></ul></li></ul></li><li>公式的表示<ul><li>$\phi_1\wedge\phi_2$<ul><li>有公共变元, 等价于自然联接$R_1\bowtie R_2$</li><li>无公共变元, 等价于笛卡尔乘积$R_1\times R_2$</li></ul></li><li>$\phi_1\vee\phi_2$: $R_1\cup R_2$</li><li>$\phi_1\rightarrow\phi_2$: $R_2\div R_1$</li><li>$\neg\phi$: $(\prod^nD_i)-R$, $D_i$为第$i$个自由变元的值域</li><li>$\exists r(\phi)$: $\pi_{A_1,A_2,\cdots,A_k}(R)$</li><li>$\forall r(\phi)$: $R\div S$</li></ul></li><li>完备系统<ul><li>能够提供关系代数的五种基本运算功能的关系模型系统</li><li>具有安全的关系演算功能的关系模型系统</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一章-数据库系统概述&quot;&gt;&lt;a href=&quot;#第一章-数据库系统概述&quot; class=&quot;headerlink&quot; title=&quot;第一章: 数据库系统概述&quot;&gt;&lt;/a&gt;第一章: 数据库系统概述&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class
      
    
    </summary>
    
    
      <category term="Course" scheme="https://Maxwell-lyu.github.io/tags/Course/"/>
    
      <category term="Introduction to Database" scheme="https://Maxwell-lyu.github.io/tags/Introduction-to-Database/"/>
    
  </entry>
  
  <entry>
    <title>Problem Solving IV Note 07</title>
    <link href="https://Maxwell-lyu.github.io/2019/06/16/Learn-PS-20190616-PS-IV-07/"/>
    <id>https://Maxwell-lyu.github.io/2019/06/16/Learn-PS-20190616-PS-IV-07/</id>
    <published>2019-06-16T12:41:25.000Z</published>
    <updated>2019-06-16T12:47:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-31-数论算法"><a href="#Chapter-31-数论算法" class="headerlink" title="Chapter 31: 数论算法"></a>Chapter 31: 数论算法</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">      x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ans = exgcd (b, a % b, y, x);</span><br><span class="line">  y -= a / b * x;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Chapter-31-数论算法&quot;&gt;&lt;a href=&quot;#Chapter-31-数论算法&quot; class=&quot;headerlink&quot; title=&quot;Chapter 31: 数论算法&quot;&gt;&lt;/a&gt;Chapter 31: 数论算法&lt;/h1&gt;&lt;figure class=&quot;high
      
    
    </summary>
    
    
      <category term="Course" scheme="https://Maxwell-lyu.github.io/tags/Course/"/>
    
      <category term="Problem Solving" scheme="https://Maxwell-lyu.github.io/tags/Problem-Solving/"/>
    
      <category term="Introduction to Algorithms" scheme="https://Maxwell-lyu.github.io/tags/Introduction-to-Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Probability Ch8</title>
    <link href="https://Maxwell-lyu.github.io/2019/06/11/Learn-PMS-20190611-PMS-08/"/>
    <id>https://Maxwell-lyu.github.io/2019/06/11/Learn-PMS-20190611-PMS-08/</id>
    <published>2019-06-11T02:57:16.000Z</published>
    <updated>2019-06-16T08:14:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>Probability Course in 2019 Spring<br><a id="more"></a> </p><h1 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a>假设检验</h1><h2 id="u-检验"><a href="#u-检验" class="headerlink" title="$u$检验"></a>$u$检验</h2><p>$$\frac{\bar{X}{}$$ </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Probability Course in 2019 Spring&lt;br&gt;
    
    </summary>
    
    
      <category term="Course" scheme="https://Maxwell-lyu.github.io/tags/Course/"/>
    
      <category term="Probability and Mathematical Statistics" scheme="https://Maxwell-lyu.github.io/tags/Probability-and-Mathematical-Statistics/"/>
    
  </entry>
  
  <entry>
    <title>Data Communication Final</title>
    <link href="https://Maxwell-lyu.github.io/2019/06/04/Learn-DC-20190604-DC-FIN/"/>
    <id>https://Maxwell-lyu.github.io/2019/06/04/Learn-DC-20190604-DC-FIN/</id>
    <published>2019-06-04T07:28:33.000Z</published>
    <updated>2019-10-13T12:48:21.387Z</updated>
    
    <content type="html"><![CDATA[<p>数据通信: 期末复习<br><a id="more"></a>  </p><h1 id="第二章：网络体系结构"><a href="#第二章：网络体系结构" class="headerlink" title="第二章：网络体系结构"></a>第二章：网络体系结构</h1><ul><li>通信模型<ul><li>源系统（源点，发送器），传输系统，目的系统（接收器，终点)</li></ul></li><li>传输方式<ul><li>单工：一个信道，只能单向</li><li>半双工：一个信道，同一时间只能上/下行，有选择器</li><li>全双工：两个信道，同时上下行</li></ul></li><li>数字通信与模拟通信<ul><li>数字系统：数字-数字编码，模拟-数字编码</li><li>模拟系统：模拟信号以固有频率基带传输（不编码），频谱搬移后传输（模拟-模拟编码）</li><li>混成系统：同一系统既包含模拟也包含数字</li></ul></li><li>网络体系结构：TCP/IP<ul><li>应用层，传输层，网际层，数据链路层，物理层</li></ul></li><li>套接字及其类型<ul><li>流套接字：TCP：可靠，按时</li><li>数据包套接字：UDP：快速乱序无保证</li><li>原始套接字：IP：直接访问底层</li></ul></li></ul><h1 id="第三章：数据传输"><a href="#第三章：数据传输" class="headerlink" title="第三章：数据传输"></a>第三章：数据传输</h1><ul><li>概念与术语<ul><li>导向媒体：电磁波沿某一物理路径前进（光纤，双绞线，同轴电缆<ul><li>点对点：直连链路</li><li>多点：共享</li></ul></li><li>非导向媒体：无线传输，不引导传输方向（空气，真空，海水</li></ul></li><li>数据与信号<ul><li>数据：信源产生，可能为模拟或数字</li><li>信号：经过调制，电磁信号居多</li></ul></li><li>周期信号的傅里叶级数表示<ul><li>傅里叶表示：<br>$$x(t)=\frac{A_0}{2}+\sum_{n=1}^{\infty}(A_n\cos(2\pi nf_0t)+B_n\sin(2\pi nf_0t))$$<br>$$A_n = \frac{2}{T}\int_{0}^{T}x(t)\cos(2\pi nf_0t)dt$$<br>$$B_n = \frac{2}{T}\int_{0}^{T}x(t)\sin(2\pi nf_0t)dt$$</li><li>方波的傅里叶表示<br>$$f(x)=\frac{4}{\pi}\sum_{n=2k-1}^\infty \frac{1}{n}\sin(\frac{n\pi x}{L})$$</li></ul></li><li>信号功率计算<ul><li>任意时段功率：<br>$$P_x=\frac{1}{t_2-t_1}\int_{t_1}^{t_2}|x(t)|^2dt$$</li><li>周期平均功率<br>$$P=\frac{1}{T}\int_{0}^{T}|x(t)|^2dt$$   </li></ul></li><li>信号的频谱与带宽<ul><li>频谱：信号的频率范围</li><li>绝对带宽：频谱宽度，最大减最小</li><li>有效带宽：包含绝大多数能量的带宽，某频率区间的功率积分是总功率的一半（-3dB）</li><li>直流分量：频率为0的部分</li></ul></li><li>方波数据率与带宽的关系<ul><li>$R_b=2f$，$R_b$数据率，$f$方波频率</li></ul></li><li>模拟/数字数据与模拟/数字传输<ul><li>模拟信号：放大器</li><li>数字信号：转发器</li></ul></li><li>数字信号传输的优势<ul><li>大规模集成电路</li><li>数据完整性</li><li>容量利用率</li><li>安全和保密</li><li>综合性、存储</li></ul></li><li>传输损伤<ul><li>衰减：放大器与转发器解决<ul><li>要求: 接收到的信号足够强, 信号电平高于噪声电平</li></ul></li><li>失真<ul><li>衰减失真：高频失真多，衰减均衡和高频高倍放大解决</li><li>时延失真：中心频率附近传输快，仅限数字信号，码间串扰</li></ul></li><li>噪声<ul><li>信噪比：$SNR_{db}=\lg{\frac{S}{N}}$</li><li>热噪声：$N_0=kT$，$k$玻尔兹曼常量，$T$热力学温度, 每赫兹噪声, 计算时$N=BN_0$</li><li>互调噪声、串扰（双绞线扭绞）、冲激噪声</li></ul></li></ul></li><li>信道容量：最大数据传输速率<ul><li>数据率bps，带宽Hz，噪声，误码率</li><li>奈奎斯特带宽：信道无噪声时：$C=2B\log_2{M}$，$M$指信号的电平数</li><li>香农容量公式：只有热噪声时：$C=B\log_2(1+SNR)$，$SNR=10^{0.1SNR_{db}}$为信噪比</li></ul></li></ul><h1 id="第四章：传输媒体"><a href="#第四章：传输媒体" class="headerlink" title="第四章：传输媒体"></a>第四章：传输媒体</h1><ul><li>光纤<ul><li>优势：容量大，体积小，衰减小，电磁隔离，转发器间隔远</li><li>折射率分类：<ul><li>阶跃型：折射率阶跃，会有失真</li><li>渐变型：光路周期性汇聚</li></ul></li><li>模式分类<ul><li>单模、多模</li></ul></li></ul></li><li>无线传播：高频天线小<ul><li>地波：-2MHz</li><li>天波：2MHz-30MHz</li><li>视距传播：30MHz-</li></ul></li><li>视距传播损伤<ul><li>自由空间损耗模型<br>$$L=10\lg(\frac{4\pi d}{\lambda})^2dB$$</li></ul></li></ul><h1 id="第五章：信号编码技术"><a href="#第五章：信号编码技术" class="headerlink" title="第五章：信号编码技术"></a>第五章：信号编码技术</h1><ul><li>编码与调制技术<ul><li>数字信号传输：数字或模拟数据-&gt;(编码器)-&gt;数字信号-&gt;(解码器)-&gt;原数据</li><li>模拟信号传输：数字或模拟基带信号<->(调制解调器)<->模拟信号</-></-></li></ul></li><li>数字信号编码格式<ul><li>NRZ-L：高电平0，低电平1</li><li>NRZI：区间起始无变化0，区间起始有变化1</li><li>双极性AMI：零电平0，正电平负电平1交替出现</li><li>伪三进制：正电平负电平0交替出现，零点平1</li><li>曼彻斯特：区间正中高到低0，低到高1</li><li>差分曼彻斯特：区间正中总是变化，区间起始变化0，区间起始不变1</li></ul></li><li>扰码<ul><li>扰码产生替代连续电压的序列</li><li>填充序列：提供足够的信息用于同步，可被识别替换还原，长度相同</li><li>目标：不含直流，定时信息丰富，不降低数据率，可检错，易于判断还原</li></ul></li><li>HDB3：会给出编码方式  </li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">自上一次替换后双极性</th><th style="text-align:center">脉冲（比特1）数</th></tr></thead><tbody><tr><td style="text-align:center">前面脉冲的极性</td><td style="text-align:center">奇数</td><td style="text-align:center">偶数</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">000-</td><td style="text-align:center">+00+</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">000+</td><td style="text-align:center">-00-</td></tr></tbody></table><ul><li>调制技术：开关键控载波<ul><li>振幅ASK：01由振幅表示<ul><li>相干解调：乘上同周期的信号，低通滤波</li></ul></li><li>频移FSK：不同频率表示01<ul><li>应用：话音，高频无线电（天波，同轴电缆局域网</li></ul></li><li>相移PSK：不同相位表示信息<ul><li>二进制相移键控：$0,\pi$</li><li>QPSK：四个相位，$\pm\frac{\pi}{4},\pm\frac{3\pi}{4}$</li></ul></li><li>正交调幅QAM：两个载波正交（差90相位，分别ASK，两个独立信号</li><li>补点公式：<ul><li>ASK，PSK<br>$$B_T=(1+r)R$$</li><li>FSK<br>$$B_T=2\Delta f+(1+r)R$$</li><li>MPSK<br>$$B_T=\frac{1+r}{\log_2M}R$$</li><li>MFSK<br>$$B_T=\frac{(1+r)M}{\log_2M}R$$</li></ul></li></ul></li><li>模拟数据数字化<ul><li>脉码调制PCM<ul><li>定时采样，每次采样有几个bit进行量化</li><li>压扩函数：非线性编码，振幅低的地方密集</li></ul></li><li>增量调制DM<ul><li>近似信号的导数，有过载噪声</li></ul></li></ul></li><li>模拟调制系统<ul><li>模拟数据加载到载波，利于传输，允许频分复用，扩展带宽，抗干扰</li><li>调幅AM<ul><li>数据与载波相加<br>$$s_{AM}=[A_0+m(t)]\cos\omega_ct$$<br>归一化，小于1时可以包络解调，否则只能正交解调<br>$$s(t)=[1+n_ax(t)]\cos2\pi f_ct, n_a&lt;1$$</li></ul></li><li>调频FM<br>$$s(t)=A_c\cos[2\pi f_c+\varphi(t)],\varphi’(t)=n_fm(t)$$</li><li>调相PM<br>$$s(t)=A_c\cos[2\pi f_c+\varphi(t)],\varphi(t)=n_pm(t)$$<br>与FM转化：频率可定义为相位变化率，因此将PM后面的积分即可得到FM</li></ul></li></ul><h1 id="第六章：差错检测与矫正"><a href="#第六章：差错检测与矫正" class="headerlink" title="第六章：差错检测与矫正"></a>第六章：差错检测与矫正</h1><ul><li>奇偶校验<ul><li>偶校验：末尾加校验比特，整个字符中的1的个数为偶数</li></ul></li><li>因特网校验和<ul><li>两个数字视为无符号二进制整数，相加，高位进位就在最低位加1</li></ul></li><li>循环冗余检验CRC<ul><li>k位信息，生成n-k位比特，作为检验序列（会给出公式，公式最高位$X^{n-k}$</li></ul></li><li>块码原理<ul><li>2k+1的距离，最多检2k=$d_{min}-1$，最多纠k=$\lfloor\frac{d_{min}-1}{2}\rfloor$</li><li>冗余度：(n-k)/k，码字共n位，k个信息位</li><li>编码率：k/n</li></ul></li></ul><h1 id="第七章-数据链路控制协议"><a href="#第七章-数据链路控制协议" class="headerlink" title="第七章: 数据链路控制协议"></a>第七章: 数据链路控制协议</h1><h2 id="帧传输模型"><a href="#帧传输模型" class="headerlink" title="帧传输模型"></a>帧传输模型</h2><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><table><thead><tr><th>名称</th><th>描述</th><th>详述</th></tr></thead><tbody><tr><td>传输时延</td><td>数据量 ÷ 数据率</td><td>emit <strong>all bits</strong> into medium</td></tr><tr><td>传播时延</td><td>介质一段到另一端</td><td><strong>a bit</strong> to traverse the link</td></tr><tr><td>处理时延</td><td>单节点时延 × 途径节点数</td><td>the recipient or intermediate <strong>node</strong> processing</td></tr><tr><td>排队时延</td><td>Σ此前耗时</td><td>waiting time at the <strong>queue</strong></td></tr></tbody></table><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><h3 id="停止等待流量控制"><a href="#停止等待流量控制" class="headerlink" title="停止等待流量控制"></a>停止等待流量控制</h3><ul><li><p>流程  </p><ol><li>源点<strong>发送帧</strong></li><li>终点<strong>收到帧</strong>, 回复<strong>ACK</strong></li><li>原点收到<strong>ACK</strong>, 发送<strong>下一帧</strong></li><li>终点不发ACK终止流</li></ol></li><li><p>数据切分成小数据块传输  </p><ol><li>接收方<strong>缓存有限</strong></li><li>便于<strong>错误重传</strong></li><li>避免一个站点<strong>长时间占用传输媒体</strong></li></ol></li><li><p>计算题  </p><ul><li>链路比特长度<br>数据率$R/bps$, 距离$d/m$, 传播速度$v/ms^{-1}$<br>$$B=R\times\frac{d}{v}$$  </li><li>传播时延(归一化值)<br>链路比特长度$B/b$, 帧长度$L/b$<br>$$a=\frac{t_{prop}}{t_{frame}}=\frac{d/v}{L/R}=\frac{B}{L}$$</li><li>链路利用率<br>传播时延(归一化值)$a$<br>$$U=\frac{t_{frame}}{t_{all}}=\frac{t_{frame}}{2t_{prop}+t_{frame}}=\frac{1}{1+2a}$$</li></ul></li></ul><h3 id="滑动窗口流量控制"><a href="#滑动窗口流量控制" class="headerlink" title="滑动窗口流量控制"></a>滑动窗口流量控制</h3><ul><li><p>流程<br>接收端缓存大小 W<br>发送端在没有收到ACK前可以发送W个帧<br>每个帧通过序号来标识, 序号大小受字段长度限制(k bits)帧以 2 k 为模编号($0\to 2^{k}-1$)<br>ACK(RRx)包含<strong>下一个期望收到的帧</strong>编号x  </p></li><li><p>优化  </p><ol><li>接收端可发送RNR, 切断对方的帧流</li><li>之后, 接收端必须通过一个正常的确认帧来重启</li><li>双向链路捎带: 没数据有确认就单发ACK, 有数据有确认就捎带, 有数据没确认就发重复的确认</li></ol></li><li><p>计算题  </p><ul><li>链路利用率<br>窗口宽度$W$, 传播时延(归一化值)$a$<br>$$U=\begin{cases}<br>1 &amp; W \geq 2a + 1\\<br>\frac{W}{2a + 1} &amp; W &lt; 2a + 1<br>\end{cases}$$</li></ul></li></ul><h2 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h2><ul><li>自动请求重传ARQ<br>差错检测 肯定确认 超时重传 否定重传</li></ul><h3 id="停止等待ARQ-Stop-and-Wait"><a href="#停止等待ARQ-Stop-and-Wait" class="headerlink" title="停止等待ARQ Stop and Wait"></a>停止等待ARQ Stop and Wait</h3><ul><li>基于停止等待流量控制</li><li>保持一个发送帧的拷贝, 在终点确认返回前, 源点不发送其他帧</li><li>帧损伤<ul><li>接收端检测到差错, 丢弃该帧？</li><li>发送端超时重传</li></ul></li><li>ACK 损伤<ul><li>发送端超时重传</li><li>接收端收到用两份相同编号的帧</li></ul></li></ul><h3 id="Go-Back-N-ARQ"><a href="#Go-Back-N-ARQ" class="headerlink" title="Go-Back-N ARQ"></a>Go-Back-N ARQ</h3><ul><li>基于滑动窗口流控机制, 没有收到确认的帧的最大数目取决于窗口大小</li><li>无错误: ACKx表示准备接收x号帧</li><li>有错误: REJx表示x号帧错误, 重传x及其后的所有帧</li><li>ACK(RR) 损伤: 下一个ACK可能在超时前到来, 那么无影响; 否则发送”ACK with P bit set”重置</li><li>REJ 损伤: 接收端将其作为丢失帧, 计算超时</li></ul><h3 id="选择拒绝ARQ-Selective-Reject"><a href="#选择拒绝ARQ-Selective-Reject" class="headerlink" title="选择拒绝ARQ Selective Reject"></a>选择拒绝ARQ Selective Reject</h3><ul><li>仅重传拒绝帧或超时帧, 后续帧被接收端接收并缓存起来</li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table><thead><tr><th>ARQ</th><th>最大窗口大小(n bit 序号)</th><th>发送端缓存大小</th><th>接收端缓存大小</th></tr></thead><tbody><tr><td>Stop-Wait</td><td>无窗口, 无序号</td><td>无</td><td>无</td></tr><tr><td>Go-Back-N</td><td>$2^n-1$</td><td>窗口大小</td><td>无</td></tr><tr><td>Sel-Rej</td><td>$2^{n-1}$</td><td>窗口大小</td><td>窗口大小</td></tr></tbody></table><h2 id="HDLC"><a href="#HDLC" class="headerlink" title="HDLC"></a>HDLC</h2><ul><li>站点类型<ul><li>主站: 负责链路控制操 命令</li><li>从站: 在主站的控制下操作 响应</li><li>混合站: 结合了主站和从站的特点</li></ul></li><li>链路设置<ul><li>非平衡设置 1 个主站, 多个从站</li><li>平衡设置 2 个混合站组成</li></ul></li><li>数据传送方式</li></ul><table><thead><tr><th>数据传送方式</th><th>链路设置</th><th>传输发起</th></tr></thead><tbody><tr><td>正常相应方式NRM</td><td>非平衡设置</td><td>主站发起, 从站收到主站命令才能传输</td></tr><tr><td>异步平衡方式ABM</td><td>平衡设置</td><td>混合站均可发起, 应用最广泛</td></tr></tbody></table><ul><li>帧结构<br>同步传输, 以帧的形式进行, 一个帧格式满足控制和交换 </li></ul><table><thead><tr><th style="text-align:center">Flag</th><th style="text-align:center">Address</th><th style="text-align:center">Control</th><th style="text-align:center">Information</th><th style="text-align:center">FCS</th><th style="text-align:center">Flag</th></tr></thead><tbody><tr><td style="text-align:center">8 bit</td><td style="text-align:center">8 bit extendable</td><td style="text-align:center">8 or 16 bit</td><td style="text-align:center">variable</td><td style="text-align:center">16 or 32 bit</td><td style="text-align:center">8 bit</td></tr></tbody></table><h1 id="第八章-复用"><a href="#第八章-复用" class="headerlink" title="第八章: 复用"></a>第八章: 复用</h1><h2 id="FDM-频分复用"><a href="#FDM-频分复用" class="headerlink" title="FDM 频分复用"></a>FDM 频分复用</h2><ul><li>概念: 多个信号调制到不同的载波频率上, 且有足够间隙防止其带宽重叠, 以同时运载  </li><li>信道: 每个信号占有的频率范围  </li><li>防护频带: 载波频率中, 信道之间未被占用的部分  </li><li>流程<br>载波$m_i(t)$ <ruby>—&gt;<rt>调制器$f_i$</rt></ruby> 副载波$s_i(t)$ <ruby>—&gt;<rt>叠加$\sum$</rt></ruby> 基带$m_b(t)$ <ruby>—&gt;<rt>发送器$f_c$</rt></ruby> FDM信号$s(t)$<br>FDM信号$s(t)$ <ruby>—&gt;<rt>接收器</rt></ruby> 复合基带$m_b(t)$ <ruby>—&gt;<rt>滤波器$f_i$</rt></ruby> 副载波$s_i(t)$ <ruby>—&gt;<rt>解调器$f_i$</rt></ruby> 载波$m_i(t)$ </li><li>WDM 波分复用</li></ul><table><thead><tr><th>复用类型</th><th>关键设备</th><th>复用原理</th><th>介质</th></tr></thead><tbody><tr><td>FDM 频分复用</td><td>调制解调器</td><td>载波频率</td><td></td></tr><tr><td>WDM 波分复用</td><td>棱镜</td><td>光波长</td><td>光纤</td></tr></tbody></table><h2 id="Synchronous-TDM-同步时分复用"><a href="#Synchronous-TDM-同步时分复用" class="headerlink" title="Synchronous TDM 同步时分复用"></a>Synchronous TDM 同步时分复用</h2><ul><li>概念<ul><li>可以用于<strong>数字信号</strong>或<strong>模拟信号传输数字数据</strong></li><li>数据被组织成”<strong>帧</strong>“: 每帧包含一组循环使用的<strong>时隙</strong>; </li><li>每个数据源可以被分配一个或多个时隙(较快的设备), 在扫描时分配</li><li>间隔可以是比特级. 也可以是字符级或更大的粒度</li><li>同步时分复用中同步是指时隙被<strong>提前分配给数据源</strong>, 且是固定的</li></ul></li><li>流程<br>数据$m_i(t)$ <ruby>—&gt;<rt>缓存</rt></ruby> 数据$m_i(t)$ <ruby>—&gt;<rt>扫描操作</rt></ruby> TDM流$m_c(t)$ <ruby>—&gt;<rt>调制解调</rt></ruby> 经调制的TDM流$s(t)$<br>经调制的TDM流$s(t)$ <ruby>—&gt;<rt>调制解调</rt></ruby> TDM流$m_c(t)$ <ruby>—&gt;<rt>扫描操作</rt></ruby> 数据$m_i(t)$ <ruby>—&gt;<rt>缓存</rt></ruby> 数据$m_i(t)$   </li><li>链路控制<ul><li>不需要链路控制, 数据流无头尾</li><li>数据率是固定的, 没有信息将发送空时隙</li></ul></li><li>差错控制: 基于单信道的差错控制</li><li>组帧<ul><li>无需为帧定界, 但需源宿同步</li><li>增加数字组帧: 每个TDM帧附加一个控制比特</li><li>同步搜索模式：接收器将接收到的帧中的比特位与预期的模式相比较, 直到这个模式在多个帧里持续传输</li><li>脉冲填充: 同步不同数据率的源</li></ul></li><li>数字载波系统<ul><li>E体系: 2.048Mbps</li><li>T体系: 1.544Mbps</li><li><h2 id="Statistical-TDM-统计时分复用"><a href="#Statistical-TDM-统计时分复用" class="headerlink" title="Statistical TDM 统计时分复用"></a>Statistical TDM 统计时分复用</h2></li></ul></li><li>概念<ul><li>每一源有一缓存, 填满时作为一帧发送</li><li>根据需求分配时隙, 解决空时隙和浪费问题</li></ul></li><li>电缆调制解调器<ul><li>有线电视网访问Internet</li><li>信道  </li></ul></li></ul><table><thead><tr><th>用户到网络数据</th><th>电视节目</th><th>网络到用户数据</th></tr></thead><tbody><tr><td>5-40MHz</td><td>50-550MHz</td><td>550-750MHz</td></tr></tbody></table><ul><li>每个信道被多个用户共享<h2 id="ADSL-非对称用户数字线路"><a href="#ADSL-非对称用户数字线路" class="headerlink" title="ADSL 非对称用户数字线路"></a>ADSL 非对称用户数字线路</h2><ul><li>用户与广域网之间的线路, 用双绞线或电话线, 下行大于上行</li><li>使用频分复用, 低25kHz用于话音, 使用回声抵消或FDM双向传输</li><li>FDM</li></ul></li></ul><table><thead><tr><th>话音POTS</th><th>上行流</th><th>下行流</th></tr></thead><tbody><tr><td>0-20kHz</td><td>25-200kHz</td><td>250-1000kHz</td></tr></tbody></table><ul><li>更多xDSL<ul><li>HDSL: 高数据率数字用户线路, 两根双绞线</li><li>SDSL：单线数字用户线路</li><li>VDSL：甚高数据率数字用户线路</li></ul></li></ul><h1 id="第九章-交换"><a href="#第九章-交换" class="headerlink" title="第九章: 交换"></a>第九章: 交换</h1><h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><ul><li>概念<ul><li>公共电话网PSTN, 为话音通话开发, 也能处理数字数据</li></ul></li><li>流程<ul><li>建立通路, 通信, 断开通路</li></ul></li></ul><h3 id="空分交换"><a href="#空分交换" class="headerlink" title="空分交换"></a>空分交换</h3><ul><li>Crossbar Switch Fabric<ul><li>两两交叉, $n$入$n$出, 将有$n^2$个交叉点, 而至多用$n$个交叉点</li><li>非阻塞</li></ul></li><li>3-Stage Space Division Switching</li></ul><table><thead><tr><th>第一级</th><th>第二级</th><th>第三级</th></tr></thead><tbody><tr><td>$\frac{N}{n}$个$n\times m$单元</td><td>$m$个$n\times n$单元</td><td>$\frac{N}{n}$个$N\times m$单元</td></tr></tbody></table><ul><li><p>$m\geq 2n - 1$时非阻塞, 否则阻塞</p></li><li><p>Banyan Switch<br><img src="BanyanSwitch.jpg" alt="BanYan Switch"></p><ul><li>利用输入端的二进制编码来构建多层空分交换, $N = 2^k$, 则共有$k$层, 每层$2^{k-1}=N/2$个$2\times 2$单元</li><li>每层接线按照输入端二进制编号的各位连接</li><li>$N=8$, 是三级空分交换, 此时算得非阻塞</li></ul></li></ul><h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><ul><li>概念<ul><li>数据交换, 大数据段分为较小的数据包, 数据包包括用户数据和控制信息</li><li>包途径多个节点, 在节点处被缓存, 链路可用将被发送</li></ul></li></ul><h3 id="数据报交换"><a href="#数据报交换" class="headerlink" title="数据报交换"></a>数据报交换</h3><ul><li>概念<ul><li>每个数据包被当作单独的数据包对待, 独自寻路, 不受此前包的影响</li></ul></li><li>特性<ul><li>无建立时间</li><li>灵活</li><li>可靠</li></ul></li></ul><h3 id="虚电路交换"><a href="#虚电路交换" class="headerlink" title="虚电路交换"></a>虚电路交换</h3><ul><li>概念<ul><li>先建立路径(虚拟), 此后发送数据包均按此路径发送</li></ul></li><li>特性<ul><li>网络可提供排序和错误控制(包按序发送)</li><li>传送速度更快(无需选择路由)</li><li>较不可靠</li></ul></li></ul><h2 id="异步传输模式ATM"><a href="#异步传输模式ATM" class="headerlink" title="异步传输模式ATM"></a>异步传输模式ATM</h2><ul><li>概念<ul><li>信源: 小的, 固定长度的分组, 减小时延</li><li>面向连接的分组交换技术: 提供类似电路交换网络的性能, 同时有提供分组交换的灵活性和效率</li><li>数据率: 高</li><li>支持数据, 话音, 视频</li><li>传输: 基于优先级和QoS(服务质量), 用户可选择服务等级</li></ul></li><li>ATM逻辑连接<ul><li>虚通路: VCC, 类似虚电路, 速率可变, 全双工, 定长信源流</li><li>虚通道连接: VPC, 一群具有相同端点的虚通路</li><li><h2 id="本章习题"><a href="#本章习题" class="headerlink" title="本章习题"></a>本章习题</h2></li></ul></li><li>性能分析</li></ul><table><thead><tr><th>交换方式</th><th>建立时间$t_{build}$</th><th>实际传输的数据$L’$</th><th>传输时间$t_{trans}$</th><th>节点延迟$t_{delay}$</th><th>总时间$t$</th></tr></thead><tbody><tr><td>电路交换</td><td>$S$</td><td>$L$</td><td>$\frac{L}{B}$</td><td>$DN$</td><td>$S + DN + \frac{L}{B}$</td></tr><tr><td>数据报交换</td><td>$0$</td><td>$P\lceil\frac{L}{P-H}\rceil$</td><td>$P\lceil\frac{L}{P-H}\rceil/B$</td><td>$DN$</td><td>$DN + P\lceil\frac{L}{P-H}\rceil/B$</td></tr><tr><td>虚电路交换</td><td>$S$</td><td>$P\lceil\frac{L}{P-H}\rceil$</td><td>$P\lceil\frac{L}{P-H}\rceil/B$</td><td>$DN$</td><td>$S + DN + P\lceil\frac{L}{P-H}\rceil/B$</td></tr></tbody></table><h1 id="第十章-蜂窝无线网络"><a href="#第十章-蜂窝无线网络" class="headerlink" title="第十章: 蜂窝无线网络"></a>第十章: 蜂窝无线网络</h1><h2 id="蜂窝无线网络的概念"><a href="#蜂窝无线网络的概念" class="headerlink" title="蜂窝无线网络的概念"></a>蜂窝无线网络的概念</h2><ul><li>蜂窝构成<ul><li>区域被分为蜂窝</li><li>蜂窝使用低功率发送器: 100W以下, 控制功率防止频率逃逸</li><li>每个蜂窝一个基站: 发送, 接收, 控制单元</li><li>相邻蜂窝频率不同: 防止干扰</li><li>蜂窝形状为六边形: 蜂窝半径为$R$, 则相邻蜂窝中心距离$\sqrt{3}R$</li></ul></li><li>频率重用<ul><li>$D$: 使用相同频率的蜂窝(同波道)中心之间的距离</li><li>$R$: 蜂窝半径</li><li>$d$: 相邻蜂窝中心之间的距离</li><li>$N$: 重复模式中的蜂窝数量, 重用系数, 其可能值仅有这些<br>$$N=I^2+J^2+(I\times J)\quad I,J\in\mathbb{N}$$</li><li>有以下关系式<br>$$\frac{D}{R}=\sqrt{3N}$$</li></ul></li><li>增大容量<ul><li>添加新信道: 建立时不会用完全部的信道, 添加新信道满足扩张</li><li>频率借用: 拥塞的蜂窝可以从邻近的空闲蜂窝借用频率, 也可动态指派频率给各个蜂窝</li><li>蜂窝分裂: 大蜂窝在使用率高的地区分裂为小蜂窝, 其功率低覆盖面积小</li><li>蜂窝扇区化: 定向天线, 蜂窝被划分为楔形扇区, 指派蜂窝频率的一个真子集</li><li>微蜂窝: 功率和覆盖范围超小的蜂窝, 建筑物内, 公路旁, 城市街道等\</li></ul></li></ul><h2 id="蜂窝系统的操作"><a href="#蜂窝系统的操作" class="headerlink" title="蜂窝系统的操作"></a>蜂窝系统的操作</h2><ul><li>信道<ul><li>控制信道: 交换 建立与维持呼叫的信息</li><li>业务信道: 承载用户之间话音或数据的连接</li></ul></li><li>呼叫典型步骤 MTSO</li></ul><table><thead><tr><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>移动单元初始化</td><td>定期扫描, 选择使用最强的基站建立控制信道, 并与控制该蜂窝的MTSO握手, 之后监听是否有寻呼</td></tr><tr><td>移动台发起的呼叫</td><td>移动单元通过在已选的建立信道上, 若信道空闲, 发送被叫单元的号码来发起呼叫</td></tr><tr><td>寻呼</td><td>MTSO根据被叫号码, 向某些基站发送寻呼信息</td></tr><tr><td>呼叫接收</td><td>被叫单元识别寻呼, 向基站发通知 -&gt; 基站向MTSO发通知 -&gt; MTSO建立电路, 选两个业务信道, 通知两个基站 -&gt; 基站通知单元</td></tr><tr><td>呼叫进行中</td><td>话音或数据信号: 单元 <-> 基站  <-> MTSO <-> 基站 <-> 单元</-></-></-></-></td></tr><tr><td>切换</td><td>移动单元跨蜂窝移动, 业务信道切换到指派给新蜂窝的业务信道, 不警告用户</td></tr><tr><td>呼叫阻塞</td><td>没有空闲业务信道, 将重试数次, 耗尽次数返回忙音</td></tr><tr><td>呼叫终止</td><td>用户挂机, MTSO得到通知, 释放业务信道</td></tr><tr><td>呼叫掉线</td><td>信号强度低于最小信号强度, MTSO将得到通知, 释放信道</td></tr><tr><td>连接固定用户</td><td>MTSO与公用电话交换网络连接</td></tr><tr><td>连接远程用户</td><td>MTSO通过电话网或专用线路, 与远程MTSO连接, 并为二者用户建立连接</td></tr></tbody></table><h2 id="移动无线电传播效应"><a href="#移动无线电传播效应" class="headerlink" title="移动无线电传播效应"></a>移动无线电传播效应</h2><ul><li>信号强度<ul><li>太强: 同信道干扰</li><li>太弱: 不足以维持连接</li></ul></li><li>衰落</li></ul><h2 id="移动环境中的衰落"><a href="#移动环境中的衰落" class="headerlink" title="移动环境中的衰落"></a>移动环境中的衰落</h2><ul><li>三种重要的传播机制<ul><li>反射</li><li>衍射</li><li>散射</li></ul></li><li>多径传播效应<ul><li>主脉冲 -&gt; 主脉冲+多个副脉冲: 相当于噪声</li></ul></li><li>衰落的类型</li></ul><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>快衰落</td><td>振幅的变化也高达20一30dB这种类型的迅速衰落变化</td></tr><tr><td>慢衰落</td><td>接收功率除了出现快速波动之外, 接收到的平均功率水平也会变化</td></tr><tr><td>平坦衰落</td><td>接收信号的所有频率成分的波动是同时的且成相同比例的</td></tr><tr><td>选择性衰落</td><td>对一个无线电信号的不同頻谱成分的影响是不同的</td></tr></tbody></table><h2 id="四代蜂窝网络"><a href="#四代蜂窝网络" class="headerlink" title="四代蜂窝网络"></a>四代蜂窝网络</h2><table><thead><tr><th>技术</th><th>最初设计时间</th><th>应用时间</th><th>服务</th><th>数据率</th><th>复用技术</th><th>核心网络</th><th>更多</th></tr></thead><tbody><tr><td>1G</td><td>1970</td><td>1984</td><td>模拟话音</td><td>1.9kbps</td><td>FDMA</td><td>PSTN</td></tr><tr><td>2G</td><td>1980</td><td>1991</td><td>数字话音</td><td>9.6kbps-14.4kbps</td><td>(GSM)TDMA, CDMA</td><td>PSTN</td><td>EDGE, 均衡, 交织, RAKE接收, 功率控制</td></tr><tr><td>2.5G</td><td>1985</td><td>1999</td><td>大容量分组化数据</td><td>384kbps-2Mbps</td><td>TDMA,CDMA</td><td>PSTN, 分组网络</td><td>多用户检测, 智能天线,  Turbo 编码, 多媒体数据</td></tr><tr><td>4G</td><td>2000</td><td>2012</td><td>完全基于IP</td><td>20~100Mbps-1Gbps</td><td>OFDMA, SC-FDMA</td><td>IP干线网</td><td>自适应调制编码, 混合自动重传, MIMO</td></tr></tbody></table><h2 id="LTE-Advanced-传输特性"><a href="#LTE-Advanced-传输特性" class="headerlink" title="LTE-Advanced 传输特性"></a>LTE-Advanced 传输特性</h2><ul><li>FDD与TDD<ul><li>FDD: 成对的上下行信道, 中间有保护频带</li><li>TDD: 同一频带, 时域上交替</li></ul></li><li>载波聚合<ul><li>带内连续: 相邻的信道被看作被放大的信道</li><li>带内不连续: 多个分量载波CC在带内不连续, 需要多个收发器</li><li>带间不连续: 多个收发器</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据通信: 期末复习&lt;br&gt;
    
    </summary>
    
    
      <category term="Course" scheme="https://Maxwell-lyu.github.io/tags/Course/"/>
    
      <category term="Data Communication" scheme="https://Maxwell-lyu.github.io/tags/Data-Communication/"/>
    
  </entry>
  
  <entry>
    <title>Probability Ch7</title>
    <link href="https://Maxwell-lyu.github.io/2019/05/23/Learn-PMS-20190523-PMS-07/"/>
    <id>https://Maxwell-lyu.github.io/2019/05/23/Learn-PMS-20190523-PMS-07/</id>
    <published>2019-05-23T00:45:09.000Z</published>
    <updated>2019-06-13T01:06:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>Probability Course in 2019 Spring<br><a id="more"></a> </p><h1 id="参数估计"><a href="#参数估计" class="headerlink" title="参数估计"></a>参数估计</h1><h2 id="矩估计"><a href="#矩估计" class="headerlink" title="矩估计"></a>矩估计</h2><ul><li><strong>计算步骤</strong><ol><li>求总体的各阶原点矩，用参数表示<br>$$\mu_i=g_i(\theta_1,\theta_2,\cdots,\theta_k)$$</li><li>解方程组，用总体矩表示参数<br>$$\theta_i=h_i(\mu_1,\mu_2,\cdots,\mu_k)$$</li><li>用样本的矩代替总体矩，得到参数的表示<br>$$\theta_i=h_i(\mu_1,\mu_2,\cdots,\mu_k)$$  </li></ol></li></ul><h2 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h2><ul><li><strong>计算步骤</strong><ol><li>列出以下式子<br>$$L(x_1,x_2,\cdots,x_n;\hat{\theta})=\max_{\theta\in\Theta}L(x_1,x_2,\cdots,x_n;\theta)=\prod_{i=1}^np(x_i;\theta)$$</li><li>上式取对数, 得到似然方程组<br>$$\frac{\partial\ln L(\theta)}{\partial\theta}=\sum_{i=1}^n\frac{\partial\ln p(x_i;\theta)}{\partial\theta}=0$$</li><li>解出参数，注意参数本身的范围</li></ol></li></ul><h2 id="估计量的评价标准"><a href="#估计量的评价标准" class="headerlink" title="估计量的评价标准"></a>估计量的评价标准</h2><ol><li>无偏性<br>$$E[\hat{\theta}(X_1,X_2,\cdots,X_n)]=\theta$$</li><li>均方误差<br>$$M(\hat{\theta},\theta)=E(\hat{\theta}-\theta)^2=D(\hat{\theta})+(E\hat{\theta}-\theta)^2$$</li><li>一致性<br>$$\hat{\theta}_n\stackrel{P}{\to}\theta$$<ol><li>无偏, 方差极限为0</li></ol></li></ol><h2 id="区间估计"><a href="#区间估计" class="headerlink" title="区间估计"></a>区间估计</h2><ol><li><p>基本概念与枢纽变量法</p><ul><li><strong>区间估计</strong><br>$$P(\hat{\theta}_1&lt;\theta&lt;\hat{\theta}_1)=1-\alpha$$<br>分别为置信下限, 置信上限, 置信系数</li><li><strong>计算方法</strong><ol><li>找一个样本函数, 包含待估参数, 并且分布已知</li><li>根据此分布, 找到常数$a$, $b$, 使得<br>$$P(a&lt;U&lt;b)=1-\alpha$$</li><li>利用不等式解出$\theta$范围</li></ol></li><li><strong>双边与单边</strong><ol><li>置信度$1-\alpha$</li><li>双边需要取$\alpha/2$或$1-\alpha/2$</li><li>单边直接用$\alpha$或$1-\alpha$</li></ol></li></ul></li><li><p>正态总体$N(\mu, \sigma^2)$中均值$\mu$的置信区间  </p><ul><li>$\sigma^2$已知<br>$$\bar{X}\pm u_{\alpha/2}\frac{\sigma}{\sqrt{n}}$$</li><li>$\sigma^2$未知<br>$$\bar{X}\pm t_{\alpha/2}(n-1)\times\frac{S}{\sqrt{n}}$$</li></ul></li><li>正态总体$N(\mu, \sigma^2)$中方差$\sigma^2$的置信区间<br>$$(\frac{(n-1)S^2}{\chi^2_{\alpha/2}(n-1)},\frac{(n-1)S^2}{\chi^2_{1-\alpha/2}(n-1)})$$</li><li>两个正态总体$N(\mu_1, \sigma_1^2)$, $N(\mu_2, \sigma_2^2)$中均值差$\mu_1-\mu_2$的置信区间<ul><li>$\sigma_i^2$已知<br>$$\bar{X}-\bar{Y}\pm u_{\alpha/2}\sqrt{\frac{\sigma_1^2}{n_1}+\frac{\sigma_2^2}{n_2}}$$</li><li>$\sigma_i^2$未知<br>$$\bar{X}-\bar{Y}\pm t_{\alpha/2}(n_1+n_2-2)\times S_w\sqrt{\frac{1}{n_1}+\frac{1}{n_2}}$$<br>$$S_w=\sqrt{\frac{(n_1-1)S_1^2+(n_2-1)S_2^2}{n_1-n_2-2}}$$</li></ul></li><li>两个正态总体$N(\mu_1, \sigma_1^2)$, $N(\mu_2, \sigma_2^2)$方差比$\sigma_1^2/\sigma_2^2$的置信区间<br>$$(\frac{S_1^2}{S_2^2}\frac{1}{F_{\alpha/2}(n_1-1,n_2-1)}, \frac{S_1^2}{S_2^2}\frac{1}{F_{1-\alpha/2}(n_1-1,n_2-1)})$$</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Probability Course in 2019 Spring&lt;br&gt;
    
    </summary>
    
    
      <category term="Course" scheme="https://Maxwell-lyu.github.io/tags/Course/"/>
    
      <category term="Probability and Mathematical Statistics" scheme="https://Maxwell-lyu.github.io/tags/Probability-and-Mathematical-Statistics/"/>
    
  </entry>
  
  <entry>
    <title>Probability Ch6</title>
    <link href="https://Maxwell-lyu.github.io/2019/05/09/Learn-PMS-20190509-PMS-06/"/>
    <id>https://Maxwell-lyu.github.io/2019/05/09/Learn-PMS-20190509-PMS-06/</id>
    <published>2019-05-09T01:14:19.000Z</published>
    <updated>2019-06-17T01:18:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>Probability Course in 2019 Spring<br><a id="more"></a> </p><h1 id="统计量与抽样分布"><a href="#统计量与抽样分布" class="headerlink" title="统计量与抽样分布"></a>统计量与抽样分布</h1><h2 id="总体与样本"><a href="#总体与样本" class="headerlink" title="总体与样本"></a>总体与样本</h2><h3 id="总体与个体"><a href="#总体与个体" class="headerlink" title="总体与个体"></a>总体与个体</h3><ul><li><strong>总体</strong>  所研究的对象的全体</li><li><strong>个体</strong>  总体当中的每个元素</li></ul><h3 id="样本"><a href="#样本" class="headerlink" title="样本"></a>样本</h3><ul><li><strong>样本</strong>  为了对总体$X$进行研究, 通常要从总体中随机地抽取一些个体, 这些个体就成为样本</li><li><strong>抽样</strong>  抽得样本的过程</li><li><strong>样本容量</strong>  样本中个体的数量称为样本容量</li><li><strong>样本值</strong>  设对总体进行了$n$次观测, 得到一组数据$(x_1,x_2,\cdots,x_n)$</li><li><strong>随机抽样的要求: 简单随机样本</strong><ol><li>代表性</li><li>独立性</li><li>分布函数<br>$$p(x_1,x_2,\cdots,x_n)=\prod_{i=1}^np(x_i)$$</li></ol></li></ul><h2 id="统计量与抽样分布-1"><a href="#统计量与抽样分布-1" class="headerlink" title="统计量与抽样分布"></a>统计量与抽样分布</h2><ul><li><p><strong>定义6.1</strong><br>设$(X_1,X_2,\cdots,X_n)$为总体$X$的一个样本, $T(x_1,x_2,\cdots,x_n)$为不含任何未知参数的函数, 则称$T(x_1,x_2,\cdots,x_n)$为一个统计量</p></li><li><p><strong>样本均值</strong><br>$$\bar{X}=\frac{1}{n}\sum_{i-1}^nX_i$$</p></li><li><p><strong>样本方差</strong><br>$$S^2=\frac{1}{n-1}\sum_{i=1}^n(X_i-\bar{X})^2$$<br>$$S^{*2}=\frac{1}{n}\sum_{i=1}^n(X_i-\bar{X})^2=\frac{1}{n}\sum_{i=1}^nX_i^2-\bar{X}^2$$</p></li><li><p><strong>样本标准差</strong><br>$$S=\sqrt{S^2}$$</p></li></ul><h2 id="正态总体"><a href="#正态总体" class="headerlink" title="正态总体"></a>正态总体</h2><ol><li>$\chi^2$分布<br>$X_i\sim N(0,1)$<br>$$\chi^2=\sum_{i=1}^nX_i^2\sim \chi^2(n)$$</li><li>$t$分布<br>$X\sim N(0,1), Y\sim\chi^2(n)$<br>$$T=\frac{X}{\sqrt{Y/n}}\sim t(n)$$</li><li>$F$分布<br>$U\sim\chi^2(n_1),V\sim\chi^2(n_2)$<br>$$F=\frac{U/n_1}{V/n_2}\sim F(n_1,n_2)$$</li><li>上$\alpha$分位点$\lambda_\alpha$<br>$$P(X&gt;\lambda_\alpha)=\alpha$$</li><li>要记忆的式子  <ul><li>$$\bar{X}\sim N(\mu, \frac{\sigma^2}{n})$$</li><li>$$\frac{(n-1)S_{n-1}^2}{\sigma^2}=\sum_{i=1}^n(\frac{X_i-\bar{X}}{\sigma})\sim\chi^2(n-1)$$</li><li>$$\sum_{i=1}^n(\frac{X_i-\mu}{\sigma})\sim\chi^2(n)$$</li><li>$\bar{X}$与$S_{n-1}^2$相互独立</li><li>$$T=\frac{\sqrt{n}(\bar{X}-\mu)}{S_{n-1}}\sim t(n-1)$$</li><li>$$T’=\frac{\sqrt{n-1}(\bar{X}-\mu)}{S_{n}}\sim t(n-1)$$</li><li>$$F=\frac{S_1^2/\sigma_1^2}{S_2^2/\sigma_2^2}\sim F(n_1-1, n_2-1)$$</li><li>$$U=\frac{(\bar{X}-\bar{Y})-(\mu_1-\mu_2)}{\sqrt{\frac{\sigma_1^2}{n_1}+\frac{\sigma_2^2}{n_2}}}\sim N(0,1)$$</li></ul></li></ol><ul><li><strong>定理6.2</strong><ol><li>$\bar{X}\sim N(\mu, \frac{\sigma^2}{n})$</li><li>$(n-1)\frac{S^2}{\sigma^2}\sim \chi^2(n-1)$</li><li>$\bar{X}$与$S^2$相互独立</li></ol></li><li><strong>推论6.1</strong><br>$$T=\frac{\sqrt{n}(\bar{X}-\mu)}{S}\sim t(n-1)$$</li><li><strong>推论6.2</strong><br>$$F=\frac{S_1^2/\sigma_1^2}{S_2^2/\sigma_2^2}\sim F(n_1-1,n_2-1)$$</li><li><strong>推论6.3</strong><br>$$T=\sqrt{\frac{n_1+n_2-2}{\frac{1}{n_1}+\frac{1}{n_2}}}\frac{(\bar{X}-\bar{Y})-(\mu_1-\mu_2)}{\sqrt{(n_1-1)S_1^2+(n_2-1)S_2^2}}\sim t(n_1+n_2-2)$$</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Probability Course in 2019 Spring&lt;br&gt;
    
    </summary>
    
    
      <category term="Course" scheme="https://Maxwell-lyu.github.io/tags/Course/"/>
    
      <category term="Probability and Mathematical Statistics" scheme="https://Maxwell-lyu.github.io/tags/Probability-and-Mathematical-Statistics/"/>
    
  </entry>
  
  <entry>
    <title>Data Communication Mid-Term</title>
    <link href="https://Maxwell-lyu.github.io/2019/04/29/Learn-DC-20190429-DC-MID/"/>
    <id>https://Maxwell-lyu.github.io/2019/04/29/Learn-DC-20190429-DC-MID/</id>
    <published>2019-04-29T03:37:44.000Z</published>
    <updated>2019-09-02T01:28:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据通信：期中复习"><a href="#数据通信：期中复习" class="headerlink" title="数据通信：期中复习"></a>数据通信：期中复习</h1><h2 id="第二章：网络体系结构"><a href="#第二章：网络体系结构" class="headerlink" title="第二章：网络体系结构"></a>第二章：网络体系结构</h2><ul><li>通信模型<ul><li>源系统（源点，发送器），传输系统，目的系统（接收器，终点)</li></ul></li><li>传输方式<ul><li>单工：一个信道，只能单向</li><li>半双工：一个信道，同一时间只能上/下行，有选择器</li><li>全双工：两个信道，同时上下行</li></ul></li><li>数字通信与模拟通信<ul><li>数字系统：数字-数字编码，模拟-数字编码</li><li>模拟系统：模拟信号以固有频率基带传输（不编码），频谱搬移后传输（模拟-模拟编码）</li><li>混成系统：同一系统既包含模拟也包含数字</li></ul></li><li>网络体系结构：TCP/IP<ul><li>应用层，传输层，网际层，数据链路层，物理层</li></ul></li><li>套接字及其类型<ul><li>流套接字：TCP：可靠，按时</li><li>数据包套接字：UDP：快速乱序无保证</li><li>原始套接字：IP：直接访问底层</li></ul></li></ul><h2 id="第三章：数据传输"><a href="#第三章：数据传输" class="headerlink" title="第三章：数据传输"></a>第三章：数据传输</h2><ul><li>概念与术语<ul><li>导向媒体：电磁波沿某一物理路径前进（光纤，双绞线，同轴电缆<ul><li>点对点：直连链路</li><li>多点：共享</li></ul></li><li>非导向媒体：无线传输，不引导传输方向（空气，真空，海水</li></ul></li><li>数据与信号<ul><li>数据：信源产生，可能为模拟或数字</li><li>信号：经过调制，电磁信号居多</li></ul></li><li>周期信号的傅里叶级数表示<ul><li>傅里叶表示：<br>$$x(t)=\frac{A_0}{2}+\sum_{n=1}^{\infty}(A_n\cos(2\pi nf_0t)+B_n\sin(2\pi nf_0t))$$<br>$$A_n = \frac{2}{T}\int_{0}^{T}x(t)\cos(2\pi nf_0t)dt$$<br>$$B_n = \frac{2}{T}\int_{0}^{T}x(t)\sin(2\pi nf_0t)dt$$</li><li>方波的傅里叶表示<br>$$f(x)=\frac{4}{\pi}\sum_{n=2k-1}^\infty \frac{1}{n}\sin(\frac{n\pi x}{L})$$</li></ul></li><li>信号功率计算<ul><li>任意时段功率：<br>$$P_x=\frac{1}{t_2-t_1}\int_{t_1}^{t_2}|x(t)|^2dt$$</li><li>周期平均功率<br>$$P=\frac{1}{T}\int_{0}^{T}|x(t)|^2dt$$   </li></ul></li><li>信号的频谱与带宽<ul><li>频谱：信号的频率范围</li><li>绝对带宽：频谱宽度，最大减最小</li><li>有效带宽：包含绝大多数能量的带宽，某频率区间的功率积分是总功率的一半（-3dB）</li><li>直流分量：频率为0的部分</li></ul></li><li>数据率与带宽的关系<ul><li>$R_b=2f$，$R_b$数据率，$f$带宽</li></ul></li><li>模拟/数字数据与模拟/数字传输<ul><li>模拟信号：放大器</li><li>数字信号：转发器</li></ul></li><li>数字信号传输的优势<ul><li>大规模集成电路</li><li>数据完整性</li><li>容量利用率</li><li>安全和保密</li><li>综合性、存储</li></ul></li><li>传输损伤<ul><li>衰减：放大器与转发器解决</li><li>失真<ul><li>衰减失真：高频失真多，衰减均衡和高频高倍放大解决</li><li>时延失真：中心频率附近传输快，仅限数字信号，码间串扰</li></ul></li><li>噪声<ul><li>信噪比：$SNR_{db}=1o\lg{\frac{S}{N}}$</li><li>热噪声：$N_0=kT$，$k$玻尔兹曼常量，$T$热力学温度</li><li>互调噪声、串扰（双绞线扭绞）、冲激噪声</li></ul></li></ul></li><li>信道容量：最大数据传输速率<ul><li>数据率bps，带宽Hz，噪声，误码率</li><li>奈奎斯特带宽：信道无噪声时：$C=2B\log_2{M}$，$M$指信号的电平数</li><li>香农容量公式：只有热噪声时：$C=B\log_2(1+SNR)$，$SNR=10^{0.1SNR_{db}}$为信噪比</li></ul></li></ul><h2 id="第四章：传输媒体"><a href="#第四章：传输媒体" class="headerlink" title="第四章：传输媒体"></a>第四章：传输媒体</h2><ul><li>光纤<ul><li>优势：容量大，体积小，衰减小，电磁隔离，转发器间隔远</li><li>折射率分类：<ul><li>阶跃型：折射率阶跃，会有失真</li><li>渐变型：光路周期性汇聚</li></ul></li><li>模式分类<ul><li>单模、多模</li></ul></li></ul></li><li>无线传播：高频天线小<ul><li>地波：-2MHz</li><li>天波：2MHz-30MHz</li><li>视距传播：30MHz-</li></ul></li><li>视距传播损伤<ul><li>自由空间损耗模型<br>$$L=10\lg(\frac{4\pi d}{\lambda})^2dB$$</li></ul></li></ul><h2 id="第五章：信号编码技术"><a href="#第五章：信号编码技术" class="headerlink" title="第五章：信号编码技术"></a>第五章：信号编码技术</h2><ul><li>编码与调制技术<ul><li>数字信号传输：数字或模拟数据-&gt;(编码器)-&gt;数字信号-&gt;(解码器)-&gt;原数据</li><li>模拟信号传输：数字或模拟基带信号<->(调制解调器)<->模拟信号</-></-></li></ul></li><li>数字信号编码格式<ul><li>NRZ-L：高电平0，低电平1</li><li>NRZI：区间起始无变化0，区间起始有变化1</li><li>双极性AMI：零电平0，正电平负电平1交替出现</li><li>伪三进制：正电平负电平0交替出现，零点平1</li><li>曼彻斯特：区间正中高到低0，低到高1</li><li>差分曼彻斯特：区间正中总是变化，区间起始变化0，区间起始不变1</li></ul></li><li>扰码<ul><li>扰码产生替代连续电压的序列</li><li>填充序列：提供足够的信息用于同步，可被识别替换还原，长度相同</li><li>目标：不含直流，定时信息丰富，不降低数据率，可检错，易于判断还原</li></ul></li><li>HDB3：会给出编码方式  </li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">自上一次替换后双极性</th><th style="text-align:center">脉冲（比特1）数</th></tr></thead><tbody><tr><td style="text-align:center">前面脉冲的极性</td><td style="text-align:center">奇数</td><td style="text-align:center">偶数</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">000-</td><td style="text-align:center">+00+</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">000+</td><td style="text-align:center">-00-</td></tr></tbody></table><ul><li>调制技术：开关键控载波<ul><li>振幅ASK：01由振幅表示<ul><li>相干解调：乘上同周期的信号，低通滤波</li></ul></li><li>频移FSK：不同频率表示01<ul><li>应用：话音，高频无线电（天波，同轴电缆局域网</li></ul></li><li>相移PSK：不同相位表示信息<ul><li>二进制相移键控：$0,\pi$</li><li>QPSK：四个相位，$\pm\frac{\pi}{4},\pm\frac{3\pi}{4}$</li></ul></li><li>正交调幅QAM：两个载波正交（差90相位，分别ASK，两个独立信号</li><li>补点公式：<ul><li>ASK，PSK<br>$$B_T=(1+r)R$$</li><li>FSK<br>$$B_T=2\Delta f+(1+r)R$$</li><li>MPSK<br>$$B_T=\frac{1+r}{\log_2M}R$$</li><li>MFSK<br>$$B_T=\frac{(1+r)M}{\log_2M}R$$</li></ul></li></ul></li><li>模拟数据数字化<ul><li>脉码调制PCM<ul><li>定时采样，每次采样有几个bit进行量化</li><li>压扩函数：非线性编码，振幅低的地方密集</li></ul></li><li>增量调制DM<ul><li>近似信号的导数，有过载噪声</li></ul></li></ul></li><li>模拟调制系统<ul><li>模拟数据加载到载波，利于传输，允许频分复用，扩展带宽，抗干扰</li><li>调幅AM<ul><li>数据与载波相加<br>$$s_{AM}=[A_0+m(t)]\cos\omega_ct$$<br>归一化，小于1时可以包络解调，否则只能正交解调<br>$$s(t)=[1+n_ax(t)]\cos2\pi f_ct, n_a&lt;1$$</li></ul></li><li>调频FM<br>$$s(t)=A_c\cos[2\pi f_c+\varphi(t)],\varphi’(t)=n_fm(t)$$</li><li>调相PM<br>$$s(t)=A_c\cos[2\pi f_c+\varphi(t)],\varphi(t)=n_pm(t)$$<br>与FM转化：频率可定义为相位变化率，因此将PM后面的积分即可得到FM</li></ul></li></ul><h2 id="第六章：差错检测与矫正"><a href="#第六章：差错检测与矫正" class="headerlink" title="第六章：差错检测与矫正"></a>第六章：差错检测与矫正</h2><ul><li>奇偶校验<ul><li>偶校验：末尾加校验比特，整个字符中的1的个数为偶数</li></ul></li><li>因特网校验和<ul><li>两个数字视为无符号二进制整数，相加，高位进位就在最低位加1</li></ul></li><li>循环冗余检验CRC<ul><li>k位信息，生成n-k位比特，作为检验序列（会给出公式，公式最高位$X^{n-k}$</li></ul></li><li>块码原理<ul><li>2k+1的距离，最多检2k=$d_{min}-1$，最多纠k=$\lfloor\frac{d_{min}-1}{2}\rfloor$</li><li>冗余度：(n-k)/k，码字共n位，k个信息位</li><li>编码率：k/n</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据通信：期中复习&quot;&gt;&lt;a href=&quot;#数据通信：期中复习&quot; class=&quot;headerlink&quot; title=&quot;数据通信：期中复习&quot;&gt;&lt;/a&gt;数据通信：期中复习&lt;/h1&gt;&lt;h2 id=&quot;第二章：网络体系结构&quot;&gt;&lt;a href=&quot;#第二章：网络体系结构&quot; cla
      
    
    </summary>
    
    
      <category term="Course" scheme="https://Maxwell-lyu.github.io/tags/Course/"/>
    
      <category term="Data Communication" scheme="https://Maxwell-lyu.github.io/tags/Data-Communication/"/>
    
  </entry>
  
  <entry>
    <title>Probability Ch5</title>
    <link href="https://Maxwell-lyu.github.io/2019/04/28/Learn-PMS-20190428-PMS-05/"/>
    <id>https://Maxwell-lyu.github.io/2019/04/28/Learn-PMS-20190428-PMS-05/</id>
    <published>2019-04-28T00:01:48.000Z</published>
    <updated>2019-06-16T02:21:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>Probability Course in 2019 Spring<br><a id="more"></a> </p><h1 id="极限理论"><a href="#极限理论" class="headerlink" title="极限理论"></a>极限理论</h1><h2 id="大数定律"><a href="#大数定律" class="headerlink" title="大数定律"></a>大数定律</h2><ul><li><strong>定义5.1</strong><br>设$X_1,X_2,\cdots, X_n$为一列随机变量, 若存在随机变量$X$, 使得任意给定的$\epsilon&gt;0$,<br>$$-$$<br>$$\lim_{n\to\infty}P(|\frac{1}{n}\sum_{k=1}^nX_k - \frac{1}{n}\sum_{k=1}^nEX_k|\geq\epsilon)=0$$<br>则称随机变量序列$\{X_n\}$依概率收敛于随机变量$X$, 记为$X_n\stackrel{P}{\to}X$</li><li><strong>定义5.2</strong><br>大数定律: 变量平均值依概率收敛于期望平均值<br>$$\frac{1}{n}\sum_{k=1}^nX_k\stackrel{P}{\to}\frac{1}{n}\sum_{k=1}^nEX_k$$</li><li><strong>马尔可夫大数定律</strong><br>$$\lim_{n\to\infty}\frac{1}{n^2}D(\sum_{k=1}^nX_k)\to 0$$</li><li><strong>切比雪夫大数定律</strong><br>$$\exists C, \forall k, D(X_k)\leq C$$</li><li><strong>独立同分布大数定律</strong><br>$$X_k\textrm{独立同分布},EX_k=\mu,D(X_k)=\sigma^2&lt;\infty$$</li><li><strong>贝努里大数定律</strong><br>事件$A$发生的频率依概率收敛到事件$A$发生的概率<br>$$\frac{\mu_n}{n}\stackrel{P}{\to}p$$</li></ul><h2 id="中心极限定理"><a href="#中心极限定理" class="headerlink" title="中心极限定理"></a>中心极限定理</h2><ol><li>$\{X\}$独立同分布, 则$\sum_{k=1}^nX_k$近似服从正态分布</li><li>$X$服从二项分布, $n$足够大, 则$X$近似服从正态分布</li><li>$X$服从泊松分布, $n$足够大, 则$X$近似服从正态分布</li><li>分布的标准化: $Y=\frac{X-\mu}{\sigma}$</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Probability Course in 2019 Spring&lt;br&gt;
    
    </summary>
    
    
      <category term="Course" scheme="https://Maxwell-lyu.github.io/tags/Course/"/>
    
      <category term="Probability and Mathematical Statistics" scheme="https://Maxwell-lyu.github.io/tags/Probability-and-Mathematical-Statistics/"/>
    
  </entry>
  
  <entry>
    <title>Problem Solving IV 10</title>
    <link href="https://Maxwell-lyu.github.io/2019/04/27/Learn-PS-20190427-PS-IV-10/"/>
    <id>https://Maxwell-lyu.github.io/2019/04/27/Learn-PS-20190427-PS-IV-10/</id>
    <published>2019-04-27T11:10:38.000Z</published>
    <updated>2019-04-27T12:34:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>Key definitions and theorems in Ch2.3 in Algorithms for Hard Problems.<br><a id="more"></a> </p><h1 id="Chapter-2-Elementary-Fundamentals"><a href="#Chapter-2-Elementary-Fundamentals" class="headerlink" title="Chapter 2: Elementary Fundamentals"></a>Chapter 2: Elementary Fundamentals</h1><h2 id="Fundamentals-of-Algorithmics"><a href="#Fundamentals-of-Algorithmics" class="headerlink" title="Fundamentals of Algorithmics"></a>Fundamentals of Algorithmics</h2><h3 id="Alphabets-Words-and-Languages"><a href="#Alphabets-Words-and-Languages" class="headerlink" title="Alphabets, Words, and Languages"></a>Alphabets, Words, and Languages</h3><ul><li><strong>Alphabet</strong>: Any non-empty, finite set is called an alphabet.   </li><li><strong>Symbol</strong>: Every element of an alphabet $\Sigma$ is called a symbol of $\Sigma$.  </li><li><strong>Word</strong>: A word over $\Sigma$ is any finite sequence of symbols of $\Sigma$.  </li><li><strong>Empty Word</strong>: The empty word $\lambda$ is the only word consisting of zero symbols.  </li><li>The set of all words over the alphabet $\Sigma$ is denoted by $\Sigma^*$.</li><li><strong>Length</strong>: The length of a word $w$ over an alphabet $\Sigma$, denoted by $|w|$, is the number of symbols in $w$ (i.e., the length of $w$ as a sequence).</li><li><p>For every word $w\in\Sigma^*$, and every symbol $a\in\Sigma$, $#_a (w)$ is the number of occurrences of the symbol $a$ in the word $w$.  </p></li><li><p>More to be added</p></li><li><p><strong>Canonical Ordering</strong>: We define the canonical ordering on $\Sigma^<em>$ as follows. For all $u, v\in\Sigma^</em>$, $u &lt; v$ if $|u| &lt; |v|$ or $|u| = |v|$, $u = xs_iu’$, and $v = xs_jv’$ for some $x,u’,v’ \in\Sigma^*$, and $i &lt; j$.  </p></li></ul><h3 id="Algorithmic-Problems"><a href="#Algorithmic-Problems" class="headerlink" title="Algorithmic Problems"></a>Algorithmic Problems</h3><ul><li><strong>Decision Problem</strong><br>A decision problem is a triple $(L, U, \Sigma)$ where $\Sigma$ is an alphabet and $L \subseteq U \subseteq \Sigma^*$. An algorithm $A$ solves (decides) the decision problem $(L, U, \Sigma)$ if, for every $x \in U$,<ol><li>$A ( x) = 1$ if $x \in L$, and</li><li>$A(x) = 0$ if $x \in U - L (x \notin L)$.</li></ol><ul><li><strong>PRIM</strong>: PRIMALITY TESTING: 质数检验</li><li><strong>EQ-POL</strong>: EQUIVALENCE PROBLEM FOR POLYNOMIALS: 多项式等价问题</li><li><strong>EQ-IBP</strong>: EQUIVALENCE PROBLEM FOR ONE-TIME-ONLY BRANCHING PROGRAMS: 分支程序等价性</li><li><strong>SAT</strong>: SATISFIABILITY PROBLEM: 合取范式是否可满足</li><li><strong>kSAT</strong>: 只有k个子式的合取范式是否可满足</li><li><strong>CLIQUE</strong>: CLIQUE PROBLEM: 给定图是否有子图为k阶完全图</li><li><strong>VCP</strong>: VERTEX COVER PROBLEM: k点覆盖问题</li><li><strong>HC</strong>: HAMILTONIAN CYCLE PROBLEM: 是否有哈密顿回路</li><li><strong>SOL-IP</strong>: EXISTENCE PROBLEMS IN LINEAR INTEGER PROGRAMMING: 整数线性规划有解问题</li><li><strong>SOL-0/1-IP</strong>: 01线性规划有解问题</li><li><strong>SOL-IP$_p$</strong>: 模p线性规划有解问题</li></ul></li><li><strong>Optimization Problem</strong> 7-tuple $U=(\Sigma_I,\Sigma_O,L,L_I,\mathcal{M}, cost, goal)$<ul><li><strong>TSP</strong>: TRAVELING SALESPERSON PROBLEM: 旅行商问题</li><li><strong>MS</strong>: MAKESPAN SCHEDULING PROBLEM: 生产计划问题</li><li><strong>MIN-VCP</strong>: 最小点覆盖问题</li><li><strong>SCP</strong>: SET COVER PROBLEM: 集合覆盖问题</li><li><strong>WEIGHT-VCP</strong>: 带权重的点覆盖问题: 点覆盖权之和最小</li><li><strong>MAX-CL</strong>: MAXIMUM CLIQUE PROBLEM: 给定图所含的最大完全子图的阶</li><li><strong>MAX-CUT</strong>, <strong>MIN-CUP</strong>: 最大割最小割</li><li><strong>SKP</strong>: SIMPLE KNAPSACK PROBLEM: 简单背包: 物品重量不超, 最多能带的重量</li><li><strong>KP</strong>: 背包问题: 物品重量不超, 最多能带的价值总和</li><li><strong>BIN-P</strong>: 装箱问题: 用最少的箱子装完物品, 容积不超箱子大小</li><li><strong>MAX-SAT</strong>:</li><li><strong>LP</strong>, <strong>IP</strong>, <strong>MAX-LINMODK</strong></li></ul></li></ul><h3 id="Complexity-Theory"><a href="#Complexity-Theory" class="headerlink" title="Complexity Theory"></a>Complexity Theory</h3><ul><li><strong>Tractable</strong>: 多项式时间可解</li><li><strong>Verifier</strong>: 检验器</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Key definitions and theorems in Ch2.3 in Algorithms for Hard Problems.&lt;br&gt;
    
    </summary>
    
    
      <category term="Course" scheme="https://Maxwell-lyu.github.io/tags/Course/"/>
    
      <category term="Problem Solving" scheme="https://Maxwell-lyu.github.io/tags/Problem-Solving/"/>
    
      <category term="Abstract Algebra" scheme="https://Maxwell-lyu.github.io/tags/Abstract-Algebra/"/>
    
  </entry>
  
  <entry>
    <title>Problem Solving IV 09</title>
    <link href="https://Maxwell-lyu.github.io/2019/04/21/Learn-PS-20190421-PS-IV-09/"/>
    <id>https://Maxwell-lyu.github.io/2019/04/21/Learn-PS-20190421-PS-IV-09/</id>
    <published>2019-04-21T02:47:45.000Z</published>
    <updated>2019-04-21T13:42:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>My note when <ruby> previewing<rt> Copying the Textbook of</rt> </ruby>  abstract algebra.<br><a id="more"></a><br><em>Form now on, only the theorems that is new to me are included in my note</em></p><h1 id="Chapter-8-Maximum-Likelihood-Decoding"><a href="#Chapter-8-Maximum-Likelihood-Decoding" class="headerlink" title="Chapter 8: Maximum-Likelihood Decoding"></a>Chapter 8: Maximum-Likelihood Decoding</h1><h2 id="Error-Detecting-and-Correcting-Codes"><a href="#Error-Detecting-and-Correcting-Codes" class="headerlink" title="Error-Detecting and Correcting Codes"></a>Error-Detecting and Correcting Codes</h2><ul><li><strong>Theorem 8.13</strong>  <blockquote><p>$d_{min}=2n+1$ means correcting $n$ or fewer errors or detecting $2n$ or fewer errors.</p></blockquote></li></ul><h2 id="Linear-Codes"><a href="#Linear-Codes" class="headerlink" title="Linear Codes"></a>Linear Codes</h2><ul><li><p><strong>Group Code</strong>  </p><blockquote><p>A code that is a subgroup of $\mathbb{Z}_2^n$  </p></blockquote></li><li><p><strong>Lemma 8.17</strong></p><blockquote><p>$w(\mathbf{x}+\mathbf{y})=d(\mathbf{x},\mathbf{y})$</p></blockquote></li><li><p><strong>Theorem 8.18</strong>  </p><blockquote><p>$d_{min}=\min\{w(\mathbf{x}):\mathbf{x}\ne 0\}$</p></blockquote></li><li><p><strong>Theorem 8.21</strong></p><blockquote><p>$H\in\mathbb{M}_{m\times n}(\mathbb{Z}_2)$, then $\mathrm{null}(H)$ is a group code</p></blockquote></li></ul><h2 id="Parity-Check-and-Generator-Matrices"><a href="#Parity-Check-and-Generator-Matrices" class="headerlink" title="Parity-Check and Generator Matrices"></a>Parity-Check and Generator Matrices</h2><ul><li><p><strong>Canonical Parity-Check Matrix</strong></p><blockquote><p>$H=(A|I_m)$, $A\in\mathbb{M}_{m\times (n-m)}(\mathbb{Z}_2)$</p></blockquote></li><li><p><strong>Generator Matrix</strong></p><blockquote><p>$G=(\frac{I_{n-m}}{A})$</p></blockquote></li><li><p><strong>Theorem 8.25</strong></p><ol><li>If $H\in\mathbb{M}_{m\times n}(\mathbb{Z}_2)$ is a canonical parity-check matrix  </li><li>then Null(H) consists of all $\mathbf{x}\in\mathbb{Z}_2$ whose first $n-m$ bits are arbitrary but whose last $m$ bits are determined by $H\mathbf{x} = 0$.   </li><li>Each of the last $m$ bits serves as an even parity check bit for some of the first $n-m$ bits.   </li><li>Hence, $H$ gives rise to an $(n, n - m)$-block code.</li></ol></li><li><p><strong>Theorem 8.26</strong></p><ol><li>Suppose that $G$ is an $n \times k$ standard generator matrix.   </li><li>Then $C = \{\mathbf{y} : G\mathbf{x} = \mathbf{y}\ for\ \mathbf{x} \in \mathbb{Z}_2^k\}$ is an $(n, k)$-block code.   </li><li>More specifically, $C$ is a group code.</li></ol></li><li><p><strong>Theorem 8.31</strong></p><blockquote><p>Then the null space of $H$ is a single error-detecting code if and only if no column of $H$ consists entirely of zeros.</p></blockquote></li><li><p><strong>Theorem 8.34</strong></p><blockquote><p>Let H be a binary matrix. The null space of $H$ is a single error-correcting code if and only if $H$ does not contain any zero columns and no two columns of $H$ are identical.</p></blockquote></li></ul><h2 id="Efficient-Decoding"><a href="#Efficient-Decoding" class="headerlink" title="Efficient Decoding"></a>Efficient Decoding</h2><ul><li><p><strong>Syndrome</strong></p><blockquote><p>$H\mathbf{x}$, where $H$ is an $n\times m$-matrix, and $\mathbf{x}\in\mathbb{Z}_2^k$</p></blockquote></li><li><p><strong>Proposition 8.36</strong></p><blockquote><p>$\mathbf{x}=\mathbf{c}+\mathbf{e}$, $\mathbf{x}$ is the code received, $\mathbf{c}$ is the codeword, $\mathbf{e}$ is the transmission error. Then $H\mathbf{x}=H\mathbf{e}$</p></blockquote></li><li><p><strong>Theorem 8.37</strong></p><ol><li>Let $H\in\mathbb{M}_{m\times n}(\mathbb{Z}_2)$ and suppose that the linear code corresponding to $H$ is single error-correcting. </li><li>Let $\mathbf{r}$ be a received $n$-tuple that was transmitted with at most one error. </li><li>If the syndrome of $\mathbf{r}$ is $0$, then no error has occurred; </li><li>Otherwise, if the syndrome of $\mathbf{r}$ is equal to some column of H, say the $i$-th column, then the error has occurred in the $i$-th bit.</li></ol></li><li><p><strong>Coset Decoding</strong></p><blockquote><p>Coset or standard decoding uses the cosets of $C$ in $\mathbb{Z}_2^n$ to implement maximum-likelihood decoding.</p></blockquote></li><li><p><strong>Proposition 8.43</strong></p><ol><li>Let $C$ be an $(n,k)$-linear code given by the matrix $H$ and suppose that $\mathbf{x}$ and $\mathbf{y}$ are in $\mathbb{Z}_2^n$ . </li><li>Then $\mathbf{x}$ and $\mathbf{y}$ are in the same coset of $C$ if and only if $H\mathbf{x} = H\mathbf{y}$. </li><li>That is, two n-tuples are in the same coset if and only if their syndromes are the same.</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;My note when &lt;ruby&gt; previewing&lt;rt&gt; Copying the Textbook of&lt;/rt&gt; &lt;/ruby&gt;  abstract algebra.&lt;br&gt;
    
    </summary>
    
    
      <category term="Course" scheme="https://Maxwell-lyu.github.io/tags/Course/"/>
    
      <category term="Problem Solving" scheme="https://Maxwell-lyu.github.io/tags/Problem-Solving/"/>
    
      <category term="Abstract Algebra" scheme="https://Maxwell-lyu.github.io/tags/Abstract-Algebra/"/>
    
  </entry>
  
  <entry>
    <title>Probability Ch4</title>
    <link href="https://Maxwell-lyu.github.io/2019/04/20/Learn-PMS-20190420-PMS-04/"/>
    <id>https://Maxwell-lyu.github.io/2019/04/20/Learn-PMS-20190420-PMS-04/</id>
    <published>2019-04-20T02:44:15.000Z</published>
    <updated>2019-06-16T09:22:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>Probability Course in 2019 Spring<br><a id="more"></a> </p><h1 id="随机变量的数字特征"><a href="#随机变量的数字特征" class="headerlink" title="随机变量的数字特征"></a>随机变量的数字特征</h1><h2 id="数学期望"><a href="#数学期望" class="headerlink" title="数学期望"></a>数学期望</h2><h3 id="数学期望的定义"><a href="#数学期望的定义" class="headerlink" title="数学期望的定义"></a>数学期望的定义</h3><ul><li><strong>定义4.1</strong>  离散型<br>设离散型随机变量$X$的分布律为$P(X=x_i)=p_i,i=1,2,\cdots$, 若级数$\sum_{i=1}^{+\infty}|x_i|p_i$收敛, 则<br>$$EX=\sum_{i=1}^{+\infty}x_ip_i$$  </li><li><strong>定义4.2</strong>  连续型<br>设连续型随机变量$X$的密度为$p(x)$, 若积分$\int_{-\infty}^{+\infty}|x|p(x)dx&lt;\infty$, 则<br>$$EX=\int_{-\infty}^{+\infty}xp(x)dx$$</li></ul><h3 id="随机变量函数的数学期望"><a href="#随机变量函数的数学期望" class="headerlink" title="随机变量函数的数学期望"></a>随机变量函数的数学期望</h3><ul><li><strong>定理4.1</strong> 随机变量函数的期望  <ol><li>离散型<br>$$EY=E[g(X)]=\sum_{k=1}^{+\infty}g(x_k)p_k$$</li><li>连续型<br>$$EY=E[g(X)]=\int_{-\infty}^{+\infty}g(x)p(x)dx$$  </li></ol></li></ul><ul><li><strong>定理4.2</strong> 随机向量函数的期望  <ol><li>离散型<br>$$EZ=E[g(X,Y)]=\sum_{i=1}^{+\infty}\sum_{j=1}^{+\infty}g(x_i,y_j)p_{ij}$$</li><li>连续型<br>$$EZ=E[g(X,Y)]=\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}g(x,y)p(x,y)dxdy$$</li></ol></li></ul><h3 id="数学期望的性质"><a href="#数学期望的性质" class="headerlink" title="数学期望的性质"></a>数学期望的性质</h3><ol><li>对常数$a,b$, 若$a\leq X\leq b$, 则$a\leq EX\leq b$; 特别地, 当$X\geq 0$时, $EX\geq 0$</li><li>线性性质<br>$$E(\sum_ic_iX_i)=\sum_ic_iEX_i$$</li><li>独立变量的期望<br>$$E(\prod_iX_i)=\prod_iEX_i$$</li></ol><h2 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h2><h3 id="方差的定义"><a href="#方差的定义" class="headerlink" title="方差的定义"></a>方差的定义</h3><ul><li><strong>定义4.4</strong> 方差<ol><li>离散型<br>$$D(X)=E(X-EX)^2=\sum_{i=1}^{+\infty}(x_k-EX)^2p_k$$</li><li>连续型<br>$$D(X)=E(X-EX)^2=\int_{-\infty}^{+\infty}(x-EX)^2p(x)dx$$</li></ol></li></ul><h3 id="方差的性质"><a href="#方差的性质" class="headerlink" title="方差的性质"></a>方差的性质</h3><ol><li>$$EX^2&lt;+\infty\quad\quad D(X)=EX^2-(EX)^2$$</li><li>被变量的分布唯一确定</li><li>$$D(X)=0\Leftrightarrow P(X=EX)=1$$</li><li>$$D(aX+b)=a^2D(X)$$</li><li>$$D(X\pm Y)=D(X)+D(Y)\pm 2E[(X-EX)(Y-EY)]$$</li><li>独立变量和的方差<br>$$D(\sum_iX_i)=\sum_iD(X_i)$$</li><li>切比雪夫不等式$\forall \epsilon&gt;0$<br>$$P(|X-EX|\geq\epsilon)\leq\frac{D(X)}{\epsilon^2}$$</li></ol><h3 id="矩"><a href="#矩" class="headerlink" title="矩"></a>矩</h3><ul><li><strong>定义4.5</strong><br>$EX^k$为$X$的 <strong>$k$阶原点矩</strong>, $E(X-EX)^k$为$X$的 <strong>$k$阶中心矩</strong><br>$EX^2=D(x)+(EX)^2$</li></ul><h2 id="协方差与相关系数"><a href="#协方差与相关系数" class="headerlink" title="协方差与相关系数"></a>协方差与相关系数</h2><ul><li><strong>定义4.6</strong> 协方差<br>$$\mathrm{cov}(X,Y)=E[(X-EX)(Y-EY)]$$<br>$$\mathrm{cov}(X,Y)=E(XY)-EX\cdot EY$$<br>$$D(\sum_{k=1}^nX_k)=\sum_{k=1}^nD(X_k)+2\sum_{1\leq i&lt;j\leq n}\mathrm{cov}(X_i,Y_j)$$</li><li><p><strong>协方差性质</strong></p><ol><li>若$X$和$Y$独立, 则$\mathrm{cov}(X,Y)=0$</li><li>$\mathrm{cov}(X,X)=D(X)$</li><li>对称性$\mathrm{cov}(X,Y)=\mathrm{cov}(Y,X)$</li><li>$\mathrm{cov}(aX+c_1,bY+c_2)=ab\mathrm{cov}(X,Y)$</li><li>$\mathrm{cov}(X_1+X_2,Y)=\mathrm{cov}(X_1,Y)+\mathrm{cov}(X_2,Y)$</li></ol></li><li><p><strong>定理4.3</strong> Cauchy-Schowarz不等式<br>$$[\mathrm{cov}(X,Y)]^2\leq D(X)D(Y)$$</p></li><li><strong>定义4.7</strong>  相关系数<br>$$\rho_{XY}=\mathrm{Corr}(X,Y)=\frac{\mathrm{cov}(X,Y)}{\sqrt{D(X)D(Y)}}$$</li><li><strong>相关系数性质</strong><ol><li>$|\rho_{XY}|\leq 1$</li><li>$|\rho_{XY}|=1\Leftrightarrow D(X)&gt;0,D(Y)&gt;0,P(cX+aY=b)=1$, 即$X$与$Y$以概率$1$具有线性关系</li></ol></li></ul><h1 id="随机变量一网打尽"><a href="#随机变量一网打尽" class="headerlink" title="随机变量一网打尽"></a>随机变量一网打尽</h1><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">参数</th><th style="text-align:center">分布律或概率密度</th><th style="text-align:center">数学期望</th><th style="text-align:center">方差</th></tr></thead><tbody><tr><td style="text-align:center">0-1分布</td><td style="text-align:center">$B(x,p)$</td><td style="text-align:center">$P(X=k)=p^k(1-p)^{1-k}$</td><td style="text-align:center">$p$</td><td style="text-align:center">$p(1-p)$</td></tr><tr><td style="text-align:center">二项分布</td><td style="text-align:center">$B(n,p)$</td><td style="text-align:center">$P(X=k)=C_n^kp^k(1-p)^{n-k}$</td><td style="text-align:center">$np$</td><td style="text-align:center">$np(1-p)$</td></tr><tr><td style="text-align:center">负二项分布</td><td style="text-align:center">$NB(r,p)$</td><td style="text-align:center">$P(X=k)=C_{k-1}^{r-1}p^r(1-p)^{k-r}$</td><td style="text-align:center">$\frac{r}{p}$</td><td style="text-align:center">$\frac{r(1-p)}{p^2}$</td></tr><tr><td style="text-align:center">几何分布</td><td style="text-align:center">$G(p)$</td><td style="text-align:center">$P(X=k)=p(1-p)^{k-1}$</td><td style="text-align:center">$\frac{1}{p}$</td><td style="text-align:center">$\frac{(1-p)}{p^2}$</td></tr><tr><td style="text-align:center">超几何分布</td><td style="text-align:center">$H(n,M,N)$</td><td style="text-align:center">$P(X=k)=\frac{C_M^kC_{N-M}^{n-m}}{C_N^n}$</td><td style="text-align:center">$\frac{nM}{N}$</td><td style="text-align:center">$\frac{nM}{N}(1-\frac{M}{N})(\frac{N-n}{N-1})$</td></tr><tr><td style="text-align:center">泊松分布</td><td style="text-align:center">$P(\lambda)$</td><td style="text-align:center">$P(X=k)=\frac{\lambda^k}{k!}e^{-\lambda}$</td><td style="text-align:center">$\lambda$</td><td style="text-align:center">$\lambda$</td></tr><tr><td style="text-align:center">均匀分布</td><td style="text-align:center">$U[a,b]$</td><td style="text-align:center">$P_{[a,b]}\equiv\frac{1}{b-a}$</td><td style="text-align:center">$\frac{a+b}{2}$</td><td style="text-align:center">$\frac{(b-a)^2}{12}$</td></tr><tr><td style="text-align:center">正态分布</td><td style="text-align:center">$N(\mu,\sigma^2)$</td><td style="text-align:center">$p(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}$</td><td style="text-align:center">$\mu$</td><td style="text-align:center">$\sigma^2$</td></tr><tr><td style="text-align:center"><del>$\Gamma$分布</del></td><td style="text-align:center">$G(\lambda,r)$</td><td style="text-align:center">$p(x)_{x&gt;0}=\frac{\lambda^r}{\Gamma(r)}x^{r-1}e^{-\lambda x}$</td><td style="text-align:center">$\frac{r}{\lambda}$</td><td style="text-align:center">$\frac{r}{\lambda^2}$</td></tr><tr><td style="text-align:center">指数分布</td><td style="text-align:center">$e(\theta)$</td><td style="text-align:center">$p(x)_{x&gt;0}=\frac{1}{\theta}e^{-\frac{x}{\theta}}$</td><td style="text-align:center">$\theta$</td><td style="text-align:center">$\theta^2$</td></tr><tr><td style="text-align:center">柯西分布</td><td style="text-align:center">$C(\lambda, \alpha)$</td><td style="text-align:center">$p(x)=\frac{1}{\pi}\frac{1}{\lambda^2+(x-\alpha)^2}$</td><td style="text-align:center">$\nexists$</td><td style="text-align:center">$\nexists$</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Probability Course in 2019 Spring&lt;br&gt;
    
    </summary>
    
    
      <category term="Course" scheme="https://Maxwell-lyu.github.io/tags/Course/"/>
    
      <category term="Probability and Mathematical Statistics" scheme="https://Maxwell-lyu.github.io/tags/Probability-and-Mathematical-Statistics/"/>
    
  </entry>
  
  <entry>
    <title>Problem Solving IV 08</title>
    <link href="https://Maxwell-lyu.github.io/2019/04/14/Learn-PS-20190414-PS-IV-08/"/>
    <id>https://Maxwell-lyu.github.io/2019/04/14/Learn-PS-20190414-PS-IV-08/</id>
    <published>2019-04-14T08:02:41.000Z</published>
    <updated>2019-04-14T08:57:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>My note when <ruby> previewing<rt> Copying the Textbook of</rt> </ruby>  abstract algebra.<br><a id="more"></a> </p><h1 id="Chapter-7-Introduction-to-Cryptography"><a href="#Chapter-7-Introduction-to-Cryptography" class="headerlink" title="Chapter 7: Introduction to Cryptography"></a>Chapter 7: Introduction to Cryptography</h1><ul><li><strong>Plaintext</strong> (明文)  </li><li><strong>Ciphertext</strong> (密文)   </li><li><strong>Cryptosystem</strong> or <strong>Cipher</strong> (密码)  </li><li><strong>Encryption</strong> and <strong>Decryption</strong> (加密&amp;解密)  </li><li><strong>Key</strong> (密钥)  </li></ul><h2 id="Private-Key-Cryptography"><a href="#Private-Key-Cryptography" class="headerlink" title="Private Key Cryptography"></a>Private Key Cryptography</h2><ul><li><p><strong>Private Key Cryptography</strong> (单钥/私钥加密)  </p><blockquote><p>The same key is used for both encrypting and decrypting messages  </p></blockquote></li><li><p><strong>Monoalphabetic Cryptosystems</strong> (单字母密码系统/移位码)</p><blockquote><p>A character in the enciphered message represents exactly one character in the original message.</p></blockquote></li><li><p><strong>Simple Shift Code</strong> (简单移位码)</p><blockquote><p>$$f(p)=p+b\textrm{ mod } 26$$</p></blockquote></li><li><p><strong>Affine Cryptosystem</strong> (仿射密码系统)</p><blockquote><p>$\textrm{gcd}(a,26)=1$:<br>$$f(p) = ap+b\textrm{ mod } 26$$</p></blockquote></li><li><strong>Polyalphabetic Cryptosystem</strong> (多字母密码系统)<blockquote><p>A ciphertext letter could represent more than one plaintext letter<br>$\mathrm{A}\in\mathrm{M}_{2\times 2}$:<br>$$f(\vec{p})=\mathrm{A}\vec{p}+\vec{b}$$</p></blockquote></li></ul><h2 id="Public-Key-Cryptography"><a href="#Public-Key-Cryptography" class="headerlink" title="Public Key Cryptography"></a>Public Key Cryptography</h2><h3 id="The-RSA-Cryptosystem"><a href="#The-RSA-Cryptosystem" class="headerlink" title="The RSA Cryptosystem"></a>The RSA Cryptosystem</h3><ul><li><p><strong>RSA Cryptosystem</strong></p><ol><li>Find BIG primes $p$ and $q$</li><li>$n=pq$ and $m=(p-1)(q-1)=\phi(n)$</li><li>$\textrm{gcd}(E,m)=1$ for randomly selected $E$</li><li>Find $D$ using Euclidean Algorithm that $DE\equiv 1(\textrm{mod }m)$</li><li>$n$ and $E$ are public</li></ol></li><li><p><strong>RSA Encryption &amp; Decryption</strong>  </p><ol><li>Message is encoded and splitted into $x&lt;n$</li><li>Encrypted message is $y=x^E$</li><li>Decrypted message is $x=y^D\textrm{ mod }n$</li></ol></li></ul><h3 id="Message-Verification"><a href="#Message-Verification" class="headerlink" title="Message Verification"></a>Message Verification</h3><ul><li><strong>How it work</strong>  <ol><li>Alice: $(n,E,D)$  </li><li>Bob: $(n’,E’,D’)$  </li><li>$x’=x^{D’}\textrm{ mod }n’$<ul><li>A message that anyone can decrypt by encrypting it with $E’$    </li><li>Can only be generated by Bob   </li></ul></li><li>$y’=x’^{E}\textrm{ mod }n$<ul><li>A message only Alice can decrypt</li><li>The message to be sent to Alice</li><li>Alice  can read it with Bob’s Public key, and be sure of that it is sent by Bob</li></ul></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;My note when &lt;ruby&gt; previewing&lt;rt&gt; Copying the Textbook of&lt;/rt&gt; &lt;/ruby&gt;  abstract algebra.&lt;br&gt;
    
    </summary>
    
    
      <category term="Course" scheme="https://Maxwell-lyu.github.io/tags/Course/"/>
    
      <category term="Problem Solving" scheme="https://Maxwell-lyu.github.io/tags/Problem-Solving/"/>
    
      <category term="Abstract Algebra" scheme="https://Maxwell-lyu.github.io/tags/Abstract-Algebra/"/>
    
  </entry>
  
  <entry>
    <title>Anki</title>
    <link href="https://Maxwell-lyu.github.io/2019/03/30/Tech-20190330-Anki/"/>
    <id>https://Maxwell-lyu.github.io/2019/03/30/Tech-20190330-Anki/</id>
    <published>2019-03-30T09:46:58.000Z</published>
    <updated>2019-04-01T12:20:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Anki背诵和记忆任何东西"><a href="#Anki背诵和记忆任何东西" class="headerlink" title="Anki背诵和记忆任何东西"></a>Anki背诵和记忆任何东西</h1><h2 id="官方网站"><a href="#官方网站" class="headerlink" title="官方网站"></a>官方网站</h2><p>下载地址在官网，有Windows，Mac，Linux，iPhone/Android等版本<br><a href="http://www.ankichina.net/" target="_blank" rel="noopener">中文官网</a><br><a href="https://apps.ankiweb.net/index.html" target="_blank" rel="noopener">英文官网</a>  </p><h2 id="Anki是什么"><a href="#Anki是什么" class="headerlink" title="Anki是什么"></a>Anki是什么</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="01.png" alt="暗杀教室" title="">                </div>                <div class="image-caption">暗杀教室</div>            </figure><p>Anki是日语“<ruby>暗<rt>あん</rt></ruby><ruby>記<rt>き</rt></ruby>”的罗马音，意为背诵，是目前世界最流行的记忆软件之一。这个软件在形式上类似“百词斩”等卡片式背单词软件，但功能却多出一个数量级。</p><h2 id="为什么是Anki"><a href="#为什么是Anki" class="headerlink" title="为什么是Anki"></a>为什么是Anki</h2><p>我在使用Anki的时候，对这一软件的以下功能有所尝试：  </p><ul><li>跨平台<br>Anki支持Windows（Win32和UWP都有），Linux，Mac，IOS，Android，而且这是一个开源软件，如果有必要，你甚至可以开发编译自己的版本</li><li>同步<br>借助AnkiWeb，跨设备同步记忆卡片组和学习进度。Github上还有搭建 自己的同步服务器的开源项目，B站也有相应的视频教程。此外，OneDrive也是可选的同步方式</li><li>灵活的卡片形式  <ol><li>普通的询问式卡片，选择题，填空题</li><li>支持LaTex(PC端可编辑和渲染源码，移动端仅支持查看图片缓存)</li><li>允许插入图片</li><li>允许插入音频甚至是视频（较大的媒体文件将会耗费大量时间同步）</li><li>允许打包分享卡片，网络上可以购买到现成的影音英语学习卡组</li></ol></li><li>自动化<br>很多优秀的脚本可以让你一键生成卡组，例如为英文单词列表自动查询字典，并匹配相应的中文释义，例句和发音，支持百度翻译，灵格斯自定义词典文件等<br>英语读写课给的英文单词表，一个脚本即可匹配牛津词典的释义和例句，3分钟不到就可以开始学习</li><li>科学的记忆<br>符合记忆规律，根据错误次数自动计算最合适的复习时间点，从几分钟到数年之后不等（最短的小于一分钟，我见过最长的是2年后）</li></ul><h2 id="怎么用？RTFM！"><a href="#怎么用？RTFM！" class="headerlink" title="怎么用？RTFM！"></a>怎么用？RTFM！</h2><p>这个软件提供了及其详细的手册！大家自己看吧。入门请不要使用移动版（iPhone/Android），因为功能不全<br><a href="http://www.ankichina.net/Index/ankishouce" target="_blank" rel="noopener">中文手册(翻译中)</a><br><a href="https://apps.an kiweb.net/docs/manual.html" target="_blank" rel="noopener">英文手册</a>    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Anki背诵和记忆任何东西&quot;&gt;&lt;a href=&quot;#Anki背诵和记忆任何东西&quot; class=&quot;headerlink&quot; title=&quot;Anki背诵和记忆任何东西&quot;&gt;&lt;/a&gt;Anki背诵和记忆任何东西&lt;/h1&gt;&lt;h2 id=&quot;官方网站&quot;&gt;&lt;a href=&quot;#官方网站&quot;
      
    
    </summary>
    
      <category term="Technique" scheme="https://Maxwell-lyu.github.io/categories/Technique/"/>
    
    
      <category term="Utility" scheme="https://Maxwell-lyu.github.io/tags/Utility/"/>
    
  </entry>
  
  <entry>
    <title>PanDownload</title>
    <link href="https://Maxwell-lyu.github.io/2019/03/30/Tech-20190330-PanDownload/"/>
    <id>https://Maxwell-lyu.github.io/2019/03/30/Tech-20190330-PanDownload/</id>
    <published>2019-03-30T08:45:52.000Z</published>
    <updated>2019-04-01T12:20:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PanDownload-百度云提速下载工具"><a href="#PanDownload-百度云提速下载工具" class="headerlink" title="PanDownload 百度云提速下载工具"></a>PanDownload 百度云提速下载工具</h1><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p><a href="http://pandownload.com/" target="_blank" rel="noopener">官方网站</a><br>网站亦包含详细使用说明，不过主要是针对旧版本，以下使用说明主要面向新版本变化较大的功能进行</p><h2 id="为什么是PanDownload"><a href="#为什么是PanDownload" class="headerlink" title="为什么是PanDownload"></a>为什么是PanDownload</h2><ul><li><strong>多线程</strong><br>百度网盘的限速机制大致为80kB/s~100kB/s每线程，PanDownload最大支持128线程下载  </li><li><strong>自动更新脚本</strong><br>百度网盘并非直链下载，需要解析，解析脚本时常需要更新。PanDownload提供自动更新脚本的功能  </li><li><strong>支持多账号登陆</strong><br>我个人使用过多种百度盘第三方客户端，有一些客户端无法下载自己网盘里的文件，需要每个文件创建分享链接才能下，而支持账号登陆，批量下载自己网盘文件的客户端更是难得  </li><li><strong>附加功能多</strong><br>我知道你们都是冲着新番资源来的，怎么用看下文  </li></ul><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h3 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h3><p>新版本加入的多标签功能，允许一个PanDownload客户端登陆多个网盘账号，或是打开多个连接。由于百度网盘单个账号的容量偏小，多个账号可以让你存更多资♂源。已登录的账号会在每次开启时自动打开一个标签页，显示此账号下的文件。<br>新建标签页，请点击标签页栏的<code>+</code>号<br><img src="01.png" alt="">  </p><h3 id="新番下载"><a href="#新番下载" class="headerlink" title="新番下载"></a>新番下载</h3><p><code>更多功能-新番下载</code><br>按照更新日分类，正在播出的新番基本都有，比B站，爱奇艺的会员慢<code>10分钟</code>左右<br>选择相应的番剧，会打开一个分享目录，右键你想要的那一集，点击下载即可享用<br>如果显示出来源为<code>AGE动漫</code>，却没有下载链接显示，多数情况下是来源站正在维护或GG了，请尝试直接前往来源站（ping一下也行）：<br><a href="http://donghua.agefans.com/" target="_blank" rel="noopener">AGE动漫</a><br>PS：我记得以前还有嘀哩嘀哩的来源的，好像D站被B站干了，就剩AGE独苗一根<br>PPS：这里的资源大多数是720P AVC（x264）格式，动作一多就是马赛克，对画质有要求的还是老老实实大会员吧（上次看刀剑神域一段UGO变剑，搞得满屏马赛克，最高祭司都不用打码了  </p><h3 id="资源搜索"><a href="#资源搜索" class="headerlink" title="资源搜索"></a>资源搜索</h3><p><code>更多功能-资源搜索</code><br>绝对的找资源神器，大量的百度盘资源随你选，除了黄赌毒基本上都能搜到  </p><h2 id="老规矩"><a href="#老规矩" class="headerlink" title="老规矩"></a>老规矩</h2><p>所有下载的资源建议<ruby>24小时内<rt>啊呀，谁知道呢</rt></ruby>删除，资源本身与软件作者和本介绍作者无关<br>看番还是建议正版，除了画质，其实<ruby>弹幕<rt>养肥再看</rt></ruby>才是本体<br>我不保证你用了就会快到吃满带宽，因为我也不能<ruby>钦点<rt>打包票</rt></ruby>的<br>，但是你问我<ruby>支不支持<rt>有没有可能性</rt></ruby>那我肯定是支持的   </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PanDownload-百度云提速下载工具&quot;&gt;&lt;a href=&quot;#PanDownload-百度云提速下载工具&quot; class=&quot;headerlink&quot; title=&quot;PanDownload 百度云提速下载工具&quot;&gt;&lt;/a&gt;PanDownload 百度云提速下载工具&lt;/
      
    
    </summary>
    
      <category term="Technique" scheme="https://Maxwell-lyu.github.io/categories/Technique/"/>
    
    
      <category term="Utility" scheme="https://Maxwell-lyu.github.io/tags/Utility/"/>
    
  </entry>
  
  <entry>
    <title>Probability Ch3</title>
    <link href="https://Maxwell-lyu.github.io/2019/03/21/Learn-PMS-20190321-PMS-03/"/>
    <id>https://Maxwell-lyu.github.io/2019/03/21/Learn-PMS-20190321-PMS-03/</id>
    <published>2019-03-21T00:13:03.000Z</published>
    <updated>2019-06-16T09:17:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>Probability Course in 2019 Spring<br><a id="more"></a> </p><h1 id="随机向量及其分布"><a href="#随机向量及其分布" class="headerlink" title="随机向量及其分布"></a>随机向量及其分布</h1><ul><li><strong>定义3.1</strong><br>若随机变量$X_1,X_2,\cdots, X_n$定义在同一个样本空间$\varOmega$上, 则称$(X_1,X_2.\cdots,X_n)$为一个$n$<strong>维随机向量</strong>或$n$<strong>维随机变量</strong>  </li></ul><h2 id="二位随机向量及其分布函数"><a href="#二位随机向量及其分布函数" class="headerlink" title="二位随机向量及其分布函数"></a>二位随机向量及其分布函数</h2><h3 id="二维离散型随机向量"><a href="#二维离散型随机向量" class="headerlink" title="二维离散型随机向量"></a>二维离散型随机向量</h3><ul><li><strong>定义3.2</strong><br>若二位随机向量$(X,Y)$的每个分量都是离散型的随机变量, 则称$(X,Y)$为一个<strong>二维离散型随机向量</strong></li><li><p><strong>定义3.3</strong><br>设随机向量$(X,Y)$的所有可能取值为$(x_i,y_i)$, $i,j=1,2,\cdots$, 假设当$i\ne k, j\ne l$时, $x_i\ne x_k, y_j\ne y_l$, 则$P(X=x_i, Y=y_i)=p_{ij}$, $i=1,2,\cdots$称为随机向量$(X,Y)$的<strong>联合分布率</strong>或$X$和$Y$的<strong>联合概率分布</strong><br>由分布律的定义可以得到联合分布率$\{p_{ij}\}$具有下列性质:  </p><ol><li>$p_{ij}\geq 0, i,j=1,2,\cdots$</li><li>$\sum_{i=1}^{+\infty}\sum_{j=1}^{+\infty}p_{ij}=1$</li></ol></li><li><p><strong>多项分布</strong><br>在$n$次独立重复实验中, 已知每次试验由三种不同的可能结果$A_1,A_2,A_3$, 且$P(A_i)=p_i$, $i=1,2,3$, $p_1+p_2+p_3=1$. 若以$X_1, X_2$分别记结果$A_1,A_2,A_3$出现的次数, 则任意的$k_i\in[0,n]\cap\mathbb{N}$, $i=1,2$<br>$$P(X_1=k_1,X_2=k_2)=\frac{n!}{k_1!k_2!(n-k_1-k_2)!}p_1^{k_1}p_2^{k_2}(1-p_1-p_2)^{n-k_1-k_2}$$<br>记为<br>$$(X_1,X_2)\sim M(n;p_1,p_2,p_3)$$  </p></li><li><p><strong>多元超几何分布</strong><br>设一个袋中分别标有1, 2或3的球, 设$i$号球有$N_i$只, $i=1,2,3$, 且$N_1+N_2+N_3=N$. 从中不放回地随机摸出$n$只, $n\leq N$, 若以$X_1$, $X_2$分别记1, 2号球的出现次数, 则$(X_1,X_2)$的联合概率分布为<br>$$P(X_1=n_1,X_2=n_2)=\frac{C_{N_1}^{n_1}C_{N_2}^{n_2}C_{N_3}^{n_3}}{C_N^n}$$  </p></li><li><p><strong>定义3.4</strong><br>对任意的实数$x,y$, 称二元函数$F(x,y)=P(X\leq x, Y\leq y)$为随机向量$(X,Y)$的 <strong>(联合)分布函数</strong>, 记为$(X,Y)\sim F(x,y)$<br>若$(X,Y)$的分布律为$\{p_{ij}\}$, 则它的分布函数可由它的分布律表示:<br>$$F(x,y)=\sum_{x_i\leq x, y_i\leq y}p_{ij}$$  </p></li><li><p><strong>边缘分布函数</strong><br>$$F_X(x)=P(X\leq x)=P(X\leq x, y\leq +\infty)=\lim_{y\to+\infty}P(X\leq x,Y\leq y)\eqqcolon F(x,+\infty)$$<br>$$F_Y(y)=F(+\infty, y)=\lim_{x\to +\infty}F(x,y)$$  </p></li></ul><h3 id="二维连续型随机向量"><a href="#二维连续型随机向量" class="headerlink" title="二维连续型随机向量"></a>二维连续型随机向量</h3><ul><li><p><strong>定义3.5</strong><br>设二维随机向量$(X,Y)$的分布函数为$F(x,y)$, 若存在非负可积二元函数$p(X,Y)$, 对任意的$x,y\in \mathbb{R}$, 有<br>$$F(x,y)=\int_{-\infty}^x\int_{-\infty}^{y}p(u,v)dudv$$<br>则称$(X,Y)$为<strong>二维连续型随机向量</strong>, 而称$p(X,Y)$为$(X,Y)$的一个<strong>联合概率密度函数</strong>, 简称为<strong>联合密度</strong><br>由分布律的定义可以得到联合概率密度函数$\{p(x,y)\}$具有下列性质:  </p><ol><li>$p(x,y)\geq 0$</li><li>$\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}p(x,y)dxdy=1$</li></ol></li><li><p><strong>边缘密度函数</strong><br>$$p_X(x)=\int_{-\infty}^{+\infty}p(x,v)dv$$<br>$$p_Y(y)=\int_{-\infty}^{+\infty}p(v,y)dv$$</p></li></ul><h3 id="联合密度函数"><a href="#联合密度函数" class="headerlink" title="联合密度函数"></a>联合密度函数</h3><ul><li><strong>略</strong></li></ul><h2 id="条件分布"><a href="#条件分布" class="headerlink" title="条件分布"></a>条件分布</h2><h3 id="离散型随机向量的条件概率分布"><a href="#离散型随机向量的条件概率分布" class="headerlink" title="离散型随机向量的条件概率分布"></a>离散型随机向量的条件概率分布</h3><ul><li><p><strong>在$X=x_i$下, $Y$的条件分布律</strong><br>$$P(Y=y_i|X=x_i)=\frac{P(Y=y_i,X=x_i)}{P(X=x_i)}=\frac{p_{ij}}{p_i}$$</p></li><li><p><strong>$Y$的边际分布</strong><br>$$P(Y=y_i)=\sum_{i=1}^{+\infty}P(Y=y_i,X=x_i)=\sum_{i=1}^{+\infty}P(Y=y_i|X=x_i)P(X=x_i)$$</p></li></ul><h3 id="连续型随机变量的条件概率"><a href="#连续型随机变量的条件概率" class="headerlink" title="连续型随机变量的条件概率"></a>连续型随机变量的条件概率</h3><ul><li><p><strong>在$X=x$的条件下, $Y$的条件分布函数</strong><br>$$F_{Y|X=x}(y)=P(Y\leq y|X=x)=\int_{-\infty}^{y}\frac{p(x,v)}{p_X(x)}dv$$</p></li><li><p><strong>在$X=x$的条件下, $Y$的条件密度函数</strong><br>$$p_{Y|X=x}(y)=\frac{p(x,v)}{p_X(x)}$$</p></li></ul><h2 id="随机变量的独立性"><a href="#随机变量的独立性" class="headerlink" title="随机变量的独立性"></a>随机变量的独立性</h2><ul><li><p><strong>定义3.9</strong><br>设$X$和$Y$是两个离散型随机变量, 若对任意的一组$(x_i,y_j)$,<br>$$P(X=x_i,Y=y_j)=P(X=x_i)P(Y=y_j)$$<br>即对任意的$i,j$, $p_{ij}=p_i\cdot p_j$, 则称<strong>随机变量$X$和$Y$相互独立</strong></p></li><li><p><strong>定义3.10</strong><br>设$X_1,X_2,\cdots,X_n$都是离散型随机变量, 若对任意的$x_1,x_2,\cdots x_n$,<br>$$P(X=x_1,X=x_2,\cdots,X=x_n)=P(X=x_1)P(X=x_2)\cdots P(X=x_n)$$<br>即对任意的$i,j$, $p_{ij}=p_i\cdot p_j$, 则称<strong>随机变量$X$和$Y$相互独立</strong></p></li><li><p><strong>定理3.1</strong><br>设$X_1,X_2,\cdots,X_n$相互独立, 若函数$Y_1=g_1(X_1,X_2,\cdots,X_m)$和$Y_2=g_2(X_{m+1},X_{m+2},\cdots,X_n)$仍然是随机变量, 则$Y_1$和$Y_2$独立</p></li><li><p><strong>定义3.11</strong><br>设$n$维随机向量$(X_1,X_2,\cdots,X_n)$的联合密度函数为$p(x_1,x_2,\cdots,x_n)$, 而$X_i$的边缘密度函数为$p_i(x_i)$. 如果<br>$$p(x_1,\cdots,x_n)=p_1(x_1)p_2(x_2)\cdots p_n(x_n)$$<br>就称随机变量$X_1,X_2,\cdots,X_n$<strong>相互独立</strong>, 或者简称<strong>独立</strong></p></li><li><p><strong>定理3.2</strong><br>独立的充要条件:<br>$$F(x,y)=F_X(x)F_Y(y)$$</p></li><li><p><strong>定理3.3</strong><br>联合密度函数为$f(x,y)$时, 二者独立的充要条件:<br>$$\exists g_1,g_2,\quad f(x,y)=g_1(x)g_2(y)$$</p></li></ul><h2 id="二维随机向量函数的分布"><a href="#二维随机向量函数的分布" class="headerlink" title="二维随机向量函数的分布"></a>二维随机向量函数的分布</h2><h3 id="二维离散型随机向量函数的分布"><a href="#二维离散型随机向量函数的分布" class="headerlink" title="二维离散型随机向量函数的分布"></a>二维离散型随机向量函数的分布</h3><ul><li><strong>略</strong></li></ul><h3 id="二维连续性随机变量函数的分布"><a href="#二维连续性随机变量函数的分布" class="headerlink" title="二维连续性随机变量函数的分布"></a>二维连续性随机变量函数的分布</h3><ol><li><p>和的分布$Z=X+Y$<br>$$p_Z(z)=\int_{-\infty}^{+\infty}p(x,z-x)dx$$</p></li><li><p>商的分布$Z+X/Y$<br>$$p_Z(z)=\int_{-\infty}^{+\infty}|y|p(zy,y)dy$$</p></li><li><p>最大(小)值的分布$M=\max, N=\min$<br>$$F_M(z)=F_X(z)F_Y(z)$$<br>$$F_N(z)=1-(1-F_X(z))(1-F_Y(z))$$<br>求导可得密度函数</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Probability Course in 2019 Spring&lt;br&gt;
    
    </summary>
    
    
      <category term="Course" scheme="https://Maxwell-lyu.github.io/tags/Course/"/>
    
      <category term="Probability and Mathematical Statistics" scheme="https://Maxwell-lyu.github.io/tags/Probability-and-Mathematical-Statistics/"/>
    
  </entry>
  
  <entry>
    <title>Problem Solving IV 03</title>
    <link href="https://Maxwell-lyu.github.io/2019/03/12/Learn-PS-20190312-PS-IV-03/"/>
    <id>https://Maxwell-lyu.github.io/2019/03/12/Learn-PS-20190312-PS-IV-03/</id>
    <published>2019-03-12T05:47:35.000Z</published>
    <updated>2019-10-13T12:48:34.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-9-Isomorphisms"><a href="#Chapter-9-Isomorphisms" class="headerlink" title="Chapter 9: Isomorphisms"></a>Chapter 9: Isomorphisms</h1><h2 id="Definitions-and-Examples"><a href="#Definitions-and-Examples" class="headerlink" title="Definitions and Examples"></a>Definitions and Examples</h2><ul><li><p><strong>Isomorphic</strong> (同构)</p><blockquote><p>Two groups $(G, \cdot)$ and $(H, \circ)$ are isomorphic if there exists a one-to-one and onto map $\phi: G\to H$ such that the group operation is preserved; that is,<br>$$\phi(a \cdot b) = \phi(a) \circ \phi(b)$$<br>for all $a$ and $b$ in $G$. If $G$ is isomorphic to $H$, we write $G\cong H$.   </p></blockquote></li><li><p><strong>Isomorphism</strong></p><blockquote><p>The map $\phi$ is called an isomorphism.  </p></blockquote></li><li><p><strong>Theorem 9.6</strong>  </p><blockquote><p>Let $\phi: G\to H$ be an isomorphism of two groups. Then the following statements are true.  </p><ol><li>$\phi^{-1}: H\to G$ is an isomorphism  </li><li>$|G|=|H|$  </li><li>If $G$ is abelian, then $H$ is abelian</li><li>If $G$ is cyclic, then $H$ is cyclic</li><li>If $G$ is a subgroup of order $n$, then $H$ is a subgroup of order $n$</li></ol></blockquote></li><li><p><strong>Theorem 9.7</strong>  </p><blockquote><p>All cyclic groups of infinite order are isomorphic to $\mathbb{Z}$</p></blockquote></li><li><p><strong>Theorem 9.8</strong>  </p><blockquote><p>If $G$ is a cyclic group of order $n$, then G is isomorphic to $\mathbb{Z}_n$.</p></blockquote></li><li><p><strong>Corollary 9.9</strong>  </p><blockquote><p>If $G$ is a group of order $p$, where $p$ is a prime number, then $G$ is isomorphic to $\mathbb{Z}_p$</p></blockquote></li><li><p><strong>Theorem 9.10</strong>  </p><blockquote><p>The isomorphism of groups determines an equivalence relation on the class of all groups.<br>Classifying all groups <strong>up to isomorphism</strong>; two groups are the same if they are isomorphic.  </p></blockquote></li></ul><h3 id="Cayley’s-Theorem"><a href="#Cayley’s-Theorem" class="headerlink" title="Cayley’s Theorem"></a>Cayley’s Theorem</h3><ul><li><p><strong>Theorem 9.12</strong> Cayley   </p><blockquote><p>Every group is isomorphic to a group of permutations.</p></blockquote></li><li><p><strong>Left Regular Representation</strong> of $G$.  </p><blockquote><p>The isomorphism $g\to \lambda_g$<br>where $g\in G$, $\lambda_g(a)=ga$, $\bar{G}=\{\lambda_g:g\in G\}$ is the permutation group that is isomorphic with $G$</p></blockquote></li></ul><h2 id="Direct-Products"><a href="#Direct-Products" class="headerlink" title="Direct Products"></a>Direct Products</h2><h3 id="External-Direct-Products"><a href="#External-Direct-Products" class="headerlink" title="External Direct Products"></a>External Direct Products</h3><ul><li><p><strong>Proposition 9.13</strong>  </p><blockquote><p>Let $G$ and $H$ be groups. The set $G\times H$ is a group under the operation $(g_1, h_1)(g_2, h_2) = (g_1g_2, h_1h_2)$ where $g1, g2 \in G$ and $h_1, h_2 \in H$.</p></blockquote></li><li><p><strong>External Direct Product</strong> of $G$ and $H$ (外直积) </p><blockquote><p>The group $G\times H$</p></blockquote></li><li><p><strong>Theorem 9.17</strong>   </p><blockquote><p>Let $(g, h) \in G\times H$. If $g$ and $h$ have finite orders $r$ and $s$ respectively, then the order of $(g, h)$ in $G\times H$ is the least common multiple of $r$ and $s$. </p></blockquote></li><li><p><strong>Corollary 9.18</strong>  </p><blockquote><p>Let $(g_1, . . . , g_n) \in \prod G_i$. If $g_i$ has finite order $r_i$ in $G_i$, then the order of $G_i$ is the least common multiple of $r_1,\cdots, r_n$.</p></blockquote></li><li><p><strong>Theorem 9.21</strong>  </p><blockquote><p>The group $\mathbb{Z}_m\times \mathbb{Z}<em>n$ is isomorphic to $\mathbb{Z}</em>{mn}$ if and only if $gcd(m,n) = 1$.</p></blockquote></li><li><p><strong>Corollary 9.22</strong>  </p><blockquote><p>Let $n_1, \cdots,n_k$ be positive integers. Then<br>$$\prod_{i=1}^k\mathbb{Z}_{n_i}\cong\mathbb{Z}_{n_1\cdots n_k}$$<br>if and only if $gcd(n_i,n_j)=1$ for $i\ne j$</p></blockquote></li><li><p><strong>Corollary 9.23</strong></p><blockquote><p>If<br>$$m=p_1^{e_1}\cdots p_k^{e_k}$$<br>where the $p_i$s are distinct primes, then<br>$$\mathbb{Z}<em>m\cong\mathbb{Z}</em>{p_1^{e_1}}\times\cdots\times\mathbb{Z}_{p_k^{e_k}}$$</p></blockquote></li></ul><h3 id="Internal-Direct-Products"><a href="#Internal-Direct-Products" class="headerlink" title="Internal Direct Products"></a>Internal Direct Products</h3><ul><li><p><strong>Internal Direct Product</strong> (内直积)</p><blockquote><p>Let $G$ be a group with subgroups $H$ and $K$ satisfying the following conditions.</p><ol><li>$G=HK=\{hk:h\in H,k\in K\}$</li><li>$H\cap K={e}$</li><li>$hk=kh$ for all $k\in K$ and $h\in H$  </li></ol><p>Then G is the internal direct product of H and K.</p></blockquote></li><li><p><strong>Theorem 9.27</strong>  </p><blockquote><p>Let $G$ be the internal direct product of subgroups $H$ and $K$. Then $G$ is isomorphic to $H\times K$.</p></blockquote></li><li><p><strong>Theorem 9.29</strong>  </p><blockquote><p>Let $G$ be the internal direct product of subgroups $H_i$, where $i = 1, 2, \cdots, n$. Then $G$ is isomorphic to $\prod_iH_i$</p></blockquote></li></ul><h1 id="Chapter-10-Normal-Subgroups-and-Factor-Groups"><a href="#Chapter-10-Normal-Subgroups-and-Factor-Groups" class="headerlink" title="Chapter 10: Normal Subgroups and Factor Groups"></a>Chapter 10: Normal Subgroups and Factor Groups</h1><h2 id="Factor-Groups-and-Normal-Subgroups"><a href="#Factor-Groups-and-Normal-Subgroups" class="headerlink" title="Factor Groups and Normal Subgroups"></a>Factor Groups and Normal Subgroups</h2><h3 id="Normal-Subgroups"><a href="#Normal-Subgroups" class="headerlink" title="Normal Subgroups"></a>Normal Subgroups</h3><ul><li><p><strong>Normal Subgroup</strong> of a group $G$ (正规子群)</p><blockquote><p>A subgroup $H$ of a group $G$ is normal in $G$ if $gH = Hg$ for all $g \in G$.<br>A normal subgroup of a group $G$ is one in which the right and left cosets are precisely the same.</p></blockquote></li><li><p><strong>Theorem 10.3</strong></p><blockquote><p>Let $G$ be a group and $N$ be a subgroup of $G$. Then the following statements are equivalent.</p><ol><li>The subgroup $N$ is normal in $G$</li><li>For all $g\in G$, $gNg^{-1}\subset N$</li><li>For all $g\in G$, $gNg^{-1}=N$</li></ol></blockquote></li></ul><h3 id="Factor-Groups"><a href="#Factor-Groups" class="headerlink" title="Factor Groups"></a>Factor Groups</h3><ul><li><p><strong>Factor Group</strong> (因子群) or <strong>Quotient Group</strong> (商群) of $G$</p><blockquote><p>If $N$ is a normal subgroup of a group $G$, then the cosets of $N$ in $G$ form a group $G/N$ under the operation $(aN)(bN) = abN$.<br>This group is called the factor or quotient group of $G$ and $N$.</p></blockquote></li><li><p><strong>Theorem 10.4</strong>  </p><blockquote><p>Let $N$ be a normal subgroup of a group $G$. The cosets of $N$ in $G$ form a group $G/N$ of order $[G : N]$.</p></blockquote></li></ul><h2 id="The-Simplicity-of-the-Alternating-Group"><a href="#The-Simplicity-of-the-Alternating-Group" class="headerlink" title="The Simplicity of the Alternating Group"></a>The Simplicity of the Alternating Group</h2><ul><li><p><strong>Simple Groups</strong> (简单群)</p><blockquote><p>Groups with no nontrivial normal subgroups.</p></blockquote></li><li><p><strong>Lemma 10.8</strong>  </p><blockquote><p>The alternating group $A_n$ is generated by 3-cycles for $n \geq 3$.</p></blockquote></li><li><p><strong>Lemma 10.9</strong>  </p><blockquote><p>Let $N$ be a normal subgroup of $A_n$, where n ≥ 3. If $N$ contains a 3-cycle, then $N = A_n$</p></blockquote></li><li><p><strong>Lemma 10.10</strong>  </p><blockquote><p>For $n \geq 5$, every nontrivial normal subgroup $N$ of $A_n$ contains a 3-cycle.</p></blockquote></li><li><p><strong>Theorem 10.11</strong>  </p><blockquote><p>The alternating group, $A_n$, is simple for $n \geq 5$.</p></blockquote></li></ul><h1 id="Chapter-11-Homomorphisms"><a href="#Chapter-11-Homomorphisms" class="headerlink" title="Chapter 11: Homomorphisms"></a>Chapter 11: Homomorphisms</h1><h2 id="Group-Homomorphisms"><a href="#Group-Homomorphisms" class="headerlink" title="Group Homomorphisms"></a>Group Homomorphisms</h2><ul><li><p><strong>Homomorphism</strong> (同态) between groups $(G, \cdot)$ and $(H, \circ)$</p><blockquote><p>A map $\phi: G\to H$ such that $\phi(g_1\cdot g_2)=\phi(g_1)\circ\phi(g_2)$ for $g_1, g_2 \in G$. </p></blockquote></li><li><p><strong>Homomorphic Image</strong> of $\phi$</p><blockquote><p>The range of $\phi$ in $H$.</p></blockquote></li><li><p><strong>Proposition 11.4</strong></p><blockquote><p>Let $\phi: G_1\to G_2$ be a homomorphism of groups.   </p><ol><li>If $e$ is the identity of $G_1$, then $\phi(e)$ is the identity of $G_2$;  </li><li>For any element $g \in G_1$, $\phi(g^{-1}) = [\phi(g)]^{−1}$;  </li><li>If $H_1$ is a subgroup of $G_1$, then $\phi(H_1)$ is a subgroup of $G_2$;</li><li>If $H_2$ is a subgroup of $G_2$, then $\phi^{-1}(H_2) = \{g \in G_1 : \phi(g) \in H_2\}$ is a subgroup of $G_1$.<br>Furthermore, if $H_2$ is normal in $G_2$, then $\phi^{-1}(H_2)$ is normal in $G_1$.</li></ol></blockquote></li><li><p><strong>Theorem 11.5</strong>  </p><blockquote><p>Let $\phi: G\to H$ be a group homomorphism. Then the kernel of $\phi$ is a normal subgroup of $G$.</p></blockquote></li></ul><h2 id="The-Isomorphism-Theorems"><a href="#The-Isomorphism-Theorems" class="headerlink" title="The Isomorphism Theorems"></a>The Isomorphism Theorems</h2><ul><li><p>The <strong>Natural</strong> or <strong>Canonical Homomorphism</strong></p><blockquote><p>Let $H$ be a normal subgroup of $G$. $\phi:G\to G/H$, $\phi(g)=gH$<br>is the natural or canonical homomorphism.</p></blockquote></li><li><p><strong>Theorem 11.10</strong> First Isomorphism Theorem  </p><blockquote><p>If $\psi : G \to H$ is a group homomorphism with $K = \textrm{ker} \psi$, then $K$ is normal in $G$. Let $\phi : G \to G/K$ be the canonical homomorphism. Then there exists a unique isomorphism $\eta : G/K \to \psi(G)$ such that $\psi = \eta\phi$.</p></blockquote></li><li><p><strong>Theorem 11.12</strong> Second Isomorphism Theorem</p><blockquote><p>Let $H$ be a subgroup of a group $G$ (not necessarily normal in $G$) and $N$ a normal subgroup of $G$. Then $HN$ is a subgroup of $G$, $H \cap N$ is a normal subgroup of $H$, and<br>$$H/H \cap N \cong HN/N$$</p></blockquote></li><li><p><strong>Theorem 11.13</strong> Correspondence Theorem</p><blockquote><p>Let $N$ be a normal subgroup of a group $G$. Then $H \mapsto H/N$  is a one-to-one correspondence between the set of subgroups $H$ containing $N$ and the set of subgroups of $G/N$.<br>Furthermore, the normal subgroups of $G$ containing $N$ correspond to normal subgroups of $G/N$.</p></blockquote></li><li><p><strong>Theorem 11.14</strong> Third Isomorphism Theorem</p><blockquote><p>Let $G$ be a group and $N$ and $H$ be normal subgroups of $G$ with $N \subset H$. Then<br>$$G/H\cong\frac{G/N}{H/N}$$</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Chapter-9-Isomorphisms&quot;&gt;&lt;a href=&quot;#Chapter-9-Isomorphisms&quot; class=&quot;headerlink&quot; title=&quot;Chapter 9: Isomorphisms&quot;&gt;&lt;/a&gt;Chapter 9: Isomorph
      
    
    </summary>
    
    
      <category term="Course" scheme="https://Maxwell-lyu.github.io/tags/Course/"/>
    
      <category term="Problem Solving" scheme="https://Maxwell-lyu.github.io/tags/Problem-Solving/"/>
    
      <category term="Abstract Algebra" scheme="https://Maxwell-lyu.github.io/tags/Abstract-Algebra/"/>
    
  </entry>
  
  <entry>
    <title>Problem Solving IV 02</title>
    <link href="https://Maxwell-lyu.github.io/2019/03/07/Learn-PS-20190307-PS-IV-02/"/>
    <id>https://Maxwell-lyu.github.io/2019/03/07/Learn-PS-20190307-PS-IV-02/</id>
    <published>2019-03-07T12:15:53.000Z</published>
    <updated>2019-06-19T09:39:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>My note when <ruby> previewing<rt> Copying the Textbook of</rt> </ruby>  abstract algebra.<br><a id="more"></a> </p><h1 id="Chapter-5-Permutation-Groups"><a href="#Chapter-5-Permutation-Groups" class="headerlink" title="Chapter 5: Permutation Groups"></a>Chapter 5: Permutation Groups</h1><h2 id="Definitions-and-Notation"><a href="#Definitions-and-Notation" class="headerlink" title="Definitions and Notation"></a>Definitions and Notation</h2><h3 id="Symmetric-Group"><a href="#Symmetric-Group" class="headerlink" title="Symmetric Group"></a>Symmetric Group</h3><ul><li><strong>Symmetric Group</strong> on n letters 对称群  <blockquote><p>$S_X=S_n$ is the permutation of a set $X=\{1,2,\cdots,n\}$  </p></blockquote></li><li><p><strong>Theorem 5.1</strong></p><blockquote><p>The symmetric group on n letters, $S_n$, is a group with $n!$ elements, where the binary operation is the composition of maps.<br>It is not necessarily commutative</p></blockquote><blockquote><p><strong>Proof</strong>:  </p><ol><li>Identity: $\forall x\in X, x\to x$  </li><li>Associative: map composition is associative  </li><li>Inverse: $f^{-1}$ exists since $f$ is one-to-one and onto  </li><li>Size: number of permutations is $n!$  </li></ol></blockquote></li><li><strong>Permutation Group</strong><blockquote><p>A subgroup of $S_n$</p></blockquote></li></ul><h3 id="Cycle-Notation"><a href="#Cycle-Notation" class="headerlink" title="Cycle Notation"></a>Cycle Notation</h3><ul><li><strong>Cycle</strong> of Length $k$ 轮换<blockquote><p>A permutation $\sigma\in S_X$<br>There exists elements $a_1$, $a_2$, $\cdots$, $a_k\in X$ such that<br>$\sigma(a_1)=a_2$, $\sigma(a_2)=a_3$, $\cdots$, $\sigma(a_k)=a_1$<br>$\{a_1,a_2,\cdots,a_k\}$ denotes the cycle $\sigma$<br>Not every permutation is a cycle.</p></blockquote></li><li><strong>Disjoint Cycle</strong><blockquote><p>$\forall i,j,\ a_i\ne b_j$</p></blockquote></li><li><p><strong>Proposition 5.8</strong></p><blockquote><p>Let $\sigma$ and $\tau$ be two disjoint cycles in $S_X$. Then $\sigma\tau=\tau\sigma$</p></blockquote><blockquote><p><strong>Proof</strong>:</p><ol><li>$x$ is neither in $\{a_1,a_2,\cdots,a_k\}$ nor $\{b_1,b_2,\cdots,b_l\}$<br>$\sigma(x)=\tau(x)=x\Rightarrow\sigma\tau(x)=\tau\sigma(x)=x$</li><li>$x$ in $\{a_1,a_2,\cdots,a_k\}$<br>Then $x$ is not in $\{b_1,b_2,\cdots,b_l\}$<br>Because they are disjoint, $\sigma(x)\notin\{b_1,b_2,\cdots,b_l\}$<br>Then $\sigma\tau(x) = \sigma(x)$, and $\tau\sigma(x) = \tau(\sigma(x))=\sigma(x)$</li><li>$\sigma\tau=\tau\sigma$</li></ol></blockquote></li><li><p><strong>Theorem 5.9</strong></p><blockquote><p>Every permutation in $S_n$ can be written as the product of disjoint cycles.</p></blockquote><blockquote><p><strong>Proof</strong>: 咕咕咕</p></blockquote></li></ul><h3 id="Transpositions"><a href="#Transpositions" class="headerlink" title="Transpositions"></a>Transpositions</h3><ul><li><strong>Transpositions</strong> 对换<blockquote><p>Permutation which is a cycle of length 2</p></blockquote></li><li><strong>Proposition 5.12</strong><blockquote><p>Any permutation of a finite set containing at least two elements can be written as the product of transpositions.</p></blockquote></li><li><p><strong>Lemma 5.14</strong></p><blockquote><p>If the identity is written as the product of r transpositions, $id=\tau_1\tau_2\cdots \tau_r$ then r is an even number.</p></blockquote><blockquote><p><strong>Proof</strong>: 咕咕咕 </p></blockquote></li><li><p><strong>Theorem 5.15</strong> </p><blockquote><p>If a permutation $\tau$ can be expressed as the product of an even number of transpositions, then any other product of transpositions equaling $\tau$ must also contain an even number of transpositions.<br>Similarly, if $\tau$ can be expressed as the product of an odd number of transpositions, then any other product of transpositions equaling $\tau$ must also contain an odd number of transpositions.</p></blockquote><blockquote><p><strong>Proof</strong>:<br>$\sigma=\sigma_1\sigma_2\cdots\sigma_m=\tau_1\tau_2\cdots\tau_n$<br>$id=\sigma\sigma^{-1}=\sigma_1\sigma_2\cdots\sigma_m(\tau_1\tau_2\cdots\tau_n)^{-1}=\sigma_1\sigma_2\cdots\sigma_m\tau_1\tau_2\cdots\tau_n$<br>Then $m+n$ must be even.<br>So even+even or odd+odd</p></blockquote></li></ul><h3 id="The-Alternating-Groups"><a href="#The-Alternating-Groups" class="headerlink" title="The Alternating Groups"></a>The Alternating Groups</h3><ul><li>The <strong>Alternation Group</strong> on $n$ <strong>Letters</strong> 交代群<blockquote><p>The set of all even permutations $A_n$ </p></blockquote></li><li><p><strong>Theorem 5.16</strong></p><blockquote><p>The set $A_n$ is a subgroup of $S_n$</p></blockquote><blockquote><p><strong>Proof</strong></p><ol><li>The product of 2 even permutations is even</li><li>The identity is even</li><li>The inverse is even</li></ol></blockquote></li><li><p><strong>Proposition 5.17</strong></p><blockquote><p>The number of even permutations in $S_n$, $n\geq2$, is equal to the number of odd permutations.<br>Hence, the order of $A_n$ is $n!/2$.</p></blockquote><blockquote><p><strong>Proof</strong>:<br>Prove a bijection $\lambda_\sigma(\tau)=\sigma\tau$</p></blockquote></li></ul><h2 id="Dihedral-Groups"><a href="#Dihedral-Groups" class="headerlink" title="Dihedral Groups"></a>Dihedral Groups</h2><ul><li>The n-th <strong>Dihedral Group</strong> 二面体群  <blockquote><p>The group of rigid motions of a regular $n-gon$</p></blockquote></li><li><strong>Theorem 5.20</strong><blockquote><p>The dihedral group, $D_n$, is a subgroup of $S_n$ of order $2n$</p></blockquote></li><li><p><strong>Theorem 5.23</strong></p><blockquote><p>The group $D_n$, $n\geq 3$, consists of all products of the two elements $r$ and $s$, satisfying the relations<br>$$r^n=1$$<br>$$s^2=1$$<br>$$srs = r^{-1}$$</p></blockquote><blockquote><p><strong>Proof</strong>:<br>$r$ is the rotation $r^k=k\frac{360\degree}{n}$, $1,r,r^2\cdots r^{n-1}$<br>$s_i$ is the mirror. If $n$ is even, then there are $n/2$   $s_i$ for each pair of across vertices, and $n/2$ $s_i$ for each pair of across edges. If $n$ is odd, then there are $n$ $s_i$ for each vertex.</p></blockquote></li></ul><h3 id="The-Motion-Group-of-a-Cube"><a href="#The-Motion-Group-of-a-Cube" class="headerlink" title="The Motion Group of a Cube"></a>The Motion Group of a Cube</h3><ul><li>The across vertices of the cube is labeled the same number.  </li><li><strong>Proposition 5.24</strong><blockquote><p>The group of rigid motions of a cube contains 24 elements.</p></blockquote></li><li><strong>Theorem 5.28</strong><blockquote><p>The group of rigid motions of a cube is $S_4$.</p></blockquote></li></ul><h1 id="Chapter-6-Cosets-and-Lagrange’s-Theorem"><a href="#Chapter-6-Cosets-and-Lagrange’s-Theorem" class="headerlink" title="Chapter 6: Cosets and Lagrange’s Theorem"></a>Chapter 6: Cosets and Lagrange’s Theorem</h1><h2 id="Cosets"><a href="#Cosets" class="headerlink" title="Cosets"></a>Cosets</h2><ul><li><strong>Left Coset</strong> of $H$ with <strong>Representative</strong> $g\in G$ 陪集<blockquote><p>$gH=\{gh:h\in H\}$</p></blockquote></li><li><strong>Right Coset</strong> of $H$<blockquote><p>$Hg=\{hg:h\in H\}$</p></blockquote></li><li><strong>Lemma 6.3</strong><blockquote><p>Let $H$ be a subgroup of a group $G$ and suppose that $g_1, g_2 \in G$. The following conditions are equivalent.</p><ol><li>$g_1H=g_2H$</li><li>$Hg_1^{-1}=Hg_2^{-1}$</li><li>$g_1H\subset g_2H$</li><li>$g_2\in g_1H$</li><li>$g_1^{-1}g_2\in H$</li></ol></blockquote></li><li><p><strong>Theorem 6.4</strong>  </p><blockquote><p>Let $H$ be a subgroup of a group $G$. Then the left cosets ofH in $G$ partition $G$. That is, the group $G$ is the disjoint union of the left cosets of $H$ in $G$.</p></blockquote><blockquote><p><strong>Proof</strong>:<br>$g_1H\cap g_2H\ne\emptyset\Rightarrow\exists a=g_1h_1=g_2h_2\Rightarrow g_1=g_2h_2h_1^{-1}\Rightarrow g_1\subset g_2H$<br>By Lemma 6.3, $g_1H=g_2H$</p></blockquote></li><li>The <strong>Index</strong> of $H$ in $G$<blockquote><p>$[G:H]$ the number of left cosets of $H$ in $G$</p></blockquote></li><li><p><strong>Theorem 6.8</strong></p><blockquote><p>Let $H$ be a subgroup of a group $G$. The number of left cosets of $H$ in $G$ is the same as the number of right cosets of $H$ in $G$.</p></blockquote><blockquote><p><strong>Proof</strong>:<br>Find a bijective map $\phi:\mathcal {L}_H\to\mathcal {R}_H$, $\phi(gH)=Hg^{-1}$<br>$Hg_1^{-1}=\phi(g_1H)=\phi(g_2H)=Hg_2^{-1}$<br>By Lemma 6.3</p></blockquote></li></ul><h2 id="Lagrange’s-Theorem"><a href="#Lagrange’s-Theorem" class="headerlink" title="Lagrange’s Theorem"></a>Lagrange’s Theorem</h2><ul><li><p><strong>Proposition 6.9</strong></p><blockquote><p>Let $H$ be a subgroup of $G$ with $g \in G$ and define a map $\phi :H \to gH$ by $\phi(h) = gh$. The map $\phi$ is bijective; hence, the number of elements in $H$ is the same as the number of elements in $gH$.</p></blockquote><blockquote><p><strong>Proof</strong>: 咕咕咕</p></blockquote></li><li><p><strong>Theorem 6.10</strong> Lagrange</p><blockquote><p>Let $G$ be a finite group and let $H$ be a subgroup of $G$. Then $|G|/|H| = [G : H]$ is the number of distinct left cosets of $H$ in $G$. In particular, the number of elements in $H$ must divide the number of elements in $G$.<br>The converse is false.</p></blockquote><blockquote><p><strong>Proof</strong>:<br>The group $G$ is partitioned into $[G : H]$ distinct left cosets. Each left coset has $|H|$ elements; therefore, $|G| = [G : H]|H|$.</p></blockquote></li><li><strong>Corollary 6.11</strong><blockquote><p>Suppose that $G$ is a finite group and $g \in G$. Then the order of $g$ must divide the number of elements in $G$.</p></blockquote></li><li><p><strong>Corollary 6.12</strong></p><blockquote><p>Let $|G| = p$ with $p$ a prime number. Then $G$ is cyclic and any $g \in G$ such that $g \ne e$ is a generator.</p></blockquote><blockquote><p><strong>Proof</strong>: 咕咕咕</p></blockquote></li><li><p><strong>Corollary 6.13</strong></p><blockquote><p>Let $H$ and $K$ be subgroups of a finite group $G$ such that $G\supset H\supset K$. Then<br>$$[G:K]=[G:H][H:K]$$</p></blockquote><blockquote><p><strong>Proof</strong>:<br>$$[G:K]=\frac{|G|}{|K|}=\frac{|G|}{|H|}\frac{|H|}{|K|}=[G:H][H:K]$$</p></blockquote></li><li><p><strong>Proposition 6.15</strong></p><blockquote><p>The group $A_4$ has no subgroup of order 6.</p></blockquote><blockquote><p><strong>Proof</strong>: 咕咕咕</p></blockquote></li><li><p><strong>Theorem 6.16</strong></p><blockquote><p>Two cycles $\tau$ and $\mu$ in $S_n$ have the same length if and only if there exists a $\sigma\in S_n$ such that $\mu = \sigma\tau\sigma^{-1}$.</p></blockquote><blockquote><p><strong>Proof</strong>: 咕咕咕</p></blockquote></li></ul><h2 id="Fermat’s-and-Euler’s-Theorems"><a href="#Fermat’s-and-Euler’s-Theorems" class="headerlink" title="Fermat’s and Euler’s Theorems"></a>Fermat’s and Euler’s Theorems</h2><ul><li>The <strong>Euler $\phi$-Function</strong><blockquote><p>the map $\phi: \mathbb{N}\to\mathbb{N}$ defined by $\phi(n)=1$ for $n = 1$, and, for $n &gt; 1$, $\phi(n)$ is the number of positive integers $m$ with $1 ≤ m &lt; n$ and $gcd(m,n) = 1$.<br>$$\phi(n)=n\prod_{p|n\textrm{ and }p\textrm{ is prime}}(1-\frac{1}{p})$$<br>一个因子一次，例如$8$只需计算一次$p=2$</p></blockquote></li><li><strong>Theorem 6.17</strong> <blockquote><p>Let $U(n)$ be the group of units in $\mathbb{Z}_n$. Then $|U(n)| = \phi(n)$.</p></blockquote></li><li><p><strong>Theorem 6.18</strong> Euler’s Theorem</p><blockquote><p>Let $a$ and $n$ be integers such that $n &gt; 0$ and $gcd(a, n) = 1$. Then $a^{\phi(n)} \equiv 1 (mod\ n)$.</p></blockquote><blockquote><p><strong>Proof</strong>:<br>$|U(n)|=\phi(n)$ by Theorem 6.17<br>$\forall a\in U(n), a^{\phi(n)}=1$<br>$a^{\phi(n)} \equiv 1 (mod\ n)$</p></blockquote></li><li><strong>Theorem 6.19</strong> Fermat’s Little Theorem<blockquote><p>Let $p$ be any prime number and suppose that $p \nmid a$ ($p$ does not divide $a$). Then<br>$$a^{p-1}\equiv 1(mod\ p)$$<br>For any integer $b$, $b^p\equiv b(mod\ p)$</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;My note when &lt;ruby&gt; previewing&lt;rt&gt; Copying the Textbook of&lt;/rt&gt; &lt;/ruby&gt;  abstract algebra.&lt;br&gt;
    
    </summary>
    
    
      <category term="Course" scheme="https://Maxwell-lyu.github.io/tags/Course/"/>
    
      <category term="Problem Solving" scheme="https://Maxwell-lyu.github.io/tags/Problem-Solving/"/>
    
      <category term="Abstract Algebra" scheme="https://Maxwell-lyu.github.io/tags/Abstract-Algebra/"/>
    
  </entry>
  
  <entry>
    <title>Probability Ch2</title>
    <link href="https://Maxwell-lyu.github.io/2019/03/07/Learn-PMS-20190307-PMS-02/"/>
    <id>https://Maxwell-lyu.github.io/2019/03/07/Learn-PMS-20190307-PMS-02/</id>
    <published>2019-03-07T00:04:38.000Z</published>
    <updated>2019-03-21T01:47:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>Probability Course in 2019 Spring<br><a id="more"></a> </p><h1 id="随机变量及其概率分布"><a href="#随机变量及其概率分布" class="headerlink" title="随机变量及其概率分布"></a>随机变量及其概率分布</h1><h2 id="随机变量及其分布函数"><a href="#随机变量及其分布函数" class="headerlink" title="随机变量及其分布函数"></a>随机变量及其分布函数</h2><h3 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h3><ul><li><strong>定义2.1</strong><br>设$\varOmega=\{e\}$是随机试验的样本空间, 如果对每个$e\in\varOmega$, 都对应一个单值实函数$X=X(e)$, 称$X$为随机变量<br>随机变量在某范围内取值表示随机事件</li><li><strong>概率分布</strong><br>随机变量的取值与概率的对应关系, 称之为$X$的概率分布</li></ul><h3 id="随机变量的分布函数"><a href="#随机变量的分布函数" class="headerlink" title="随机变量的分布函数"></a>随机变量的分布函数</h3><ul><li><strong>定义2.2</strong><br>设$X$是一个随机变量, $x$是任意实数, 称函数<br>$$F(X)=P(X\leq x)(-\infty&lt;x&lt;\infty)$$<br>为随机变量$X$的分布函数</li><li><strong>基本性质</strong><ol><li>$F(x)$为单调不减函数, 即对任意实数$x_2&gt;x_1$, 有$F(x_2)\geq F(x_1)$</li><li>$0\leq F(x)\leq 1$, 且$F(-\infty)=\lim_{x\to-\infty}F(x)=0$, $F(+\infty)=\lim_{x\to+\infty}F(x)=1$</li><li>$F(x)$为右连续, 即$F(x_0+0)=\lim{x\to x_0+0}F(x)=F(x_0)$<br>任意随机变量的分布函数必满足这三个性质, 满足这三个性质的必定为某个随机变量的分布函数</li></ol></li></ul><h2 id="离散型随机变量及其分布"><a href="#离散型随机变量及其分布" class="headerlink" title="离散型随机变量及其分布"></a>离散型随机变量及其分布</h2><h3 id="离散型随机变量"><a href="#离散型随机变量" class="headerlink" title="离散型随机变量"></a>离散型随机变量</h3><ul><li><strong>定义2.3</strong><br>若随机变量$X$的可能取值为有限个或可列无限多个, 则称$X$为离散型随机变量</li><li><strong>定义2.4</strong><br>设离散型随机变量$X$的所有可能取值为$x_1,x_2,\cdots,x_n,\cdots$, $X$取值$x_k$的相应概率为$p_k$, 即<br>$$P(X=x_k)=p_k$$<br>称之为离散型随机变量$X$的分布律, 分布律具有如下性质  <ol><li>$p_k\geq0$, $k=1,2,\cdots$</li><li>$\sum_{k}p_k=1$</li></ol></li></ul><h3 id="常见离散型随机变量"><a href="#常见离散型随机变量" class="headerlink" title="常见离散型随机变量"></a>常见离散型随机变量</h3><ul><li><p><strong>0-1分布</strong><br>若随机变量的可能取值只有0, 1, 且<br>$$P(X=1)=p, P(X=0)=q, (0&lt;p&lt;1, q=1-p)$$<br>则称$X$服从0-1分布   </p></li><li><p><strong>二项分布</strong><br> 若随机变量的分布律为<br> $$p_k=P(X=k)=C_n^kp^kq^{n-k}, k=0,1,\cdots, n$$<br> 其中$0&lt;p&lt;1,q=1-p$, 则称$X$服从参数为$n,p$的二项分布, 记为$X\sim B(n,p)$  </p></li><li><p><strong>泊松分布</strong><br>如果随机变量$X$的分布律为<br>$$p_k=P(X=k)=\frac{\lambda^k}{k!}e^{-\lambda}, k=0,1,2,\cdots$$<br>其中$\lambda&gt;0$为常数, 则称$X$服从参数为$\lambda$的泊松分布, 记为$X\sim P(\lambda)$<br>是用于表示<strong>大量试验</strong>中<strong>稀有事件</strong>出现的频数的概率模型  </p><ul><li>$\lambda$的概率意义: 事件的平均发生次数</li></ul></li><li><strong>几何分布</strong><br>若随机变量X的分布律为<br>$$p\{X=k\}=q^{k-1}p$$<br> 其中$0&lt;p&lt;1,q=1-p$, 则称$X$服从参数为$p$的二项分布, 记为$X\sim G(p)$<br>表示贝努里试验进行到事件首次出现为止, 所需次数$X$服从几何分布 </li><li><strong>超几何分布</strong><br>$$p\{X=k\}=\frac{C_M^kC_{N-M}^{n-k}}{C_N^n},k=0,1,\cdots,\min(n,M)$$<br>其中$n,M,N$为参数, 则称$X$服从参数为$n,M,N$的超几何分布, 记为$X\sim H(n,M,N)$<br>表示不放回随机抽样<br>若放回, 则满足二项分布$B(n, \frac{M}{N})$, 若$N\to\infty$, 与二项分布近似相等</li></ul><h2 id="连续型随机变量及其分布"><a href="#连续型随机变量及其分布" class="headerlink" title="连续型随机变量及其分布"></a>连续型随机变量及其分布</h2><h3 id="连续型随机变量"><a href="#连续型随机变量" class="headerlink" title="连续型随机变量"></a>连续型随机变量</h3><ul><li><strong>定义2.5</strong><br>设随机变量$X$的分布函数为$F(x)$, 若存在非负可积函数$p(x)$, 对任意实数$x$有<br>$$F(x)=\int_{-\infty}^xp(t)dt$$<br>则称$X$为连续型随机变量, 称$p(x)$为$X$的概率密度函数, 简称密度函数<br>由定义可见, 任何连续型随机变量的密度函数具有如下性质: <ol><li>$p(x)\geq 0$</li><li>$\int_{-\infty}^{+\infty}p(x)dx=1$</li><li>对于任意实数$a,b(a&lt;b)$<br>$$P(a&lt;X\leq b)=F(b)-F(a)=\int_a^bp(x)dx$$</li><li>由于$p(x)$为可积函数, 根据微积分性质, 分布函数$F(x)$为连续函数</li><li>若$p(x)$在$x$连续, 则分布函数$F(x)$可导, 且$p(x)=F’(x)$</li></ol></li></ul><h3 id="常见连续型随机变量"><a href="#常见连续型随机变量" class="headerlink" title="常见连续型随机变量"></a>常见连续型随机变量</h3><ul><li><strong>均匀分布</strong><br>若随机变量$X$的概率密度函数为<br>$$p(x)=\begin{cases}<br>   \frac{1}{b-a}  &amp;a&lt;x&lt;b \\<br>   0 &amp;其他<br>\end{cases}$$<br>则称$X$在区间$[a,b]$上服从均匀分布, 记为$X\sim U[a,b]$<br>$X$的分布函数为<br>$$F(x)=\begin{cases}<br> 0 &amp;x&lt;a\\<br> \frac{x-a}{b-a} &amp;a\leq x&lt;b\\<br> 1 &amp;x\geq b<br>\end{cases}$$</li><li><strong>指数分布</strong><br>若随机变量$X$的概率密度函数为<br>$$p(x)=\begin{cases}<br> \lambda e^{-\lambda x} &amp; x\geq 0\\<br> 0 &amp;x&lt;0<br>\end{cases}$$<br>则称$X$服从参数为$\lambda$的指数分布, 记为$X\sim E(\lambda)$<br>$X$的分布函数为<br>$$F(X)=\begin{cases}<br> 1-e^{-\lambda x} &amp;x\geq 0\\<br> 0 &amp;其他<br>\end{cases}$$</li><li><strong>正态分布</strong><br>若随机变量$X$的密度函数为<br>$$p(x)=\frac{1}{\sqrt{2\pi\sigma}}e^{-\frac{(t-\mu)^2}{2\sigma^2}}dt,-\infty &lt; x &lt;\infty$$<br>其中$\mu,\sigma(&gt;0)$为常数, 则称$X$服从参数为$\mu,\sigma^2$的正态分布, 记为$X\sim N(\mu, \sigma^2)$<br> 正态分布的分布函数为<br> $$F(x)=\int_{-\infty}^x\frac{1}{\sqrt{2\pi\sigma}}e^{-\frac{(t-\mu)^2}{2\sigma^2}}dt$$<br> 当$\mu=0, \sigma =1$时, $X\sim N(0, 1)$, 称$X$服从<strong>标准正态分布</strong>, 其密度函数和分布函数特别记为$\varphi(x)$和$\varPhi(x)$<br> $$\varphi(x)=\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}$$<br> $$\varPhi(x)=\int_{-\infty}^x\frac{1}{\sqrt{2\pi}}e^{-\frac{t^2}{2}}$$<br> 对标准正态分布的分布函数$varPhi(x)$有, $\varPhi(-x)=1-\varPhi(x)$</li><li><strong>定理2.1</strong><br>若随机变量$X\sim N(\mu, \sigma^2)$, 则$Z=\frac{X-\mu}{\sigma}\sim N(0, 1)$</li></ul><h2 id="随机变量函数的分布"><a href="#随机变量函数的分布" class="headerlink" title="随机变量函数的分布"></a>随机变量函数的分布</h2><ul><li><strong>随机变量的函数</strong><br> 设$X$是随机变量, $y=g(x)$是普通实函数。构造随机变量$Y$, $X$当取值时$x$时, $Y$取值$y=g(x)$，称$Y$是随机变量$X$的函数，记为$Y=g(X)$. 我们需要讨论，已知$X$的概率分布，如何求$Y=g(X)$的概率分布. 分为离散型和连续型两种情况讨论. </li></ul><h3 id="离散型随机变量的函数"><a href="#离散型随机变量的函数" class="headerlink" title="离散型随机变量的函数"></a>离散型随机变量的函数</h3><ul><li>设$X$是离散型随机变量, 其分布律为$x_k\mapsto p_k$, 对于$X$的函数$Y=g(X)$, $Y$也是离散型随机变量  <ol><li>若$y_1,y_2,\cdots, y_n,\cdots$互不相同, 则:<br>$$P(Y=y_k)=P(Y=g(x_k))=P(X=x_k)=p_k$$</li><li>若有相同的, 则相同的$y_k$对应的概率相加:<br>$$P(Y=y_k)=\sum_{i:y_k=g(x_i)}P(X=x_i)$$</li></ol></li></ul><h3 id="连续型随机变量的函数"><a href="#连续型随机变量的函数" class="headerlink" title="连续型随机变量的函数"></a>连续型随机变量的函数</h3><ul><li>设$X$是连续型随机变量, $y=g(x)$为连续实函数, 则$Y=g(X)$也是连续型随机变量. 己知$X$的密度函数$p_X(x)$，求$Y$的密度函数$p_Y(y)$.<br>常用的方法是分布函数法，即先求Y的分布函数$F_Y(y)$<br>$$F_Y(y)=P(Y\leq y)=P(g(X)\leq y)=\int_{x:g(x)\leq y}p_X(x)dx$$</li><li><p>然后$p_Y=(y)=F’_Y(y)$</p></li><li><p><strong>定理</strong><br>若随机变量$X$的分布函数$F(x)$严格单调递增, 则随机变量$Y=F(X)$服从$[0,1]$上的均匀分布</p></li><li><p><strong>定理2.2</strong><br> 设随机变量$X$的可能取值范围为$(a,b)$, $X$的概率密度为$p(x)$，$a&lt;x&lt;b$(其中$a$可为$-\infty$, $b$可为$+\infty$), 设函数$y=(x)$处处可导, 且恒有$g’(x)&gt;0$(或恒有$g’(x)&lt;0$), 则$Y=g(X)$为连续型随机变量，其概率密度为<br> $$p_Y(y)=\begin{cases}<br> p_X[g^{-1}(y)]\cdot|[g^{-1}(y)]’| &amp;\alpha&lt;y&lt;\beta\\<br> 0 &amp;其他<br> \end{cases}$$<br> 其中$\alpha=\min\{g(a),g(b)\}$, $\beta=\max\{g(a),g(b)\}$, $g^{-1}(y)$为$y=g(x)$的反函数</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Probability Course in 2019 Spring&lt;br&gt;
    
    </summary>
    
    
      <category term="Course" scheme="https://Maxwell-lyu.github.io/tags/Course/"/>
    
      <category term="Probability and Mathematical Statistics" scheme="https://Maxwell-lyu.github.io/tags/Probability-and-Mathematical-Statistics/"/>
    
  </entry>
  
  <entry>
    <title>Logic Ch1</title>
    <link href="https://Maxwell-lyu.github.io/2019/03/01/Learn-ML-20190301-ML-01/"/>
    <id>https://Maxwell-lyu.github.io/2019/03/01/Learn-ML-20190301-ML-01/</id>
    <published>2019-03-01T07:17:50.000Z</published>
    <updated>2019-03-11T11:28:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>Logic Course in 2019 Spring<br><a id="more"></a> </p><h1 id="第一讲：命题逻辑"><a href="#第一讲：命题逻辑" class="headerlink" title="第一讲：命题逻辑"></a>第一讲：命题逻辑</h1><h2 id="命题逻辑的语法"><a href="#命题逻辑的语法" class="headerlink" title="命题逻辑的语法"></a>命题逻辑的语法</h2><p><strong>定义1.1</strong>(字母表)  </p><ol><li>命题符：$P_0,P_1,P_2,\cdots,P_n,\cdots,n\in \mathbb{N}$, 记$PS=\{P_n|n\in\mathbb{N}\}$  </li><li>联结词：$\neg$, $\wedge$, $\vee$, $\rightarrow$  </li><li>辅助符：$($, $)$</li></ol><p><strong>定义1.2</strong>(命题)</p><ol><li>命题符为命题  </li><li>若$A$, $B$为命题, 则$(\neg A)$, $(A\wedge B)$, $(A\vee B)$, $(A\rightarrow B)$为命题  </li><li>命题仅限于此  </li><li><strong>BNF范式</strong>表达：$\varphi\Coloneqq P|(\neg\varphi)|(\varphi_1\wedge\varphi_2)|(\varphi_1\vee\varphi_2)|(\varphi_1\rightarrow\varphi_2),P\in PS$ </li><li><strong>闭包法</strong>也可定义命题<br> 令$C_\neg$, $C_\wedge$, $C_\vee$, $C_\rightarrow$为所有字母表符号串之集上的函数：<br> $$C_\neg(A)=(\neg A)$$<br> $$C_*(A,B)=(A*B)$$<br> 这里$*\in \{\wedge, \vee, \rightarrow\}$  </li></ol><p><strong>定义1.3</strong>(命题集)<br>所有命题的集合$PROP$是满足以下条件的最小集合：</p><ol><li>$PS\subseteq PROP$</li><li>若$A\in PROP$, 则$C_\neg(A)\in PROP$</li><li>若$A,B\in PROP$, 则$C_\wedge(A,B)$, $C_\vee(A,B)$, $C_\rightarrow(A,B)\in PROP$</li><li>即$PROC$为函数$C_\neg$, $C_\wedge$, $C_\vee$, $C_\rightarrow$下$PS$的归纳闭包</li></ol><p><strong>引理1.4</strong>(括号引理)<br>若$A$为命题, 则$A$中所有左括号的个数等于右括号的个数</p><p><strong>引理1.5</strong><br>$A\in PROP$等价于存在有穷序列$A_0,A_1,\cdots,A_n$使$A$为$A_n$且对任何$i\leq n$,   </p><ul><li>或(a) $A_i\in PS$  </li><li>或(b) 存在$k&lt;i$使$A_i$为$\neg A_k$  </li><li>或(c) 存在$k,l&lt;i$使$A_i$为$(A_k*A_l)$, 这里$*$为$\wedge$,   $\vee$, $\rightarrow$之一<br>以上序列$A_0,A_1,\cdots,A_n$被称为$A$的<strong>构造序列</strong>  </li></ul><p><strong>结构归纳</strong></p><ul><li>每个命题皆有构造过程, 但构造过程不一定唯一</li><li>若$A_0,A_1,\cdots,A_n$为$A$的最短构造过程, 则称$n$为$A$的<strong>构造长度</strong></li><li>对$A$的结构作归纳证明一些性质, 事实上是对$A$的构造长度作归纳, 而这是自然数上的归纳</li></ul><h2 id="命题的语义"><a href="#命题的语义" class="headerlink" title="命题的语义"></a>命题的语义</h2><p><strong>什么是命题的语义</strong><br>对于任意的<strong>赋值</strong>, $v:PS\rightarrow\{T,F\}$, 定义一个<strong>解释</strong><br>$$\hat{v}:PROP\rightarrow\{T,F\}$$  </p><p><strong>定义1.6</strong><br>令真值集$B=\{T,F\}$</p><ul><li>联结词$\neg$被解释为一元函数$H_\neg:B\rightarrow B$</li><li>联结词$*$被解释为二元函数$H_*:B^2\rightarrow B$<br>这里$*\in \{\wedge, \vee, \rightarrow\}$ </li><li>定义为真值表, 此处略</li></ul><p><strong>定义1.7</strong>(命题的语义)  </p><ul><li>$v$为一个赋值, 指它为函数$v:PS\rightarrow B$<br>从而对任何命题符$P-i$, $v(P_i)$为$T$或$F$</li><li><p>对于任何赋值$v$, 定义$\hat{v}：PROP\rightarrow B$如下：  </p><ul><li>$\hat{v}(P_n)=v(P_n)$, $n\in\mathbb{N}$</li><li>$\hat{v}(\neg A)=H_\neg(\hat{v}(A))$</li><li>$\hat{v}(A * B)=H_*(\hat{v}(A), \hat{v}(B))$, 这里$*\in \{\wedge, \vee, \rightarrow\}$<blockquote><p>  确实应该是$H_*(\hat{v}(A),\hat{v}(B))$</p></blockquote></li></ul></li><li><p><strong>引理1.8</strong><br>设$A$为命题, $v_1$, $v_2$为赋值, 若$v_1\upharpoonright FV(A)=v_2\upharpoonright FV(A)$, 即对于$P\in FV(A)$, $v_1(P)=v_2(P)$, 则$\hat{v_1}(A)=\hat{v_2}(A)$</p></li><li><p><strong>定义1.9</strong><br>设$A$为命题, $v$为赋值  </p><ol><li>$v$满足$A$, 记为$v\vDash A$, 指$\hat{v}(A)=T$</li><li>$A$为永真式(tautology), 记为$\vDash A$, 指对任何$v$有$\hat{v}(A)=T$</li><li>$A$可满足, 指有$v$使$v\vDash A$</li><li>设$\Gamma$为命题集, $A$为$\Gamma$的语义结论, 记为$\Gamma\vDash A$, 指对所有$v$, 若对任何$B\in \Gamma$有$\hat{v}(B)=T$, 则$\hat{v}(A)=T$</li></ol></li><li><p><strong>定义1.10</strong><br>设$A$为命题, $FV(A)=\{Q_1, \cdots, Q_n\}$. $n$元函数$H_A:B^n\to B$定义如下: 对于任何$(a_1,\cdots,a_n)\in B^n$, $H_A(a_1,\cdots, a_n)=\hat{v}(A)$, 这里赋值$v$满足$v(Q_i)=a_i(1\leq i\leq n)$. 下面称$f:B^n\to B$为$n$元真值函数, 称$H_A$为$A$定义的真值函数</p></li><li><p><strong>定义1.11</strong>  </p><ol><li>命题$A$为析合范式($\vee\wedge$-nf)指$A$呈形$\bigvee_{i=1}^m(\bigwedge_{k=1}^nP_{i,k})$, 这里$P_{i,k}$为命题符或命题符的否定(即呈形$\neg P_i$)</li><li>命题$A$为合析范式($\wedge\vee$-nf)指$A$呈形$\bigwedge_{i=1}^l(\bigvee_{k=1}^nQ_{i,k})$, 这里$Q_{i,k}$为命题符或命题符的否定(即呈形$\neg Q_i$)<br>其中$\bigwedge_{k=1}^n$为$(\cdots(((B_1\wedge B_2)\wedge B_3)\cdots\wedge B_n)\cdots)$的简写; $\bigvee_{k=1}^n$为$(\cdots(((B_1\vee B_2)\vee B_3)\cdots\vee B_n)\cdots)$的简写</li></ol></li><li><p><strong>定理1.12</strong>  </p><ol><li>存在命题$A$, 其为$\vee\wedge$-nf使$f=H_A$</li><li>存在命题$A’$, 其为$\wedge\vee$-nf使$f=H_{A’}$</li></ol></li><li><p><strong>定义1.13</strong>  </p><ol><li>设$A, B$为命题, $A$与$B$逻辑等价, 记为$A\simeq B$, 指对任何赋值$v$,<br>$$v\vDash A\textrm{ iff }v\vDash B$$</li></ol></li><li><p><strong>命题1.14</strong>  </p><ol><li>$A\simeq A$</li><li>若$A\simeq B$, 则$B\simeq A$</li><li>若$A\simeq B$且$B\simeq C$, 则$A\simeq C$</li><li>若$A\simeq B$, 则$(\neg A)\simeq (\neg B)$</li><li>若$A_1\simeq B_1$且$A_2\simeq B_2$, 则$(A_1* A_2)\simeq(B_1*B_2)$, 这里$*\in\{\wedge,\vee,\rightarrow\}$</li></ol></li><li><p><strong>命题1.15</strong><br>设$FV(A\wedge B)=\{Q_1, \cdots, Q_n\}$且$H_A:B^n\rightarrow B$, $H_B:B^n\rightarrow B$. 我们有$A\simeq B\textrm{ iff }H_A=H_B$</p></li><li><p><strong>命题1.16</strong><br>若$A$为命题，则存在$\wedge\vee$-nf$B$和$\vee\wedge$-nf$B’$使$A\simeq B$且$A\simeq B’$, 这时称$B$和$B’$分别为$A$的$\wedge\vee$-nf和$\vee\wedge$-nf</p></li></ul><h2 id="自然推理系统及其性质"><a href="#自然推理系统及其性质" class="headerlink" title="自然推理系统及其性质"></a>自然推理系统及其性质</h2><ul><li><p><strong>定义1.17</strong><br>一个矢列是一个二元组$(\Gamma, \Delta)$, 记为$\Gamma\vdash\Delta$, 这里$\Gamma, \Delta$为命题的有穷集合(可以为空), 称$\Gamma$为前件, $\Delta$为后件. 命题逻辑的自然推理系统$G’$由以下公里和规则组成, $\Gamma, \Delta, \Lambda, \Theta$表示任何命题有穷集合, $A, B$表示任何命题, $\Lambda, A, \Delta$为集合$\Lambda\cup\{A\}\cup\Delta$的缩写  </p><ul><li>公理: 左右两边有一样的</li><li>规则: <ul><li>否定调换左右</li><li>左或右且分为两个</li><li>左且右或逗号隔开</li><li>箭头看作有否定的或</li><li>$$\textrm{Cut}: \frac{\Gamma\vdash\Lambda,A\quad\Delta,A\vdash\Theta}{\Gamma,\Delta\vdash\Lambda,\Theta}$$<br>规则的上矢列被称为前提, 下矢列被称为结论. $G’$系统中的规则被称为推理规则, 规则中被作用的命题被称为主命题, 而不变的命题被称为辅命题</li></ul></li></ul></li><li><p><strong>定义1.18</strong><br>设$\Lambda$为$\{A_1,A_2,\cdots, A_m\}$, $\Delta$为$\{B_1,B_2,\cdots, B_n\}$  </p><ol><li>$\Lambda\vdash\Delta$有反例(falsifiable)指存在赋值$v$使$v\vDash(A_1\wedge \cdots\wedge A_m)\wedge(\neg B_1\wedge\cdots\wedge\neg B_n)$, 这时称$v$反驳$\Lambda\vdash\Delta$  </li><li>$\Lambda\vdash\Delta$有效(valid)指对任何赋值$v$, $v\vDash(A_1\wedge\cdots\wedge A_m)\rightarrow(B_1\vee B_2\vee\cdots\vee B_n)$, 这时称$v$满足$\Lambda\vdash\Delta$  </li><li>$\Lambda\vdash\Delta$有效也被记为$\Lambda\vDash\Delta$</li><li>当$m=0$时, $\vdash B_1,\cdots B_n$有反例指$(\neg B_1\wedge\cdots\wedge\neg B_n)$可满足; $\vdash B_1,\cdots B_n$有效指$(B_1\vee \cdots\vee B_n)$永真</li><li>当$n=0$时, $A_1,\cdots A_n\vdash$有反例指$(A_1\wedge \cdots\wedge A_m)$可满足; $A_1,\cdots A_n\vdash$有效指$(A_1\wedge \cdots\wedge A_m)$不可满足</li><li>约定$\{\}\vdash\{\}$非有效</li></ol></li><li><p><strong>命题1.19</strong><br>$\Gamma\vdash\Delta$有效$\textrm{ iff }$$\Gamma\vdash\Delta$无反例</p></li><li><p><strong>引理1.20</strong><br>对于$G’$系统中的每条异于$\textrm{Cut}$的规则:   </p><ol><li>赋值$v$反驳规则的结论$\textrm{ iff }$$v$至少反驳规则的一个前提</li><li>$v$满足规则的结论$\textrm{ iff }$$v$满足规则的所有前提</li><li>每个前提有效$\textrm{ iff }$结论有效</li></ol></li><li><p><strong>定义1.21</strong><br>设$\Gamma\vdash\Lambda$为矢列, 树$T$为$\Gamma\vdash\Lambda$的证明树指:  (见书本图片)</p></li><li><p><strong>定义1.22</strong><br>设$\Gamma\vdash\Lambda$为矢列, $\Gamma\vdash\Lambda$可证(provable)指存在$\Gamma\vdash\Lambda$的证明树</p></li></ul><ul><li><p><strong>定理1.23</strong>($G’$的soundness)<br>若$\Gamma\vdash\Delta$在$G’$中可证, 则$\Gamma\vdash\Delta$有效  </p></li><li><p><strong>定理1.24</strong>($G’$的completeness)<br>若$\Gamma\vdash\Delta$有效, 则$\Gamma\vdash\Delta$在$G’$中可证. 这就是$G’$的完全性</p></li><li><p><strong>系1.25</strong><br>$\Gamma\vdash\Delta$可证$\textrm{ iff }$$\Gamma\vdash\Delta$有效</p></li><li><p><strong>系1.26</strong><br>若$\Gamma\vdash\Delta$在$G’$中可证, 则$\Gamma\vdash\Delta$在$G’$中由一个无$\textrm{Cut}$证明</p></li><li><p><strong>定理1.27</strong>(compactness)<br>设$\Gamma$为命题的集合, 若$\Gamma$的任何有穷子集可满足, 则$\Gamma$可满足</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Logic Course in 2019 Spring&lt;br&gt;
    
    </summary>
    
    
      <category term="Course" scheme="https://Maxwell-lyu.github.io/tags/Course/"/>
    
      <category term="Mathematical Logic" scheme="https://Maxwell-lyu.github.io/tags/Mathematical-Logic/"/>
    
  </entry>
  
  <entry>
    <title>Probability Ch1</title>
    <link href="https://Maxwell-lyu.github.io/2019/02/28/Learn-PMS-20190228-PMS-01/"/>
    <id>https://Maxwell-lyu.github.io/2019/02/28/Learn-PMS-20190228-PMS-01/</id>
    <published>2019-02-28T00:29:38.000Z</published>
    <updated>2019-04-27T01:12:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>Probability Course in 2019 Spring<br><a id="more"></a> </p><h1 id="随机事件与概率"><a href="#随机事件与概率" class="headerlink" title="随机事件与概率"></a>随机事件与概率</h1><h2 id="随机事件及其运算"><a href="#随机事件及其运算" class="headerlink" title="随机事件及其运算"></a>随机事件及其运算</h2><h3 id="随机试验与随机事件"><a href="#随机试验与随机事件" class="headerlink" title="随机试验与随机事件"></a>随机试验与随机事件</h3><ul><li><strong>随机现象</strong>：非确定性现象</li><li><strong>随机试验</strong>：$E$：对随机现象的的一次观测</li><li><strong>样本空间</strong>：$\varOmega$：所有可能结果的集合</li><li><strong>基本事件</strong>或<strong>样本点</strong>：$e$：样本空间的元素, 即$E$的每个可能结果</li><li><strong>随机事件</strong>：$A,B,C$等：样本空间$\varOmega$的子集合, 简称事件</li></ul><h3 id="事件间的关系及运算"><a href="#事件间的关系及运算" class="headerlink" title="事件间的关系及运算"></a>事件间的关系及运算</h3><ol><li>事件间的关系<ol><li><strong>包含关系</strong><br>如果事件$A$发生必然导致事件$B$发生, 则事件$B$包含事件$A$, 记$B\supset A$  </li><li><strong>互不相容关系</strong><br>若事件$A$与$B$不可能同时发生, 则称$A,B$互不相容（或互斥）, 此时$A$与$B$没有共同的样本点  </li><li><strong>相等关系</strong><br>若$B\supset A$, 且$A\supset B$, 则称$A$与$B$相等, 记为$A=B$, 两者样本点完全相同</li></ol></li><li>事件的运算<ol><li><strong>事件的并</strong><br>事件$A$与$B$至少发生一个所构成的事件成为$A$与$B$的并, 记为$A\cup B$, 其样本点由$A$与$B$的样本点合并而成<br>事件$A_1,A_2,\cdots,A_n$至少发生一个的事件称为$A_1,A_2,\cdots,A_n$的并, 记为$A_1\cup A_2\cup\cdots\cup A_n$或$\bigcup_{i=1}^nA_i$  </li><li><strong>事件的交</strong><br>事件$A$与$B$同时发生的事件成为$A$与$B$的交, 记为$A\cap B$或$AB$, 其样本点由$A$与$B$共同的样本点而成<br>事件$A_1,A_2,\cdots,A_n$同时发生的事件称为$A_1,A_2,\cdots,A_n$的交, 记为$A_1\cap A_2\cap\cdots\cap A_n$或$\bigcap_{i=1}^nA_i$或$A_1A_2\cdots A_n$  </li><li><strong>事件的差</strong><br>事件$A$发生而$B$不发生的事件称为$A$与$B$的差, 记为$A-B$, 其样本点由$A$中除去$B$的样本点组成  </li><li><strong>对立事件</strong><br>$A$不发生的事件称为$A$的对立事件, 记为$\bar{A}$, 其样本点由$\varOmega$中除$A$以外的样本点组成   </li><li><strong>注意如下等式</strong>  <ol><li>$A=(A-B)\cup AB$  </li><li>$A\cup B = A\cup (B-A)=(A-B)\cup AB \cup (B-A)$  </li><li>$A-B=A-AB=A\bar{B}$</li><li>$\bar{A}=\varOmega-A,A\cup\bar{A}=\varOmega$  </li></ol></li><li><strong>满足如下运算律</strong>  <ol><li>交换律 $A\cup B=b\cup A, A\cap B=B\cap A$</li><li>结合律 $(A\cup B)\cup C=A\cup(B\cup C),(A\cap B)\cap C=A\cap(B\cap C)$  </li><li>分配律 $A\cup(B\cap C)=(A\cup B)\cap(A\cup C),A\cap(B\cup C)=(A\cap B)\cup(A\cap C)$  </li><li>德摩根定律 $\overline{A\cup B}=\bar{A}\cap\bar{B},\overline{A\cap B}=\bar{A}\cup\bar{B}$</li></ol></li></ol></li></ol><h2 id="事件的概率及性质"><a href="#事件的概率及性质" class="headerlink" title="事件的概率及性质"></a>事件的概率及性质</h2><h3 id="频率与概率"><a href="#频率与概率" class="headerlink" title="频率与概率"></a>频率与概率</h3><ul><li><strong>频率</strong>：设随机事件$A$在$n$次重复实验中共出现$n_A$次, 将其比值$n_A/n$定义为$A$发生的频率, 记为$f_n(A)$, 即<br>$$f_n(A)=\frac{n_A}{n}$$ </li><li><strong>频率的性质</strong>  <ol><li>$0\leq f_n(A)\leq 1$</li><li>$f_n(\varOmega)=1$</li><li>若$A_1, A_2,\cdots, A_n$互不相容, 则<br>$$f_n(\bigcup_{i=1}^nA_i)=\sum_{i=1}^nf_n(A_i)$$</li></ol></li><li><strong>频率的稳定性</strong>与<strong>统计概率</strong><br>随试验次数的增加, 事件的频率将在某个数值附近稳定地摆动, 此数值定义为$A$发生的概率, 称为统计概率</li></ul><h3 id="概率的定义及性质"><a href="#概率的定义及性质" class="headerlink" title="概率的定义及性质"></a>概率的定义及性质</h3><ul><li><strong>定义1.1</strong><br>设$E$是随机实验, $\varOmega$为其样本空间。对于$E$的每一个随机事件$A$, 对应一个实数$P(A)$, 如果几何函数$P(\cdot)$满足：  <ol><li>非负性 $P(A)\geq 0$</li><li>规范性 $P(\varOmega)=1$</li><li>可列可加性 若$A_1, A_2,\cdots, A_n,\cdots$两两互不相容, 则<br>$$P(\bigcup_{i=1}^\infty A_i)=\sum_{i=1}^\infty P(A_i)$$<br>则称$P(A)$为事件$A$的概率</li></ol></li><li><strong>概率的性质</strong><ol><li>$P(\varPhi)=0$</li><li>若$A_1, A_2,\cdots, A_n$为$n$个两两互不相容事件, 则有<br>$$P(\bigcup_{i=1}^nA_i)=\sum_{i=1}^nP(A_i)$$</li><li>对任意两事件$A,B$有<br>$$P(A-B)=P(A)-P(AB)$$</li><li>对任意两事件$A,B$有<strong>加法定理</strong><br>$$P(A\cup B)=P(A)+P(B)-P(A\cap B)$$<br>利用归纳法推广：<br>$$P(\bigcup_{i=1}^nA_i)=\sum_{i=1}^nP(A_i)-\sum_{1\leq i\leq j\leq n}P(A_iA_j)+\sum_{1\leq i\leq j\leq k\leq n}P(A_iA_jA_k)+\cdots+(-1)^{n-1}P(A_1A_2\cdots A_n)$$</li><li>对任意事件$A$, $P(\bar{A})=1-P(A)$</li></ol></li></ul><h2 id="等可能概型（古典概型）"><a href="#等可能概型（古典概型）" class="headerlink" title="等可能概型（古典概型）"></a>等可能概型（古典概型）</h2><ul><li><strong>古典概型</strong>  <ol><li>样本空间$\varOmega$的元素个数为有限个</li><li>样本空间中每个基本事件（基本点）发生的可能性相同</li></ol></li><li><strong>计算</strong><br>  $$P(A)=\frac{m}{n}=\frac{A包含的样本点数}{样本点总数}$$</li><li><strong>不放回抽样</strong><br>$N$件产品, $M$件次品, 取出$n$件, 有$k$件次品<br>  $$p = \frac{C_m^kC_{N-M}^{n-k}}{C_N^n}$$</li><li><strong>有放回抽样</strong><br>$N$件产品, $M$件次品, 取出$n$件, 有$k$件次品<br> $$p=\frac{C_n^kM^k(N-M)^{n-k}}{N^n}=C_n^k(\frac{M}{N})^k(1-\frac{M}{N})^{n-k}$$</li></ul><h2 id="几何概率"><a href="#几何概率" class="headerlink" title="几何概率"></a>几何概率</h2><ul><li><strong>定义1.2</strong><br>若随机试验的样本空间对应一个度量有限的几何区域$S$, 每一基本事件与$S$内任意点一一对应, 则任一随机事件对应$n$中的某一子区域$D$.若事件的概率只和对应的区域$D$的度量成正比, 与的形状及$D$在$S$中的位置无关。发生的概率定义为<br>$$P(A)=\frac{m(A)}{n(\Omega)}=\frac{A对应区域D的度量}{\Omega对应区域S的度量}$$</li></ul><h2 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h2><h3 id="条件概率-1"><a href="#条件概率-1" class="headerlink" title="条件概率"></a>条件概率</h3><ul><li><p><strong>定义1.3</strong><br>设$A$, $B$为两个随机事件, 且$P(B)&gt;0$, 称<br>$$P(A|B)=\frac{P(AB)}{P(B)}$$  </p><p>为在事件$B$发生的条件下, 事件$A$发生的概率, 概率的性质仍适用  </p></li></ul><h3 id="乘法公式"><a href="#乘法公式" class="headerlink" title="乘法公式"></a>乘法公式</h3><ul><li><p><strong>乘法公式</strong><br>由条件概率公式可以得到, 当$P(B)&gt;0$时,<br>$P(AB)=P(B)P(A|B)$<br>$P(AB)=P(A)P(B|A)$</p><p>推广：设$A_1,A_2,\cdots,A_n$为$n$个随机事件, 当$P(A_1,A_2,\cdots,A_n)&gt;0$时,<br>$P(A_1A_2\cdots A_n)=P(A_1)P(A_2|A_1)P(A_3|A_1A_2)\cdots P(A_n|A_1A_2\cdots A_{n-1})$ </p></li></ul><h3 id="全概率公式与贝叶斯公式"><a href="#全概率公式与贝叶斯公式" class="headerlink" title="全概率公式与贝叶斯公式"></a>全概率公式与贝叶斯公式</h3><ul><li><strong>定义1.4</strong><br>若$n$个事件$A_1,A_2,\cdots,A_n$满足<ol><li>$A_1,A-2,\cdots,A_n$两两互不相容</li><li>$A_1\cup A_2\cup\cdots\cup A_n=\varOmega$<br>则称$A_1,A_2,\cdots,A_n$为样本空间$\varOmega$的一个<strong>划分</strong>或<strong>完备事件组</strong><br>若事件$A_1,A_2,\cdots,A_n$为完备事件组, 则在随机试验的每次试验中, $A_1,A_2,\cdots,A_n$必发生且仅发生一个</li></ol></li><li><strong>定理1.1</strong>（全概率公式）<br>设$A_1,A_2,\cdots,A_n$为完备事件组, 则对事件$B$有<br>$$P(B)=\sum_{k=1}^nP(A_k)P(B|A_k)$$</li><li><strong>定理1.2</strong>（贝叶斯公式）<br>设$A_1,A_2,\cdots,A_n$为完备事件组, 则对事件$B$有<br>$$P(A_i|B)=\frac{P(A_i)P(B|A_i)}{\sum_{k=1}^nP(A_k)P(B|A_k)}$$  </li></ul><h2 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h2><h3 id="独立性定义"><a href="#独立性定义" class="headerlink" title="独立性定义"></a>独立性定义</h3><ul><li><strong>定义1.5</strong><br>设$A$, $B$是两个随机事件, 若满足等式<br>$$P(AB)=P(A)P(B)$$<br>则称事件$A$, $B$<strong>相互独立</strong>, 简称<strong>独立</strong></li><li><strong>定理1.3</strong><br>若随机事件$A$与$B$相互独立, 则$\bar{A}$与$B$, $A$与$\bar{B}$, $\bar{A}$与$\bar{B}$也相互独立  </li></ul><h3 id="多个事件的独立性"><a href="#多个事件的独立性" class="headerlink" title="多个事件的独立性"></a>多个事件的独立性</h3><ul><li><strong>定理1.4</strong>（分组独立性定理）<br>设事件$A_1,A_2,\cdots,A_n$相互独立, 将其任意分为没有公共事件的$k$个组, 每个组任意做事件运算, 得到一个新事件, 则这$k$个新事件相互独立</li><li><p><strong>$n$个事件独立性</strong><br>对$n$个事件$A_1,A_2,\cdots,A_n$, 如果下列等式成立<br>$$\begin{cases}<br>  P(A_iA_j)=P(A_i)P(A_j) \\<br>  P(A_iA_jA_k)=P(A_i)P(A_j)P(A_k) \\<br>  \cdots \cdots \\<br>  P(A_{i_1}A_{i_2}\cdots A_{i_m})=P(A_{i_1})P(A_{i_2})\cdots P(A_{i_m})\\<br>  \cdots \cdots \\<br>  P(A_1A_2\cdots A_n) = P(A_1)P(A_2)\cdots P(A_n)<br>\end{cases}$$<br>则称事件$A_1,A_2,\cdots,A_n$相互独立</p></li><li><p><strong>小概率事件原理</strong><br>设随机试验中某事件$A$发生的概率为$p$, 无论$p$多么小, 只要不断重复独立地做$n$次实验, $A$迟早会发生的概率为1<br>$$P(A_1\cup A_2 \cup\cdots A_n)=1-(1-p)^n\to 1$$</p></li></ul><h3 id="可靠性分析"><a href="#可靠性分析" class="headerlink" title="可靠性分析"></a>可靠性分析</h3><p>设有$n$个独立工作的原件构成的系统, 第$i$个原件正常工作的事件记为$A_i$, 正常工作的概率$P(A_i)=p_i$, 系统正常工作的概率记为$B$</p><ol><li><strong>串联方式</strong>构成的系统<br>$$P(B_1)=P(A_1A_2\cdots A_n)=P(A_1)P(A_2)\cdots P(A_n)=p_1p_2\cdots p_n$$</li><li><strong>并联方式</strong>构成的系统<br>$$P(B_2)=P(A_1\cup A_2\cup\cdots\cup A_n)=1-P(\bar{A_1}\bar{A_2}\cdots \bar{A_n})=1-\prod_{i=1}^n(1-p_i)$$</li></ol><h2 id="独立重复试验模型"><a href="#独立重复试验模型" class="headerlink" title="独立重复试验模型"></a>独立重复试验模型</h2><ul><li><strong>$n$重伯努利试验</strong><ol><li>每次实验只有两个结果, $A$与$\bar{A}$, 且$P(A)=p$, $P(\bar{A})=1-p=q$</li><li>试验进行$n$次, 每次试验结果相互独立</li></ol></li><li><strong>定理1.5</strong><br>$n$重伯努利试验中, $A$发生$k$次的概率记为$P_n(k)$<br>$$P_n(k)=C_n^kp^kq^{n-k},(k=0,1,\cdots,n;q=1-p)$$<br>注意$\sum_{k=0}^nP_n(k)=\sum_{k=0}^nC_n^kp^kq^{n-k}=(p+q)^n=1$</li><li><strong>定理1.6</strong>（泊松定理）<br>设$n$为正整数, $\lambda=np_n$为常数, 则对任意正整数$k$有<br>$$\lim_{n\to\infty}C_n^kp_n^k(1-p_n)^{n-k}=\frac{\lambda^k}{k!}e^{-\lambda}$$<br>用于在$n$较大, $p$较小时进行近似计算</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Probability Course in 2019 Spring&lt;br&gt;
    
    </summary>
    
    
      <category term="Course" scheme="https://Maxwell-lyu.github.io/tags/Course/"/>
    
      <category term="Probability and Mathematical Statistics" scheme="https://Maxwell-lyu.github.io/tags/Probability-and-Mathematical-Statistics/"/>
    
  </entry>
  
  <entry>
    <title>Problem Solving IV 01</title>
    <link href="https://Maxwell-lyu.github.io/2019/01/30/Learn-PS-20190130-PS-IV-01/"/>
    <id>https://Maxwell-lyu.github.io/2019/01/30/Learn-PS-20190130-PS-IV-01/</id>
    <published>2019-01-30T03:07:53.000Z</published>
    <updated>2019-06-19T08:29:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>My note when <ruby> previewing<rt> Copying the Textbook of</rt> </ruby>  abstract algebra.<br><a id="more"></a> </p><h1 id="Chapter-3：Groups"><a href="#Chapter-3：Groups" class="headerlink" title="Chapter 3：Groups"></a>Chapter 3：Groups</h1><h2 id="Integer-Equivalence-Classes-and-Symmetries"><a href="#Integer-Equivalence-Classes-and-Symmetries" class="headerlink" title="Integer Equivalence Classes and Symmetries"></a>Integer Equivalence Classes and Symmetries</h2><h3 id="The-Integers-mod-n"><a href="#The-Integers-mod-n" class="headerlink" title="The Integers mod n"></a>The Integers mod n</h3><ul><li>模n和: addition modulo n: $(a+b)\%n$  </li><li><p>模n积: multiplication modulo n: $(ab)\%n$  </p></li><li><p><strong>Proposition 3.4</strong><br>Let $\mathbb{Z}_n$ be the set of equivalence classes of the integers mod $n$ and $a$, $b$, $c$ $\in$ $\mathbb{Z}_n$.</p><ol><li>communicative  交换律<blockquote><p>$a+b \equiv b+a\quad(mod\ n)$<br>$a\times b \equiv b\times a\quad(mod\ n)$  </p></blockquote></li><li>associative 结合律<blockquote><p>$(a+b)+c \equiv a+(b+c)\quad(mod\ n)$<br>$(a\times b)\times c \equiv a\times (b\times c)\quad(mod\ n)$   </p></blockquote></li><li>identities 特征值（0元素，数1<blockquote><p>$a+0 \equiv a\quad(mod\ n)$<br>$a\times1\equiv a\quad(mod\ n)$</p></blockquote></li><li>distribution 分配律<blockquote><p>$a\times(b+c)\equiv ab+ac\quad(mod\ n)$</p></blockquote></li><li>inverse 相反数（负元素<blockquote><p>$a+(-a)\equiv0\quad(mod\ n)$</p></blockquote></li><li>multiplicative inverse 倒数<blockquote><p>$a\ne 0$ required.<br>$gcd(a,n)=1\Leftrightarrow \exists b$, $a\times b \equiv 1\quad (mod\ n)$</p></blockquote></li></ol></li></ul><h3 id="Symmetries"><a href="#Symmetries" class="headerlink" title="Symmetries"></a>Symmetries</h3><ul><li><strong>Permutation</strong> of a set:</li><li><blockquote><p>a one-to-one and onto map $\pi:S\to S$</p></blockquote></li><li><strong>Symmetry</strong> of a geometric figure:  <blockquote><p>a rearrangement of the figure preserving the arrangement of its sides and vertices as well as its distances and angles.<br>边布局、点布局、长度和角度均不变，<ruby> [布局]<rt> Arrangement</rt> </ruby> 不考虑顶点标号的<ruby> [排列]<rt> Permutation</rt> </ruby> </p></blockquote></li><li><strong>Rigid Motion</strong> of an object：<blockquote><p>a map from the plane to itself preserving the symmetry.<br>不造成形变，到自身的映射，相当于重新分配点的标号<br>$A\to B, B\to C, A\to A$ is denoted as:<br>$$\begin{pmatrix}A &amp; B &amp; C \\ B &amp; C &amp; A\end{pmatrix}$$</p></blockquote></li><li><strong>Composing</strong> motion<blockquote><p>similar to composing functions/maps</p></blockquote></li></ul><h2 id="Definitions-and-Examples"><a href="#Definitions-and-Examples" class="headerlink" title="Definitions and Examples"></a>Definitions and Examples</h2><h3 id="Definitions"><a href="#Definitions" class="headerlink" title="Definitions"></a>Definitions</h3><ul><li><strong>Binary operations</strong> or <strong>Law of Composition</strong> on a set $G$:  <blockquote><p>$f:G\times G\to G$<br> every $(a,b)\in G\times G$ is mapped to a unique element denoted as $a\circ b$ or $ab$<br> 双射</p></blockquote></li><li><strong>Composition</strong> of 2 elements:  <blockquote><p>$a\circ b$ or $ab$</p></blockquote></li><li><strong>Group</strong> $(G,\circ)$<blockquote><p>a set $G$ together with a law of composition $(a,b)\mapsto a\circ b$ that satisfies the following 3 axioms:  </p><ol><li><strong>Associative</strong><br>$\forall a,b,c\in G$, $(a\circ b)\circ c=a\circ(b\circ c)$</li><li><strong>Identity Element</strong><br>$\forall a\in G$, $\exists e\in G$, $e\circ a=a\circ e=a$</li><li><strong>Inverse Element</strong><br>$\forall a\in G$, $\exists a^{-1}$ that $a\circ a^{-1}=a^{-1}\circ a=e$</li></ol></blockquote></li><li><strong>Abelian Group</strong> or <strong>Commutative Group</strong><blockquote><p>a group $(G,\circ )$ that $\forall a,b\in G$, $a\circ b=b\circ a$</p></blockquote></li><li><strong>Cayley Table</strong><blockquote><p>describe a group in terms of an addition or multiplication table<br>类似乘法表的形式，将每对元素映射的结果记录在表中</p></blockquote></li><li><strong>Order</strong> of a group<blockquote><p>A group is <strong>finite</strong>, or has <strong>finite order</strong>, if it contains a finite number of elements.<br>The order is $|G|=n$<br>Otherwise, the group is said to be <strong>infinite</strong> or to have <strong>infinite order</strong>.<br>The order is $|G|=\infty$  </p></blockquote></li></ul><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><ul><li><strong>Group of Units</strong> of $\mathbb{Z}_n$<blockquote><p>The set of all elements in $\mathbb{Z}_n$ that is relatively prime to $n$</p></blockquote></li><li><strong>Symmetries</strong> of an equilateral triangle form a nonabelian group.<blockquote><p>Described in Section 3.1</p></blockquote></li><li><strong>General Linear Group</strong><blockquote><p>The set of invertible matrices forms a group<br>只有可逆阵满足，群定义<ruby> [公理3]<rt> Inverse Element</rt> </ruby> </p></blockquote></li><li><strong>Quaternion Group</strong><blockquote><p>$Q_8=\{\pm 1,\pm I,\pm J,\pm K\}$<br>$1=\begin{pmatrix}1 &amp; 0 \\ 0 &amp; 1\end{pmatrix}$, $I=\begin{pmatrix}0 &amp; 1 \\ -1 &amp; 0\end{pmatrix}$, $J=\begin{pmatrix}0 &amp; i \\ i &amp; 0\end{pmatrix}$, $K=\begin{pmatrix}i &amp; 0 \\ 0 &amp; -i\end{pmatrix}$<br>$I^2=J^2=K^2=-1$<br>$IJ=K$, $JK=I$, $KI=J$, $JI=-K$, $KJ=-I$, $IK=-J$  </p></blockquote></li><li><strong>Nonzero Complex Number</strong><blockquote><p>$$z^{-1}=\frac{a-bi}{a^2+b^2}$$  </p></blockquote></li></ul><h3 id="Basic-Properties-of-Groups"><a href="#Basic-Properties-of-Groups" class="headerlink" title="Basic Properties of Groups"></a>Basic Properties of Groups</h3><ul><li><strong>Proposition 3.17</strong> 特征元素唯一<br>The <strong>identity element</strong> in a group G is <strong>unique</strong>.<blockquote><p><strong>Proof</strong>:<br>$e=e’e=e’$</p></blockquote></li><li><strong>Proposition 3.18</strong> 逆元素唯一<br>The <strong>inverse</strong> of an element in a group G is <strong>unique</strong>.<blockquote><p><strong>Proof</strong>:<br>$(g^{-1})=e(g^{-1})=(g^{-1})’g(g^{-1})=(g^{-1})’e=(g^{-1})’$</p></blockquote></li><li><strong>Proposition 3.19</strong> 取逆分配<br>Let $G$ be a group. If $a,b\in G$, then $(ab)^{-1}=b^{-1}a^{-1}$.<blockquote><p><strong>Proof</strong>:<br>$abb^{-1}a^{-1}=aea^{-1}=aa^{-1}=e$<br>$b^{-1}a^{-1}ab=b^{-1}eb=b^{-1}b=e$<br>Inverse is unique</p></blockquote></li><li><strong>Proposition 3.20</strong> 两次取逆<br>Let $G$ be a group. For any $a\in G$, $(a^{-1})^{-1}=a$.<blockquote><p><strong>Proof</strong>:<br>$(a^{-1})^{-1}=e(a^{-1})^{-1}=aa^{-1}(a^{-1})^{-1}=ae=a$  </p></blockquote></li><li><strong>Proposition 3.21</strong> 方程唯一解<br>Let $G$ be a group and $a,b\in G$. Then the equations $ax = b$ and $xa = b$ have unique solutions in $G$. The <strong>right and left cancellation laws</strong> are true in groups.<blockquote><p><strong>Proof</strong>:<br>$x_1=a^{-1}ax_1=a^{-1}ax_2=x_2$<br>$x_1=x_1aa^{-1}=x_2aa^{-1}=x_2$</p></blockquote></li><li><strong>Proposition 3.22</strong> 消去律<br>If $G$ is a group and $a,b,c\in G$, then $ba=ca\Rightarrow b=c$ and $ab=ac\Rightarrow b=c$. <blockquote><p><strong>Proof</strong>:<br>$ba=ca\Rightarrow baa^{-1}=caa^{-1}\Rightarrow b=c$<br>$ab=ac\Rightarrow a^{-1}ab=a^{-1}ac\Rightarrow b=c$</p></blockquote></li><li><strong>Exponential Notation</strong> for $g\in G$ and $n\in\mathbb{N}$ 幂  <blockquote><p>$g^0=e$<br>$g^n=g\cdot g\cdots g$(n times)<br>$g^{-n}=g^{-1}\cdot g^{-1}\cdots g^{-1}$(n times)</p></blockquote></li><li><strong>Theorem 3.23</strong>  <blockquote><ol><li>$g^mg^n=g^{m+n}$, $\forall m,n\in\mathbb{Z}$</li><li>$(g^m)^n=g^{mn}$, $\forall m,n\in\mathbb{Z}$</li><li>$(gh)^n=(h^{-1}g^{-1})^{-n}$, $\forall n\in\mathbb{Z}$</li><li>Only for abelian groups, $(gh)^n=g^nh^n$, $\forall n\in\mathbb{Z}$</li></ol></blockquote></li></ul><h2 id="Subgroups"><a href="#Subgroups" class="headerlink" title="Subgroups"></a>Subgroups</h2><h3 id="Definitions-1"><a href="#Definitions-1" class="headerlink" title="Definitions"></a>Definitions</h3><ul><li><strong>Subgroup</strong> $H$ of a group $G$ 子群  <blockquote><p>A subset H of G such that when the group operation of G is restricted to H, H is a group in its own right.<br>元素为子集，二元操作不变，仍满足群公理</p></blockquote></li><li><strong>Trivial Subgroup</strong><blockquote><p>$H=\{e\}$</p></blockquote></li><li><strong>Proper Subgroup</strong> 真子群<blockquote><p>$H\ne G$</p></blockquote></li></ul><h3 id="Examples-1"><a href="#Examples-1" class="headerlink" title="Examples"></a>Examples</h3><ul><li><strong>$\mathbb{Q}^*$</strong> is a subgroup of <strong>$\mathbb{R}^*$</strong><blockquote><p><strong>Proof</strong>:</p><ol><li>1 is the identity element</li><li>$(p/q)^{-1}=q/p$</li><li>Multiplication is associative in both $\mathbb{Q}^<em>$ and $\mathbb{R}^</em>$  </li></ol></blockquote></li><li><strong>$\{1,-1,i,-i\}$</strong> is a subgroup of <strong>$\mathbb{C}^*$</strong>  </li><li><p><strong>$SL_2(\mathbb{R})$</strong> is a subgroup of <strong>$GL_2(\mathbb{R})$</strong>  </p><blockquote><p><strong>$GL_2(\mathbb{R})$</strong>: general linear group.<br><strong>$SL_2(\mathbb{R})$</strong>: special linear group, matrices of determinant 1.  </p></blockquote><blockquote><p><strong>Proof</strong>:</p><ol><li>$I_2$ is the identity element.  </li><li>$A=\begin{pmatrix}a &amp; b \\ c &amp; d\end{pmatrix}$, $A^{-1}=\begin{pmatrix}d &amp; -b \\ -c &amp; a\end{pmatrix}$</li><li>Multiplication is associative.</li><li>The product also has determinant 1, by $|AB|=|A||B|$.</li></ol></blockquote></li><li>A subset $H$ of a group $G$ can be a group without being a subgroup of $G$.<blockquote><p>$(\mathbb{M}<em>{2\times 2},+)$ is a subset of but not a subgroup of $GL</em>{2}$.<br>此处二元操作不同，因而不是子群  </p></blockquote></li><li>One way of telling whether or not two groups are the same is by examining their subgroups.  <blockquote><p>判断群是否同构，可判断子群的数量及各自的大小是否相同  </p></blockquote></li></ul><h3 id="Some-Subgroup-Theorems"><a href="#Some-Subgroup-Theorems" class="headerlink" title="Some Subgroup Theorems"></a>Some Subgroup Theorems</h3><ul><li><p><strong>Proposition 3.30</strong> 子群充要条件1</p><blockquote><p>A subset H of G is a subgroup if and only if it satisfies the following conditions:  </p><ol><li>The identity $e$ of $G$ is in $H$.  </li><li>If $h_1$, $h_2\in H$, then $h_1h_2\in H$.  </li><li>If $h\in H$, then $h^{-1}\in H$.  </li></ol></blockquote><blockquote><p><strong>Proof</strong>:<br>$\Rightarrow$: </p><ol><li>$ee_H=e_H=e_He_H\Rightarrow e=e_H$</li><li>$H$ is a group</li><li>$H$ is a group, then $h(h^{-1})’=e$, $(h^{-1})’\in H$, also (h^{-1})’\in G$. By uniqueness of inverse, $(h^{-1})’=h^{-1}$.  </li></ol><p>$\Leftarrow$:<br>These conditions plus the associativity of the binary operation will prove that $H$ is a group.</p></blockquote></li><li><p><strong>Proposition 3.31</strong> 子群充要条件2</p><blockquote><p>Let $H$ be a subset of a group $G$. Then $H$ is a subgroup of $G$ if and only if $H\ne \emptyset$, and whenever $g$, $h\in H$ then $gh^{−1}$ is in $H$.  </p></blockquote><blockquote><p><strong>Proof</strong>:<br>$\Rightarrow$:<br>$h\in H\Rightarrow h^{-1}\in H\Rightarrow gh^{-1}\in H$</p><p>$\Leftarrow$:   </p><ol><li>Let $g=h$, we have $e\in H$</li><li>Let $g=h_1$, $h=h_2^{-1}$, we have $gh^{-1}=h_1(h_2^{-1})^{-1}=h_1h_2\in H$</li><li>Let $g=e$, we have $h^{-1}\in H$</li><li>By Proposition 3.30  </li></ol></blockquote></li></ul><h1 id="Chapter-4-Cyclic-Groups"><a href="#Chapter-4-Cyclic-Groups" class="headerlink" title="Chapter 4: Cyclic Groups"></a>Chapter 4: Cyclic Groups</h1><h2 id="Cyclic-Subgroups"><a href="#Cyclic-Subgroups" class="headerlink" title="Cyclic Subgroups"></a>Cyclic Subgroups</h2><h3 id="Definitions-2"><a href="#Definitions-2" class="headerlink" title="Definitions"></a>Definitions</h3><ul><li><strong>Cyclic Subgroup</strong> of a group $G$ generated by $a$: 循环子群<blockquote><p>$\langle a\rangle=\{a^k:k\in\mathbb{Z}\}$, $a\in G$  </p></blockquote></li><li><p><strong>Theorem 4.3</strong></p><blockquote><p>$\langle a\rangle$ is a subgroup of $G$.<br>$\langle a\rangle$ is the smallest subgroup of $G$ that contains a.  </p></blockquote><blockquote><p><strong>Proof</strong>:  </p><ol><li>$e=a^0\in \langle a\rangle$</li><li>$g=a^m\in \langle a\rangle$，$h=a^n\in \langle a\rangle$, then $gh=a^{m+n}\in \langle a\rangle$</li><li>$g=a^n\in \langle a\rangle$，then $g^{-1}=a^{-n}\in \langle a\rangle$  </li><li>Any subgroup $H$ containing $a$ must contain all powers of $a$, then $\langle a\rangle\subset H$, $\langle a\rangle$ is the smallest</li></ol></blockquote></li><li><strong>Cyclic Group</strong> $G$ 循环群<blockquote><p>$\exists a\in G$, $G=\langle a\rangle$</p></blockquote></li><li><strong>Generator</strong> of a cyclic group 生成元<blockquote><p>$a$ in $\langle a\rangle$</p></blockquote></li><li><strong>Order</strong> of a cyclic group $G$: 阶<blockquote><p>$a\in G$, the smallest positive integer $n$ that $a^n=e$<br>$|a|=n$<br>If there is no such $n$, $|a|=\infty$</p></blockquote></li><li><p><strong>Theorem 4.9</strong></p><blockquote><p>Every cyclic group is abelian.</p></blockquote><blockquote><p><strong>Proof</strong>:<br>$g=a^r\in \langle a\rangle$，$h=a^s\in \langle a\rangle$, $gh=a^ra^s=a^{r+s}=a^{s+r}=a^sa^r=hg$</p></blockquote></li></ul><h3 id="Subgroups-of-Cyclic-Groups"><a href="#Subgroups-of-Cyclic-Groups" class="headerlink" title="Subgroups of Cyclic Groups"></a>Subgroups of Cyclic Groups</h3><ul><li><p><strong>Theorem 4.10</strong></p><blockquote><p>Every subgroup of a cyclic group is cyclic.</p></blockquote><blockquote><p><strong>Proof</strong>: (Brief Version)<br>Let $m$ be the smallest natural number such that $a^m\in H$. Such an $m$ exists by the Principle of Well-Ordering.<br>$h=a^m\in H$, we must show that every $h’\in H$ can be written as a power of $h$<br>$h’=a^k=a^{mq+r}=(a^m)^qa^r=h^qa^r\in H$, where $0\leq r&lt;m$<br>$a^r=a^kh^{-q}$, then $a^r\in H$<br>$r=0$, because $m$ is the smallest positive integer that $a^m\in H$<br>$h’=h^q$<br>$H=\langle h\rangle$ is a cyclic group</p></blockquote></li><li><strong>Corollary 4.11</strong><blockquote><p>The The subgroups of $\mathbb{Z}$ are exactly $n\mathbb{Z}$ for $n=1,2,\cdots$.</p></blockquote></li><li><p><strong>Proposition 4.12</strong></p><blockquote><p>Let $G$ be a cyclic group of order $n$ and suppose that $a$ is a generator for $G$. Then $a^k = e$ if and only if $n$ divides $k$.</p></blockquote><blockquote><p><strong>Proof</strong>:<br>$\Rightarrow$:<br>$e=a^k=a^{nq+r}=a^{nq}a^r=ea^r=a^r$<br>$r=0$, $n$ divides $k$ </p><p>$\Leftarrow$:<br>$a^k=a^{ns}=(a^n)^s=e^s=e$</p></blockquote></li><li><p><strong>Theorem 4.13</strong></p><blockquote><p>Let G be a cyclic group of order n and suppose that $a\in G$ is a generator of the group. If $b=a^k$, then the order of $b$ is $n/d$, where $d = gcd(k,n)$.</p></blockquote><blockquote><p><strong>Proof</strong>:<br>Suppose $e=b^m=a^{km}$<br>The order $m$ is the smallest integer $n$ that $n$ divides $km$<br>The smallest $km$ is $lcm(k,m)$, which is $kn/d$<br>Then $m=n/d$  </p></blockquote></li><li><strong>Corollary 4.14</strong>  <blockquote><p>The generators of $\mathbb{Z}_n$ are the integers r such that $1\leq r&lt;n$ and $gcd(r,n) = 1$.<br>See the <strong>Group of Units</strong> of $\mathbb{Z}_n$  </p></blockquote></li></ul><h2 id="Multiplicative-Group-of-Complex-Numbers"><a href="#Multiplicative-Group-of-Complex-Numbers" class="headerlink" title="Multiplicative Group of Complex Numbers"></a>Multiplicative Group of Complex Numbers</h2><h3 id="Definitions-3"><a href="#Definitions-3" class="headerlink" title="Definitions"></a>Definitions</h3><ul><li><strong>Complex Numbers</strong> 复数<blockquote><p>$\mathbb{C}=\{a+bi:a,b\in\mathbb{R}\}$<br>$a$ is <strong>Real Part</strong> 实部<br>$b$ is <strong>Imaginary Part</strong> 虚部  </p></blockquote></li><li><strong>Rectangular</strong> or <strong>Cartesian</strong><blockquote><p>$z=a+bi$</p></blockquote></li><li><strong>Complex Conjugate</strong> 共轭复数<blockquote><p>$z^*=a-bi$</p></blockquote></li><li><strong>Absolute Value</strong> or <strong>Modulus</strong><blockquote><p>$|z|=\sqrt{a^2+b^2}$</p></blockquote></li><li><strong>Polar Coordinates</strong>  <blockquote><p>$z=r(\cos\theta+i\sin\theta)=r\textrm{cis}(\theta)$<br>$r=|z|$  </p></blockquote></li></ul><h3 id="Theorems"><a href="#Theorems" class="headerlink" title="Theorems"></a>Theorems</h3><ul><li><strong>Proposition 4.20</strong>  <blockquote><p>$z=r\textrm{cis}\theta$, $w=s\textrm{cis}\phi$<br>$zw=rs\textrm{cis}(\theta+\phi)$  </p></blockquote></li><li><p><strong>Theorem 4.22</strong> DeMoivre</p><blockquote><p>$[r\textrm{cis}\theta]^n=r^n\textrm{cis}(n\theta)$</p></blockquote><blockquote><p><strong>Proof</strong>:<br>Induction on n.</p></blockquote></li></ul><h3 id="The-Circle-Group-and-the-Roots-of-Unity"><a href="#The-Circle-Group-and-the-Roots-of-Unity" class="headerlink" title="The Circle Group and the Roots of Unity"></a>The Circle Group and the Roots of Unity</h3><ul><li><strong>Circle Group</strong><blockquote><p>$\mathbb{T}=\{z\in\mathbb{C}:|z|=1\}$</p></blockquote></li><li><strong>Proposition 4.24</strong>  <blockquote><p>The circle group is a subgroup of $\mathbb{C}$</p></blockquote></li><li><strong>$n$-th Roots of Unity</strong><blockquote><p>The $z$ satisfying $z^n=1$</p></blockquote></li><li><p><strong>Theorem 4.25</strong>  </p><blockquote><p>The $n$-th roots of unity is $z=\textrm{cis}(\frac{2k\pi}{n})$  </p></blockquote><blockquote><p><strong>Proof</strong>:<br>$z^n=\textrm{cis}(2k\pi)=1$  </p></blockquote></li><li><strong>Primitive $n$-th Root of Unity</strong>  <blockquote><p>A generator for the group of the nth roots of unity.</p></blockquote></li></ul><h2 id="The-Method-of-Repeated-Squares"><a href="#The-Method-of-Repeated-Squares" class="headerlink" title="The Method of Repeated Squares"></a>The Method of Repeated Squares</h2><ul><li>Calculate $x^a(\textrm{mod }b)$  </li><li>First: $a=\sum{2^{a_i}}$  </li><li>Calculate: $x^{2^{a_i}}(\textrm{mod }b)$ (This is quick)</li><li>Add up.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;My note when &lt;ruby&gt; previewing&lt;rt&gt; Copying the Textbook of&lt;/rt&gt; &lt;/ruby&gt;  abstract algebra.&lt;br&gt;
    
    </summary>
    
    
      <category term="Course" scheme="https://Maxwell-lyu.github.io/tags/Course/"/>
    
      <category term="Problem Solving" scheme="https://Maxwell-lyu.github.io/tags/Problem-Solving/"/>
    
      <category term="Abstract Algebra" scheme="https://Maxwell-lyu.github.io/tags/Abstract-Algebra/"/>
    
  </entry>
  
  <entry>
    <title>Tag &amp; Category Test</title>
    <link href="https://Maxwell-lyu.github.io/2019/01/16/Tests-test/"/>
    <id>https://Maxwell-lyu.github.io/2019/01/16/Tests-test/</id>
    <published>2019-01-16T10:25:00.000Z</published>
    <updated>2019-01-16T11:07:50.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Test" scheme="https://Maxwell-lyu.github.io/categories/Test/"/>
    
    
      <category term="Administration" scheme="https://Maxwell-lyu.github.io/tags/Administration/"/>
    
      <category term="Test" scheme="https://Maxwell-lyu.github.io/tags/Test/"/>
    
  </entry>
  
  <entry>
    <title>Hello Hexo!</title>
    <link href="https://Maxwell-lyu.github.io/2019/01/13/Hello-Hexo/"/>
    <id>https://Maxwell-lyu.github.io/2019/01/13/Hello-Hexo/</id>
    <published>2019-01-13T14:30:37.000Z</published>
    <updated>2019-01-13T14:37:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="你好，博客"><a href="#你好，博客" class="headerlink" title="你好，博客"></a>你好，博客</h1><p>一直以来，总幻想着自已会时不时写点什么，让许多一闪而过的念头留下些许痕迹。然而，懒惰是强大的，一次次在键盘上打出的，只有WASD。<br>今天也许会变得不一样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;你好，博客&quot;&gt;&lt;a href=&quot;#你好，博客&quot; class=&quot;headerlink&quot; title=&quot;你好，博客&quot;&gt;&lt;/a&gt;你好，博客&lt;/h1&gt;&lt;p&gt;一直以来，总幻想着自已会时不时写点什么，让许多一闪而过的念头留下些许痕迹。然而，懒惰是强大的，一次次在键盘上打出的，
      
    
    </summary>
    
    
      <category term="Administration" scheme="https://Maxwell-lyu.github.io/tags/Administration/"/>
    
  </entry>
  
  <entry>
    <title>CM-KEY</title>
    <link href="https://Maxwell-lyu.github.io/1970/01/01/Learn-CM-20191006-CM-KEY/"/>
    <id>https://Maxwell-lyu.github.io/1970/01/01/Learn-CM-20191006-CM-KEY/</id>
    <published>1970-01-01T00:00:00.000Z</published>
    <updated>2019-10-09T13:23:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Basic-enumeration"><a href="#Basic-enumeration" class="headerlink" title="Basic enumeration"></a>Basic enumeration</h1><h1 id="Generating-Function"><a href="#Generating-Function" class="headerlink" title="Generating Function"></a>Generating Function</h1><h2 id="Generating-Functions"><a href="#Generating-Functions" class="headerlink" title="Generating Functions"></a>Generating Functions</h2><ul><li>Ordinary Generating Function: OGF<br>$$G(x)=\sum_{n\geq 0}^\infty a_nx^n$$</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Basic-enumeration&quot;&gt;&lt;a href=&quot;#Basic-enumeration&quot; class=&quot;headerlink&quot; title=&quot;Basic enumeration&quot;&gt;&lt;/a&gt;Basic enumeration&lt;/h1&gt;&lt;h1 id=&quot;Gener
      
    
    </summary>
    
    
      <category term="Course" scheme="https://Maxwell-lyu.github.io/tags/Course/"/>
    
      <category term="Combinatorics" scheme="https://Maxwell-lyu.github.io/tags/Combinatorics/"/>
    
  </entry>
  
</feed>
